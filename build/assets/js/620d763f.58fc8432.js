"use strict";(globalThis.webpackChunkmarkdown_web_app=globalThis.webpackChunkmarkdown_web_app||[]).push([[383],{632(n,e,i){i.r(e),i.d(e,{assets:()=>l,contentTitle:()=>a,default:()=>u,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var t=i(4848),r=i(8453);const o={id:"maximum-flow",title:"Maximum Flow"},a="Maximum Flow",s={id:"maximum-flow",title:"Maximum Flow",description:"Maximum Flow is a fundamental problem in network theory that involves finding the maximum amount of flow that can be sent from a source node to a sink node in a flow network. A flow network is a directed graph where each edge has a capacity (maximum amount of flow it can carry) and actual flow (amount currently passing through).",source:"@site/docs/maximum-flow.md",sourceDirName:".",slug:"/maximum-flow",permalink:"/markdown-web-app/maximum-flow",draft:!1,unlisted:!1,editUrl:"https://github.com/kalyxon/markdown-web-app/tree/main/docs/maximum-flow.md",tags:[],version:"current",frontMatter:{id:"maximum-flow",title:"Maximum Flow"},sidebar:"dsa",previous:{title:"Minimum Spanning Tree",permalink:"/markdown-web-app/minimum-spanning-tree"},next:{title:"Shortest Path",permalink:"/markdown-web-app/shortest-path"}},l={},c=[{value:"Key Concepts in Maximum Flow",id:"key-concepts-in-maximum-flow",level:2},{value:"DSA Maximum Flow Algorithms",id:"dsa-maximum-flow-algorithms",level:2},{value:"The Maximum Flow Problem",id:"the-maximum-flow-problem",level:3},{value:"DSA Ford-Fulkerson Algorithm",id:"dsa-ford-fulkerson-algorithm",level:2},{value:"How Ford-Fulkerson Works",id:"how-ford-fulkerson-works",level:3},{value:"Ford-Fulkerson Implementation",id:"ford-fulkerson-implementation",level:3},{value:"Ford-Fulkerson Complexity",id:"ford-fulkerson-complexity",level:3},{value:"DSA Edmonds-Karp Algorithm",id:"dsa-edmonds-karp-algorithm",level:2},{value:"How Edmonds-Karp Works",id:"how-edmonds-karp-works",level:3},{value:"Edmonds-Karp Implementation",id:"edmonds-karp-implementation",level:3},{value:"Edmonds-Karp Complexity",id:"edmonds-karp-complexity",level:3},{value:"Comparison: Ford-Fulkerson vs Edmonds-Karp",id:"comparison-ford-fulkerson-vs-edmonds-karp",level:2},{value:"Max-Flow Min-Cut Theorem",id:"max-flow-min-cut-theorem",level:2},{value:"Finding Minimum Cut",id:"finding-minimum-cut",level:3},{value:"Applications of Maximum Flow",id:"applications-of-maximum-flow",level:2},{value:"1. <strong>Network Routing</strong>",id:"1-network-routing",level:3},{value:"2. <strong>Bipartite Matching</strong>",id:"2-bipartite-matching",level:3},{value:"3. <strong>Supply Chain Optimization</strong>",id:"3-supply-chain-optimization",level:3},{value:"Advanced Maximum Flow Algorithms",id:"advanced-maximum-flow-algorithms",level:2},{value:"1. <strong>Dinic&#39;s Algorithm</strong> (More Efficient)",id:"1-dinics-algorithm-more-efficient",level:3},{value:"2. <strong>Push-Relabel Algorithm</strong>",id:"2-push-relabel-algorithm",level:3},{value:"Common Problems and Solutions",id:"common-problems-and-solutions",level:2},{value:"Problem 1: Multiple Sources and Sinks",id:"problem-1-multiple-sources-and-sinks",level:3},{value:"Problem 2: Vertex Capacities",id:"problem-2-vertex-capacities",level:3},{value:"Practice Problems",id:"practice-problems",level:2},{value:"Common Mistakes to Avoid",id:"common-mistakes-to-avoid",level:2},{value:"Visual Example: Maximum Flow Process",id:"visual-example-maximum-flow-process",level:2},{value:"Performance Considerations",id:"performance-considerations",level:2}];function d(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.header,{children:(0,t.jsx)(e.h1,{id:"maximum-flow",children:"Maximum Flow"})}),"\n",(0,t.jsx)(e.p,{children:"Maximum Flow is a fundamental problem in network theory that involves finding the maximum amount of flow that can be sent from a source node to a sink node in a flow network. A flow network is a directed graph where each edge has a capacity (maximum amount of flow it can carry) and actual flow (amount currently passing through)."}),"\n",(0,t.jsx)(e.h2,{id:"key-concepts-in-maximum-flow",children:"Key Concepts in Maximum Flow"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Flow Network"}),": Directed graph G = (V, E) with:"]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Source node 's' (where flow originates)"}),"\n",(0,t.jsx)(e.li,{children:"Sink node 't' (where flow terminates)"}),"\n",(0,t.jsx)(e.li,{children:"Capacity c(u,v) \u2265 0 for each edge (u,v) \u2208 E"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Flow Constraints"}),":"]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Capacity Constraint"}),": f(u,v) \u2264 c(u,v) for all edges"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Flow Conservation"}),": \u03a3 f(u,v) = \u03a3 f(v,w) for all v \u2260 s,t"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Skew Symmetry"}),": f(u,v) = -f(v,u)"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Residual Graph"}),": Represents remaining capacity after current flow"]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Augmenting Path"}),": Path from source to sink in residual graph"]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Minimum Cut"}),": Minimum capacity cut separating source from sink (Max-Flow Min-Cut Theorem)"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"dsa-maximum-flow-algorithms",children:"DSA Maximum Flow Algorithms"}),"\n",(0,t.jsx)(e.h3,{id:"the-maximum-flow-problem",children:"The Maximum Flow Problem"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\nusing namespace std;\n\nclass Graph {\nprivate:\n    int V;\n    vector<vector<int>> capacity;\n    vector<vector<int>> flow;\n    \npublic:\n    Graph(int vertices) : V(vertices) {\n        capacity.resize(V, vector<int>(V, 0));\n        flow.resize(V, vector<int>(V, 0));\n    }\n    \n    void addEdge(int u, int v, int cap) {\n        capacity[u][v] = cap;\n    }\n    \n    int getCapacity(int u, int v) {\n        return capacity[u][v];\n    }\n    \n    int getFlow(int u, int v) {\n        return flow[u][v];\n    }\n    \n    void setFlow(int u, int v, int f) {\n        flow[u][v] = f;\n    }\n    \n    int getVertices() {\n        return V;\n    }\n};\n\n// Utility function to print flow network\nvoid printFlowNetwork(Graph& g, int source, int sink) {\n    int V = g.getVertices();\n    \n    cout << "Flow Network:" << endl;\n    cout << "Source: " << source << ", Sink: " << sink << endl;\n    cout << "Edges (u -> v): capacity / flow" << endl;\n    \n    int totalFlow = 0;\n    for (int u = 0; u < V; u++) {\n        for (int v = 0; v < V; v++) {\n            int cap = g.getCapacity(u, v);\n            int f = g.getFlow(u, v);\n            if (cap > 0) {\n                cout << u << " -> " << v << ": " << cap << " / " << f << endl;\n                if (u == source) {\n                    totalFlow += f;\n                }\n            }\n        }\n    }\n    cout << "Current total flow from source: " << totalFlow << endl << endl;\n}\n'})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Example Network:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"    10        5\n (0)----\x3e(1)----\x3e(3)\n  |       |       ^\n  |10     |5      |10\n  v       v       |\n (2)----\x3e(4)----\x3e(5)\n    15       10\nSource: 0, Sink: 5\n"})}),"\n",(0,t.jsx)(e.h2,{id:"dsa-ford-fulkerson-algorithm",children:"DSA Ford-Fulkerson Algorithm"}),"\n",(0,t.jsx)(e.p,{children:"The Ford-Fulkerson method is a greedy approach for computing maximum flow. It repeatedly finds augmenting paths in the residual graph and augments flow until no more augmenting paths exist."}),"\n",(0,t.jsx)(e.h3,{id:"how-ford-fulkerson-works",children:"How Ford-Fulkerson Works"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Initialize"}),": Start with zero flow"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Find Augmenting Path"}),": Find any path from source to sink with positive residual capacity"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Augment Flow"}),": Push the minimum residual capacity along the path"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Update Residual Graph"}),": Update forward and backward edges"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Repeat"}),": Until no augmenting path exists"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"ford-fulkerson-implementation",children:"Ford-Fulkerson Implementation"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\n#include <algorithm>\nusing namespace std;\n\n// DFS for finding augmenting path (used in Ford-Fulkerson)\nbool dfs(vector<vector<int>>& residual, int source, int sink, vector<int>& parent) {\n    int V = residual.size();\n    vector<bool> visited(V, false);\n    \n    // Stack for DFS\n    vector<int> stack;\n    stack.push_back(source);\n    visited[source] = true;\n    parent[source] = -1;\n    \n    while (!stack.empty()) {\n        int u = stack.back();\n        stack.pop_back();\n        \n        for (int v = 0; v < V; v++) {\n            if (!visited[v] && residual[u][v] > 0) {\n                parent[v] = u;\n                visited[v] = true;\n                \n                if (v == sink) {\n                    return true;\n                }\n                stack.push_back(v);\n            }\n        }\n    }\n    \n    return visited[sink];\n}\n\n// Ford-Fulkerson Algorithm Implementation\nint fordFulkerson(vector<vector<int>>& capacity, int source, int sink) {\n    int V = capacity.size();\n    \n    // Create residual graph and initialize with capacities\n    vector<vector<int>> residual(V, vector<int>(V, 0));\n    for (int u = 0; u < V; u++) {\n        for (int v = 0; v < V; v++) {\n            residual[u][v] = capacity[u][v];\n        }\n    }\n    \n    vector<int> parent(V);\n    int maxFlow = 0;\n    int iteration = 0;\n    \n    cout << "=== Ford-Fulkerson Algorithm ===" << endl;\n    \n    // Augment flow while there\'s a path from source to sink\n    while (dfs(residual, source, sink, parent)) {\n        iteration++;\n        \n        // Find minimum residual capacity along the path\n        int pathFlow = INT_MAX;\n        for (int v = sink; v != source; v = parent[v]) {\n            int u = parent[v];\n            pathFlow = min(pathFlow, residual[u][v]);\n        }\n        \n        // Update residual capacities and reverse edges\n        cout << "\\nIteration " << iteration << ":";\n        cout << "\\nAugmenting path: ";\n        vector<int> path;\n        for (int v = sink; v != source; v = parent[v]) {\n            int u = parent[v];\n            path.push_back(v);\n            residual[u][v] -= pathFlow;\n            residual[v][u] += pathFlow;\n        }\n        path.push_back(source);\n        reverse(path.begin(), path.end());\n        \n        for (int i = 0; i < path.size(); i++) {\n            cout << path[i];\n            if (i < path.size() - 1) cout << " -> ";\n        }\n        cout << "\\nFlow augmented: " << pathFlow << endl;\n        \n        // Add path flow to overall flow\n        maxFlow += pathFlow;\n        cout << "Total flow so far: " << maxFlow << endl;\n    }\n    \n    cout << "\\nMaximum flow: " << maxFlow << endl;\n    return maxFlow;\n}\n\nint main() {\n    // Create a flow network\n    int V = 6;\n    vector<vector<int>> capacity(V, vector<int>(V, 0));\n    \n    // Example network from CLRS\n    capacity[0][1] = 16;\n    capacity[0][2] = 13;\n    capacity[1][2] = 10;\n    capacity[1][3] = 12;\n    capacity[2][1] = 4;\n    capacity[2][4] = 14;\n    capacity[3][2] = 9;\n    capacity[3][5] = 20;\n    capacity[4][3] = 7;\n    capacity[4][5] = 4;\n    \n    int source = 0, sink = 5;\n    \n    cout << "Initial Network:" << endl;\n    for (int u = 0; u < V; u++) {\n        for (int v = 0; v < V; v++) {\n            if (capacity[u][v] > 0) {\n                cout << u << " -> " << v << ": " << capacity[u][v] << endl;\n            }\n        }\n    }\n    \n    int maxFlow = fordFulkerson(capacity, source, sink);\n    \n    return 0;\n}\n'})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Output:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"Initial Network:\n0 -> 1: 16\n0 -> 2: 13\n1 -> 2: 10\n1 -> 3: 12\n2 -> 1: 4\n2 -> 4: 14\n3 -> 2: 9\n3 -> 5: 20\n4 -> 3: 7\n4 -> 5: 4\n\n=== Ford-Fulkerson Algorithm ===\n\nIteration 1:\nAugmenting path: 0 -> 1 -> 3 -> 5\nFlow augmented: 12\nTotal flow so far: 12\n\nIteration 2:\nAugmenting path: 0 -> 2 -> 4 -> 5\nFlow augmented: 4\nTotal flow so far: 16\n\nIteration 3:\nAugmenting path: 0 -> 2 -> 4 -> 3 -> 5\nFlow augmented: 7\nTotal flow so far: 23\n\nMaximum flow: 23\n"})}),"\n",(0,t.jsx)(e.h3,{id:"ford-fulkerson-complexity",children:"Ford-Fulkerson Complexity"}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Time Complexity:"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"O(E \xd7 max_flow) in worst case"}),"\n",(0,t.jsx)(e.li,{children:"Depends on the choice of augmenting paths"}),"\n",(0,t.jsx)(e.li,{children:"Can be exponential for poor path choices"}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Space Complexity:"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"O(V\xb2) for adjacency matrix representation"}),"\n",(0,t.jsx)(e.li,{children:"O(V + E) for adjacency list representation"}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Advantages:"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Simple to understand and implement"}),"\n",(0,t.jsx)(e.li,{children:"Works for both integer and real-valued capacities"}),"\n",(0,t.jsx)(e.li,{children:"Guaranteed to find maximum flow"}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Disadvantages:"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"May take exponential time with poor augmenting path choices"}),"\n",(0,t.jsx)(e.li,{children:"Not polynomial time in general case"}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"dsa-edmonds-karp-algorithm",children:"DSA Edmonds-Karp Algorithm"}),"\n",(0,t.jsx)(e.p,{children:"Edmonds-Karp is a specific implementation of Ford-Fulkerson that uses Breadth-First Search (BFS) to find the shortest augmenting path (in terms of number of edges). This guarantees polynomial time complexity."}),"\n",(0,t.jsx)(e.h3,{id:"how-edmonds-karp-works",children:"How Edmonds-Karp Works"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Initialize"}),": Start with zero flow"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"BFS"}),": Find shortest augmenting path from source to sink using BFS"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Augment Flow"}),": Push flow equal to minimum residual capacity along the path"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Update Residual Graph"}),": Update forward and backward edges"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Repeat"}),": Until no augmenting path exists"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"edmonds-karp-implementation",children:"Edmonds-Karp Implementation"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\n#include <algorithm>\nusing namespace std;\n\n// BFS for finding shortest augmenting path\nbool bfs(vector<vector<int>>& residual, int source, int sink, vector<int>& parent) {\n    int V = residual.size();\n    vector<bool> visited(V, false);\n    \n    queue<int> q;\n    q.push(source);\n    visited[source] = true;\n    parent[source] = -1;\n    \n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        \n        for (int v = 0; v < V; v++) {\n            if (!visited[v] && residual[u][v] > 0) {\n                parent[v] = u;\n                visited[v] = true;\n                \n                if (v == sink) {\n                    return true;\n                }\n                q.push(v);\n            }\n        }\n    }\n    \n    return visited[sink];\n}\n\n// Edmonds-Karp Algorithm Implementation\nint edmondsKarp(vector<vector<int>>& capacity, int source, int sink) {\n    int V = capacity.size();\n    \n    // Create residual graph\n    vector<vector<int>> residual(V, vector<int>(V, 0));\n    for (int u = 0; u < V; u++) {\n        for (int v = 0; v < V; v++) {\n            residual[u][v] = capacity[u][v];\n        }\n    }\n    \n    vector<int> parent(V);\n    int maxFlow = 0;\n    int iteration = 0;\n    \n    cout << "=== Edmonds-Karp Algorithm ===" << endl;\n    \n    // Augment flow while there\'s a path from source to sink\n    while (bfs(residual, source, sink, parent)) {\n        iteration++;\n        \n        // Find minimum residual capacity along the path\n        int pathFlow = INT_MAX;\n        for (int v = sink; v != source; v = parent[v]) {\n            int u = parent[v];\n            pathFlow = min(pathFlow, residual[u][v]);\n        }\n        \n        // Update residual capacities\n        cout << "\\nIteration " << iteration << ":";\n        cout << "\\nShortest augmenting path (BFS): ";\n        \n        vector<int> path;\n        for (int v = sink; v != source; v = parent[v]) {\n            int u = parent[v];\n            path.push_back(v);\n            residual[u][v] -= pathFlow;\n            residual[v][u] += pathFlow;\n        }\n        path.push_back(source);\n        reverse(path.begin(), path.end());\n        \n        for (int i = 0; i < path.size(); i++) {\n            cout << path[i];\n            if (i < path.size() - 1) cout << " -> ";\n        }\n        cout << "\\nFlow augmented: " << pathFlow << endl;\n        \n        // Add path flow to overall flow\n        maxFlow += pathFlow;\n        cout << "Total flow so far: " << maxFlow << endl;\n    }\n    \n    cout << "\\nMaximum flow: " << maxFlow << endl;\n    return maxFlow;\n}\n\n// Find minimum cut (S-T cut) after running max flow\nvoid findMinCut(vector<vector<int>>& residual, int source) {\n    int V = residual.size();\n    vector<bool> visited(V, false);\n    \n    // BFS to find reachable vertices from source in residual graph\n    queue<int> q;\n    q.push(source);\n    visited[source] = true;\n    \n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        \n        for (int v = 0; v < V; v++) {\n            if (!visited[v] && residual[u][v] > 0) {\n                visited[v] = true;\n                q.push(v);\n            }\n        }\n    }\n    \n    cout << "\\nMinimum Cut (S-T Cut):" << endl;\n    cout << "Set S (reachable from source): ";\n    for (int i = 0; i < V; i++) {\n        if (visited[i]) cout << i << " ";\n    }\n    \n    cout << "\\nSet T (not reachable): ";\n    for (int i = 0; i < V; i++) {\n        if (!visited[i]) cout << i << " ";\n    }\n    cout << endl;\n}\n\nint main() {\n    // Create the same flow network\n    int V = 6;\n    vector<vector<int>> capacity(V, vector<int>(V, 0));\n    \n    capacity[0][1] = 16;\n    capacity[0][2] = 13;\n    capacity[1][2] = 10;\n    capacity[1][3] = 12;\n    capacity[2][1] = 4;\n    capacity[2][4] = 14;\n    capacity[3][2] = 9;\n    capacity[3][5] = 20;\n    capacity[4][3] = 7;\n    capacity[4][5] = 4;\n    \n    int source = 0, sink = 5;\n    \n    cout << "Network Representation:" << endl;\n    cout << "    16         12" << endl;\n    cout << " (0)----\x3e(1)----\x3e(3)" << endl;\n    cout << "   | \\\\    /|      |" << endl;\n    cout << " 13|  \\\\ /  |10    |20" << endl;\n    cout << "   |   X   |      |" << endl;\n    cout << "   |  / \\\\  |      |" << endl;\n    cout << "   v /   \\\\ v      v" << endl;\n    cout << " (2)----\x3e(4)----\x3e(5)" << endl;\n    cout << "     14        4" << endl;\n    cout << "Source: 0, Sink: 5\\n" << endl;\n    \n    int maxFlow = edmondsKarp(capacity, source, sink);\n    \n    // Create residual graph for min-cut demonstration\n    vector<vector<int>> residual(V, vector<int>(V, 0));\n    for (int u = 0; u < V; u++) {\n        for (int v = 0; v < V; v++) {\n            residual[u][v] = capacity[u][v];\n        }\n    }\n    \n    // Run BFS to prepare for min-cut\n    vector<int> parent(V);\n    while (bfs(residual, source, sink, parent)) {\n        int pathFlow = INT_MAX;\n        for (int v = sink; v != source; v = parent[v]) {\n            int u = parent[v];\n            pathFlow = min(pathFlow, residual[u][v]);\n        }\n        \n        for (int v = sink; v != source; v = parent[v]) {\n            int u = parent[v];\n            residual[u][v] -= pathFlow;\n            residual[v][u] += pathFlow;\n        }\n    }\n    \n    findMinCut(residual, source);\n    \n    return 0;\n}\n'})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Output:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"Network Representation:\n    16         12\n (0)----\x3e(1)----\x3e(3)\n   | \\    /|      |\n 13|  \\ /  |10    |20\n   |   X   |      |\n   |  / \\  |      |\n   v /   \\ v      v\n (2)----\x3e(4)----\x3e(5)\n     14        4\nSource: 0, Sink: 5\n\n=== Edmonds-Karp Algorithm ===\n\nIteration 1:\nShortest augmenting path (BFS): 0 -> 1 -> 3 -> 5\nFlow augmented: 12\nTotal flow so far: 12\n\nIteration 2:\nShortest augmenting path (BFS): 0 -> 2 -> 4 -> 5\nFlow augmented: 4\nTotal flow so far: 16\n\nIteration 3:\nShortest augmenting path (BFS): 0 -> 2 -> 4 -> 3 -> 5\nFlow augmented: 7\nTotal flow so far: 23\n\nMaximum flow: 23\n\nMinimum Cut (S-T Cut):\nSet S (reachable from source): 0 2 4 \nSet T (not reachable): 1 3 5\n"})}),"\n",(0,t.jsx)(e.h3,{id:"edmonds-karp-complexity",children:"Edmonds-Karp Complexity"}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Time Complexity:"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"O(V \xd7 E\xb2) - Polynomial time"}),"\n",(0,t.jsx)(e.li,{children:"BFS takes O(E) time"}),"\n",(0,t.jsx)(e.li,{children:"At most O(VE) augmentations"}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Space Complexity:"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"O(V\xb2) for adjacency matrix"}),"\n",(0,t.jsx)(e.li,{children:"O(V + E) for adjacency list"}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Advantages:"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Guaranteed polynomial time (O(VE\xb2))"}),"\n",(0,t.jsx)(e.li,{children:"Always finds the shortest augmenting path"}),"\n",(0,t.jsx)(e.li,{children:"More efficient than basic Ford-Fulkerson"}),"\n",(0,t.jsx)(e.li,{children:"Implementation is straightforward"}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Disadvantages:"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Slower than more advanced algorithms like Dinic's"}),"\n",(0,t.jsx)(e.li,{children:"Still not the most efficient for large networks"}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"comparison-ford-fulkerson-vs-edmonds-karp",children:"Comparison: Ford-Fulkerson vs Edmonds-Karp"}),"\n",(0,t.jsxs)(e.table,{children:[(0,t.jsx)(e.thead,{children:(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.th,{children:"Aspect"}),(0,t.jsx)(e.th,{children:"Ford-Fulkerson"}),(0,t.jsx)(e.th,{children:"Edmonds-Karp"})]})}),(0,t.jsxs)(e.tbody,{children:[(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:(0,t.jsx)(e.strong,{children:"Path Finding"})}),(0,t.jsx)(e.td,{children:"DFS (any path)"}),(0,t.jsx)(e.td,{children:"BFS (shortest path)"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:(0,t.jsx)(e.strong,{children:"Time Complexity"})}),(0,t.jsx)(e.td,{children:"O(E \xd7 max_flow)"}),(0,t.jsx)(e.td,{children:"O(V \xd7 E\xb2)"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:(0,t.jsx)(e.strong,{children:"Guarantee"})}),(0,t.jsx)(e.td,{children:"May be exponential"}),(0,t.jsx)(e.td,{children:"Polynomial time"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:(0,t.jsx)(e.strong,{children:"Implementation"})}),(0,t.jsx)(e.td,{children:"Simpler"}),(0,t.jsx)(e.td,{children:"Slightly more complex"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:(0,t.jsx)(e.strong,{children:"Use Case"})}),(0,t.jsx)(e.td,{children:"Small networks, theoretical"}),(0,t.jsx)(e.td,{children:"Practical applications"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:(0,t.jsx)(e.strong,{children:"Performance"})}),(0,t.jsx)(e.td,{children:"Variable, depends on path choice"}),(0,t.jsx)(e.td,{children:"Consistent, predictable"})]})]})]}),"\n",(0,t.jsx)(e.h2,{id:"max-flow-min-cut-theorem",children:"Max-Flow Min-Cut Theorem"}),"\n",(0,t.jsxs)(e.p,{children:["The fundamental theorem of network flows states that:\n",(0,t.jsx)(e.strong,{children:"Maximum flow from source to sink = Minimum capacity of an s-t cut"})]}),"\n",(0,t.jsx)(e.h3,{id:"finding-minimum-cut",children:"Finding Minimum Cut"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'// Function to demonstrate Max-Flow Min-Cut Theorem\nvoid maxFlowMinCutTheorem() {\n    cout << "\\n=== Max-Flow Min-Cut Theorem ===" << endl;\n    cout << "Theorem: In any flow network:" << endl;\n    cout << "1. Maximum flow from s to t = Minimum s-t cut capacity" << endl;\n    cout << "2. An s-t cut is a partition of vertices into S and T" << endl;\n    cout << "   where s \u2208 S and t \u2208 T" << endl;\n    cout << "3. Cut capacity = sum of capacities from S to T" << endl;\n    \n    cout << "\\nExample Proof:" << endl;\n    cout << "For our network with max flow = 23:" << endl;\n    cout << "Consider cut: S = {0, 2, 4}, T = {1, 3, 5}" << endl;\n    cout << "Edges crossing cut: 0->1(16), 2->1(4), 4->3(7), 4->5(4)" << endl;\n    cout << "But after max flow, some edges are saturated:" << endl;\n    cout << "0->1 carries 12/16, 4->3 carries 7/7 (saturated)" << endl;\n    cout << "2->1 carries 0/4 (reverse flow possible)" << endl;\n    cout << "4->5 carries 4/4 (saturated)" << endl;\n    cout << "Cut capacity = 12 + 0 + 7 + 4 = 23 = Max flow \u2713" << endl;\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"applications-of-maximum-flow",children:"Applications of Maximum Flow"}),"\n",(0,t.jsxs)(e.h3,{id:"1-network-routing",children:["1. ",(0,t.jsx)(e.strong,{children:"Network Routing"})]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:"// Example: Internet packet routing\nclass NetworkRouter {\npublic:\n    int findMaxBandwidth(vector<vector<int>>& bandwidth, int server, int client) {\n        // Bandwidth matrix represents maximum data rate between nodes\n        return edmondsKarp(bandwidth, server, client);\n    }\n};\n"})}),"\n",(0,t.jsxs)(e.h3,{id:"2-bipartite-matching",children:["2. ",(0,t.jsx)(e.strong,{children:"Bipartite Matching"})]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:"// Maximum bipartite matching using max flow\nint bipartiteMatching(vector<vector<int>>& adj, int m, int n) {\n    // Create flow network: source -> U -> V -> sink\n    int V = m + n + 2;\n    int source = V - 2, sink = V - 1;\n    \n    vector<vector<int>> capacity(V, vector<int>(V, 0));\n    \n    // Connect source to U vertices\n    for (int i = 0; i < m; i++) {\n        capacity[source][i] = 1;\n    }\n    \n    // Connect V vertices to sink\n    for (int j = 0; j < n; j++) {\n        capacity[m + j][sink] = 1;\n    }\n    \n    // Connect U to V based on adjacency\n    for (int i = 0; i < m; i++) {\n        for (int j : adj[i]) {\n            capacity[i][m + j] = 1;\n        }\n    }\n    \n    return edmondsKarp(capacity, source, sink);\n}\n"})}),"\n",(0,t.jsxs)(e.h3,{id:"3-supply-chain-optimization",children:["3. ",(0,t.jsx)(e.strong,{children:"Supply Chain Optimization"})]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:"// Factory to warehouse distribution\nclass SupplyChain {\npublic:\n    int optimizeDistribution(vector<int>& factoryOutput, \n                            vector<int>& warehouseDemand,\n                            vector<vector<int>>& transportCapacity) {\n        // Add super source and super sink\n        int factories = factoryOutput.size();\n        int warehouses = warehouseDemand.size();\n        int V = factories + warehouses + 2;\n        int source = V - 2, sink = V - 1;\n        \n        vector<vector<int>> capacity(V, vector<int>(V, 0));\n        \n        // Connect source to factories\n        for (int i = 0; i < factories; i++) {\n            capacity[source][i] = factoryOutput[i];\n        }\n        \n        // Connect warehouses to sink\n        for (int j = 0; j < warehouses; j++) {\n            capacity[factories + j][sink] = warehouseDemand[j];\n        }\n        \n        // Connect factories to warehouses\n        for (int i = 0; i < factories; i++) {\n            for (int j = 0; j < warehouses; j++) {\n                capacity[i][factories + j] = transportCapacity[i][j];\n            }\n        }\n        \n        return edmondsKarp(capacity, source, sink);\n    }\n};\n"})}),"\n",(0,t.jsx)(e.h2,{id:"advanced-maximum-flow-algorithms",children:"Advanced Maximum Flow Algorithms"}),"\n",(0,t.jsxs)(e.h3,{id:"1-dinics-algorithm-more-efficient",children:["1. ",(0,t.jsx)(e.strong,{children:"Dinic's Algorithm"})," (More Efficient)"]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Time Complexity: O(V\xb2E) or O(E\u221aV) for unit capacities"}),"\n",(0,t.jsx)(e.li,{children:"Uses BFS for level graph + DFS for blocking flow"}),"\n"]}),"\n",(0,t.jsxs)(e.h3,{id:"2-push-relabel-algorithm",children:["2. ",(0,t.jsx)(e.strong,{children:"Push-Relabel Algorithm"})]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Time Complexity: O(V\xb3) or O(V\xb2\u221aE)"}),"\n",(0,t.jsx)(e.li,{children:"More complex but very efficient in practice"}),"\n",(0,t.jsx)(e.li,{children:"Uses height labels and excess flow"}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"common-problems-and-solutions",children:"Common Problems and Solutions"}),"\n",(0,t.jsx)(e.h3,{id:"problem-1-multiple-sources-and-sinks",children:"Problem 1: Multiple Sources and Sinks"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Solution"}),": Add super source and super sink"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:"int maxFlowMultipleSourcesSinks(vector<vector<int>>& capacity, \n                               vector<int>& sources, \n                               vector<int>& sinks) {\n    int V = capacity.size();\n    int superSource = V, superSink = V + 1;\n    V += 2;\n    \n    vector<vector<int>> newCapacity(V, vector<int>(V, 0));\n    \n    // Copy original capacities\n    for (int i = 0; i < capacity.size(); i++) {\n        for (int j = 0; j < capacity[i].size(); j++) {\n            newCapacity[i][j] = capacity[i][j];\n        }\n    }\n    \n    // Connect super source to all sources\n    for (int s : sources) {\n        newCapacity[superSource][s] = INT_MAX;\n    }\n    \n    // Connect all sinks to super sink\n    for (int t : sinks) {\n        newCapacity[t][superSink] = INT_MAX;\n    }\n    \n    return edmondsKarp(newCapacity, superSource, superSink);\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"problem-2-vertex-capacities",children:"Problem 2: Vertex Capacities"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Solution"}),": Split each vertex into in-vertex and out-vertex"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:"int maxFlowVertexCapacities(vector<vector<int>>& edgeCapacity,\n                           vector<int>& vertexCapacity, \n                           int source, int sink) {\n    int V = edgeCapacity.size();\n    int newV = 2 * V;\n    \n    vector<vector<int>> newCapacity(newV, vector<int>(newV, 0));\n    \n    // Split each vertex v into v_in and v_out\n    for (int v = 0; v < V; v++) {\n        int v_in = 2 * v;\n        int v_out = 2 * v + 1;\n        \n        // Edge from v_in to v_out with vertex capacity\n        newCapacity[v_in][v_out] = vertexCapacity[v];\n        \n        // Redirect original edges\n        for (int u = 0; u < V; u++) {\n            if (edgeCapacity[u][v] > 0) {\n                int u_out = 2 * u + 1;\n                newCapacity[u_out][v_in] = edgeCapacity[u][v];\n            }\n        }\n    }\n    \n    return edmondsKarp(newCapacity, 2 * source, 2 * sink + 1);\n}\n"})}),"\n",(0,t.jsx)(e.h2,{id:"practice-problems",children:"Practice Problems"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Basic Maximum Flow"}),": Find max flow in given network"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Bipartite Matching"}),": Maximum number of job assignments"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Edge Disjoint Paths"}),": Maximum number of paths with no common edges"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Circulation with Demands"}),": Flow network with vertex demands"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Maximum Flow with Lower Bounds"}),": Edges have minimum required flow"]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"common-mistakes-to-avoid",children:"Common Mistakes to Avoid"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Forgetting reverse edges"}),": Crucial for algorithm correctness"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Not handling multiple edges"}),": Sum capacities for parallel edges"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Integer overflow"}),": Use long long for large capacities"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Infinite loops"}),": Ensure proper termination conditions"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Wrong residual graph updates"}),": Update both forward and backward edges"]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"visual-example-maximum-flow-process",children:"Visual Example: Maximum Flow Process"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"Initial Network:\n    10       4\n s-----\x3eA-----\x3et\n |      |      ^\n |5     |3     |8\n v      v      |\n B-----\x3eC------+\n    9       6\n\nStep 1: Find path s->A->t, flow = 4\nStep 2: Find path s->B->C->t, flow = 6\nStep 3: Find path s->A->C->t, flow = 3\nStep 4: Find path s->B->t, flow = 5\n\nTotal Flow = 4 + 6 + 3 + 5 = 18\n\nResidual Graph after max flow:\n    (6)       (0)   // Numbers show remaining capacity\n s-----\x3eA-----\x3et\n |      |      ^\n |(0)   |(0)   |(2)\n v      v      |\n B-----\x3eC------+\n    (4)       (0)\n\nMinimum Cut: {s, A, B, C} to {t} with capacity 18\n"})}),"\n",(0,t.jsx)(e.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"For dense graphs"}),": Edmonds-Karp is usually sufficient"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"For large sparse graphs"}),": Consider Dinic's algorithm"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"For unit capacities"}),": Use specialized algorithms"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"For real-time applications"}),": Pre-compute or use approximate solutions"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Memory optimization"}),": Use adjacency lists instead of matrices"]}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:"Maximum flow algorithms are fundamental tools in computer science with wide-ranging applications from network design to combinatorial optimization. Understanding both Ford-Fulkerson and Edmonds-Karp provides a solid foundation for tackling complex flow problems."}),"\n",(0,t.jsx)(e.hr,{})]})}function u(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(d,{...n})}):d(n)}},8453(n,e,i){i.d(e,{R:()=>a,x:()=>s});var t=i(6540);const r={},o=t.createContext(r);function a(n){const e=t.useContext(o);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function s(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:a(n.components),t.createElement(o.Provider,{value:e},n.children)}}}]);