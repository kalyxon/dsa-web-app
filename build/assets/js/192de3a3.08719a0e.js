"use strict";(globalThis.webpackChunkmarkdown_web_app=globalThis.webpackChunkmarkdown_web_app||[]).push([[895],{8060(n,e,t){t.r(e),t.d(e,{assets:()=>o,contentTitle:()=>s,default:()=>u,frontMatter:()=>d,metadata:()=>c,toc:()=>a});var i=t(4848),r=t(8453);const d={id:"graphs",title:"Graphs"},s="Graphs",c={id:"graphs",title:"Graphs",description:"Introduction to Graphs",source:"@site/docs/graphs.md",sourceDirName:".",slug:"/graphs",permalink:"/markdown-web-app/graphs",draft:!1,unlisted:!1,editUrl:"https://github.com/kalyxon/markdown-web-app/tree/main/docs/graphs.md",tags:[],version:"current",frontMatter:{id:"graphs",title:"Graphs"},sidebar:"dsa",previous:{title:"Trees",permalink:"/markdown-web-app/trees"},next:{title:"Time Complexity",permalink:"/markdown-web-app/time-complexity"}},o={},a=[{value:"Introduction to Graphs",id:"introduction-to-graphs",level:2},{value:"Key Terminology:",id:"key-terminology",level:3},{value:"Graph Types:",id:"graph-types",level:3},{value:"Basic Graph Implementation",id:"basic-graph-implementation",level:2},{value:"Advanced Graph Implementations",id:"advanced-graph-implementations",level:2},{value:"Graph Traversal Algorithms",id:"graph-traversal-algorithms",level:2},{value:"Complete Graph Traversal Implementation",id:"complete-graph-traversal-implementation",level:2},{value:"Cycle Detection in Graphs",id:"cycle-detection-in-graphs",level:2},{value:"Types of Cycles:",id:"types-of-cycles",level:3},{value:"Complete Cycle Detection Implementation",id:"complete-cycle-detection-implementation",level:2},{value:"Summary",id:"summary",level:2},{value:"1. <strong>Graph Fundamentals</strong>",id:"1-graph-fundamentals",level:3},{value:"2. <strong>Graph Implementations</strong>",id:"2-graph-implementations",level:3},{value:"3. <strong>Graph Traversal</strong>",id:"3-graph-traversal",level:3},{value:"4. <strong>Cycle Detection</strong>",id:"4-cycle-detection",level:3},{value:"Key Takeaways:",id:"key-takeaways",level:3}];function l(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.header,{children:(0,i.jsx)(e.h1,{id:"graphs",children:"Graphs"})}),"\n",(0,i.jsx)(e.h2,{id:"introduction-to-graphs",children:"Introduction to Graphs"}),"\n",(0,i.jsxs)(e.p,{children:["A ",(0,i.jsx)(e.strong,{children:"Graph"})," is a non-linear data structure consisting of vertices (nodes) and edges (connections) that link these vertices. Graphs are powerful tools for modeling relationships and connections in real-world scenarios like social networks, computer networks, maps, and dependency trees."]}),"\n",(0,i.jsx)(e.h3,{id:"key-terminology",children:"Key Terminology:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Vertex/Node"}),": Fundamental unit of the graph"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Edge"}),": Connection between two vertices"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Directed Graph (Digraph)"}),": Edges have direction"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Undirected Graph"}),": Edges have no direction"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Weighted Graph"}),": Edges have weights/costs"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Unweighted Graph"}),": All edges have equal weight"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Path"}),": Sequence of vertices connected by edges"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Cycle"}),": Path that starts and ends at the same vertex"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Degree"}),": Number of edges incident to a vertex"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Adjacent Vertices"}),": Vertices connected by an edge"]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"graph-types",children:"Graph Types:"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.strong,{children:"Directed vs Undirected"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.strong,{children:"Weighted vs Unweighted"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.strong,{children:"Cyclic vs Acyclic"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.strong,{children:"Connected vs Disconnected"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.strong,{children:"Simple vs Multigraph"})}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Complete Graph"}),": Every pair of vertices is connected"]}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"basic-graph-implementation",children:"Basic Graph Implementation"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <algorithm>\n#include <limits>\nusing namespace std;\n\n// ========== GRAPH REPRESENTATIONS ==========\n\n// 1. Edge List Representation\nclass GraphEdgeList {\nprivate:\n    struct Edge {\n        int src;\n        int dest;\n        int weight;\n        \n        Edge(int s, int d, int w = 1) : src(s), dest(d), weight(w) {}\n    };\n    \n    vector<Edge> edges;\n    int numVertices;\n    bool directed;\n    bool weighted;\n    \npublic:\n    GraphEdgeList(int V, bool dir = false, bool w = false) \n        : numVertices(V), directed(dir), weighted(w) {}\n    \n    void addEdge(int src, int dest, int weight = 1) {\n        edges.push_back(Edge(src, dest, weight));\n        if(!directed) {\n            edges.push_back(Edge(dest, src, weight));\n        }\n    }\n    \n    void display() {\n        cout << "Edge List Representation:" << endl;\n        cout << "V = " << numVertices << ", E = " << edges.size() << endl;\n        cout << "Format: (src -> dest [weight])" << endl;\n        \n        for(const auto& edge : edges) {\n            cout << "(" << edge.src << " -> " << edge.dest;\n            if(weighted) cout << " [" << edge.weight << "]";\n            cout << ")" << endl;\n        }\n    }\n};\n\n// 2. Adjacency Matrix Representation\nclass GraphAdjMatrix {\nprivate:\n    vector<vector<int>> adjMatrix;\n    int numVertices;\n    bool directed;\n    bool weighted;\n    \npublic:\n    GraphAdjMatrix(int V, bool dir = false, bool w = false) \n        : numVertices(V), directed(dir), weighted(w) {\n        adjMatrix.resize(V, vector<int>(V, 0));\n    }\n    \n    void addEdge(int src, int dest, int weight = 1) {\n        if(src >= 0 && src < numVertices && dest >= 0 && dest < numVertices) {\n            adjMatrix[src][dest] = weighted ? weight : 1;\n            if(!directed) {\n                adjMatrix[dest][src] = weighted ? weight : 1;\n            }\n        }\n    }\n    \n    void display() {\n        cout << "\\nAdjacency Matrix Representation:" << endl;\n        cout << "   ";\n        for(int i = 0; i < numVertices; i++) {\n            cout << i << " ";\n        }\n        cout << endl;\n        \n        for(int i = 0; i < numVertices; i++) {\n            cout << i << ": ";\n            for(int j = 0; j < numVertices; j++) {\n                cout << adjMatrix[i][j] << " ";\n            }\n            cout << endl;\n        }\n    }\n    \n    bool isEdge(int src, int dest) {\n        return adjMatrix[src][dest] != 0;\n    }\n    \n    int getWeight(int src, int dest) {\n        return adjMatrix[src][dest];\n    }\n};\n\n// 3. Adjacency List Representation (Most Common)\nclass GraphAdjList {\nprivate:\n    struct Edge {\n        int dest;\n        int weight;\n        \n        Edge(int d, int w = 1) : dest(d), weight(w) {}\n    };\n    \n    vector<list<Edge>> adjList;\n    int numVertices;\n    bool directed;\n    bool weighted;\n    \npublic:\n    GraphAdjList(int V, bool dir = false, bool w = false) \n        : numVertices(V), directed(dir), weighted(w) {\n        adjList.resize(V);\n    }\n    \n    void addEdge(int src, int dest, int weight = 1) {\n        if(src >= 0 && src < numVertices && dest >= 0 && dest < numVertices) {\n            adjList[src].push_back(Edge(dest, weight));\n            if(!directed) {\n                adjList[dest].push_back(Edge(src, weight));\n            }\n        }\n    }\n    \n    void display() {\n        cout << "\\nAdjacency List Representation:" << endl;\n        for(int i = 0; i < numVertices; i++) {\n            cout << i << " -> ";\n            for(const auto& edge : adjList[i]) {\n                cout << edge.dest;\n                if(weighted) cout << "(" << edge.weight << ")";\n                cout << " ";\n            }\n            cout << endl;\n        }\n    }\n    \n    const list<Edge>& getNeighbors(int vertex) {\n        return adjList[vertex];\n    }\n    \n    int getDegree(int vertex) {\n        if(vertex >= 0 && vertex < numVertices) {\n            return adjList[vertex].size();\n        }\n        return 0;\n    }\n};\n\n// ========== COMPLETE GRAPH CLASS ==========\n\nclass Graph {\nprivate:\n    int numVertices;\n    bool directed;\n    bool weighted;\n    vector<list<pair<int, int>>> adjList; // pair<dest, weight>\n    \npublic:\n    Graph(int V = 0, bool dir = false, bool w = false) \n        : numVertices(V), directed(dir), weighted(w) {\n        adjList.resize(V);\n    }\n    \n    // ========== BASIC OPERATIONS ==========\n    \n    void addVertex() {\n        numVertices++;\n        adjList.resize(numVertices);\n    }\n    \n    void addEdge(int src, int dest, int weight = 1) {\n        if(src < 0 || src >= numVertices || dest < 0 || dest >= numVertices) {\n            cout << "Invalid vertices!" << endl;\n            return;\n        }\n        \n        adjList[src].push_back({dest, weight});\n        if(!directed) {\n            adjList[dest].push_back({src, weight});\n        }\n    }\n    \n    void removeEdge(int src, int dest) {\n        if(src < 0 || src >= numVertices || dest < 0 || dest >= numVertices) {\n            return;\n        }\n        \n        // Remove edge from src to dest\n        adjList[src].remove_if([dest](const pair<int, int>& edge) {\n            return edge.first == dest;\n        });\n        \n        if(!directed) {\n            // Remove edge from dest to src\n            adjList[dest].remove_if([src](const pair<int, int>& edge) {\n                return edge.first == src;\n            });\n        }\n    }\n    \n    bool hasEdge(int src, int dest) {\n        if(src < 0 || src >= numVertices || dest < 0 || dest >= numVertices) {\n            return false;\n        }\n        \n        for(const auto& edge : adjList[src]) {\n            if(edge.first == dest) {\n                return true;\n            }\n        }\n        return false;\n    }\n    \n    int getWeight(int src, int dest) {\n        if(src < 0 || src >= numVertices || dest < 0 || dest >= numVertices) {\n            return -1;\n        }\n        \n        for(const auto& edge : adjList[src]) {\n            if(edge.first == dest) {\n                return edge.second;\n            }\n        }\n        return -1;\n    }\n    \n    // ========== GRAPH PROPERTIES ==========\n    \n    int getNumVertices() const {\n        return numVertices;\n    }\n    \n    int getNumEdges() {\n        int count = 0;\n        for(int i = 0; i < numVertices; i++) {\n            count += adjList[i].size();\n        }\n        \n        if(!directed) {\n            count /= 2;\n        }\n        return count;\n    }\n    \n    vector<int> getVertices() {\n        vector<int> vertices(numVertices);\n        for(int i = 0; i < numVertices; i++) {\n            vertices[i] = i;\n        }\n        return vertices;\n    }\n    \n    vector<pair<int, int>> getEdges() {\n        vector<pair<int, int>> edges;\n        unordered_set<string> visited;\n        \n        for(int src = 0; src < numVertices; src++) {\n            for(const auto& edge : adjList[src]) {\n                int dest = edge.first;\n                \n                // For undirected graphs, avoid duplicate edges\n                if(!directed) {\n                    string key1 = to_string(src) + "-" + to_string(dest);\n                    string key2 = to_string(dest) + "-" + to_string(src);\n                    \n                    if(visited.find(key1) == visited.end() && \n                       visited.find(key2) == visited.end()) {\n                        edges.push_back({src, dest});\n                        visited.insert(key1);\n                    }\n                } else {\n                    edges.push_back({src, dest});\n                }\n            }\n        }\n        \n        return edges;\n    }\n    \n    vector<int> getNeighbors(int vertex) {\n        vector<int> neighbors;\n        if(vertex < 0 || vertex >= numVertices) {\n            return neighbors;\n        }\n        \n        for(const auto& edge : adjList[vertex]) {\n            neighbors.push_back(edge.first);\n        }\n        \n        return neighbors;\n    }\n    \n    int getDegree(int vertex) {\n        if(vertex < 0 || vertex >= numVertices) {\n            return -1;\n        }\n        \n        int degree = adjList[vertex].size();\n        \n        // For undirected graphs, degree is simply number of edges\n        // For directed graphs, we might want in-degree and out-degree separately\n        return degree;\n    }\n    \n    pair<int, int> getInOutDegree(int vertex) {\n        if(vertex < 0 || vertex >= numVertices || !directed) {\n            return {-1, -1};\n        }\n        \n        int outDegree = adjList[vertex].size();\n        int inDegree = 0;\n        \n        for(int i = 0; i < numVertices; i++) {\n            for(const auto& edge : adjList[i]) {\n                if(edge.first == vertex) {\n                    inDegree++;\n                }\n            }\n        }\n        \n        return {inDegree, outDegree};\n    }\n    \n    // ========== DISPLAY FUNCTIONS ==========\n    \n    void display() {\n        cout << "\\n=== GRAPH INFORMATION ===" << endl;\n        cout << "Vertices: " << numVertices << endl;\n        cout << "Edges: " << getNumEdges() << endl;\n        cout << "Type: " << (directed ? "Directed" : "Undirected") << endl;\n        cout << "Weighted: " << (weighted ? "Yes" : "No") << endl;\n        \n        cout << "\\nAdjacency List:" << endl;\n        for(int i = 0; i < numVertices; i++) {\n            cout << i << " -> ";\n            for(const auto& edge : adjList[i]) {\n                cout << edge.first;\n                if(weighted) {\n                    cout << "(" << edge.second << ")";\n                }\n                cout << " ";\n            }\n            cout << endl;\n        }\n        \n        if(directed) {\n            cout << "\\nVertex Degrees (In, Out):" << endl;\n            for(int i = 0; i < numVertices; i++) {\n                auto degrees = getInOutDegree(i);\n                cout << "Vertex " << i << ": In=" << degrees.first \n                     << ", Out=" << degrees.second << endl;\n            }\n        } else {\n            cout << "\\nVertex Degrees:" << endl;\n            for(int i = 0; i < numVertices; i++) {\n                cout << "Vertex " << i << ": " << getDegree(i) << endl;\n            }\n        }\n    }\n    \n    // ========== GRAPH GENERATION ==========\n    \n    void buildSampleGraph() {\n        // Clear existing graph\n        numVertices = 7;\n        adjList.clear();\n        adjList.resize(numVertices);\n        directed = false;\n        weighted = false;\n        \n        // Build a sample undirected unweighted graph\n        addEdge(0, 1);\n        addEdge(0, 2);\n        addEdge(1, 3);\n        addEdge(1, 4);\n        addEdge(2, 5);\n        addEdge(2, 6);\n        addEdge(3, 4);\n        addEdge(5, 6);\n    }\n    \n    void buildSampleDirectedGraph() {\n        // Clear existing graph\n        numVertices = 6;\n        adjList.clear();\n        adjList.resize(numVertices);\n        directed = true;\n        weighted = false;\n        \n        // Build a sample directed unweighted graph\n        addEdge(0, 1);\n        addEdge(0, 2);\n        addEdge(1, 3);\n        addEdge(2, 4);\n        addEdge(3, 5);\n        addEdge(4, 5);\n        addEdge(5, 0); // Creates a cycle\n    }\n    \n    void buildSampleWeightedGraph() {\n        // Clear existing graph\n        numVertices = 5;\n        adjList.clear();\n        adjList.resize(numVertices);\n        directed = false;\n        weighted = true;\n        \n        // Build a sample weighted undirected graph\n        addEdge(0, 1, 10);\n        addEdge(0, 2, 5);\n        addEdge(1, 2, 15);\n        addEdge(1, 3, 12);\n        addEdge(2, 3, 8);\n        addEdge(2, 4, 7);\n        addEdge(3, 4, 6);\n    }\n    \n    void buildCompleteGraph(int n) {\n        numVertices = n;\n        adjList.clear();\n        adjList.resize(numVertices);\n        directed = false;\n        weighted = false;\n        \n        for(int i = 0; i < n; i++) {\n            for(int j = i + 1; j < n; j++) {\n                addEdge(i, j);\n            }\n        }\n    }\n    \n    void buildCycleGraph(int n) {\n        numVertices = n;\n        adjList.clear();\n        adjList.resize(numVertices);\n        directed = false;\n        weighted = false;\n        \n        for(int i = 0; i < n; i++) {\n            addEdge(i, (i + 1) % n);\n        }\n    }\n    \n    void buildStarGraph(int n) {\n        numVertices = n + 1;\n        adjList.clear();\n        adjList.resize(numVertices);\n        directed = false;\n        weighted = false;\n        \n        // Center vertex is 0\n        for(int i = 1; i <= n; i++) {\n            addEdge(0, i);\n        }\n    }\n    \n    // ========== UTILITY FUNCTIONS ==========\n    \n    bool isEmpty() const {\n        return numVertices == 0;\n    }\n    \n    void clear() {\n        numVertices = 0;\n        adjList.clear();\n    }\n};\n\n// Function to demonstrate different graph representations\nvoid demonstrateGraphRepresentations() {\n    cout << "=== GRAPH REPRESENTATIONS DEMONSTRATION ===\\n" << endl;\n    \n    // Create the same graph in different representations\n    int V = 5;\n    \n    cout << "1. Edge List:" << endl;\n    GraphEdgeList edgeList(V, false, false);\n    edgeList.addEdge(0, 1);\n    edgeList.addEdge(0, 2);\n    edgeList.addEdge(1, 3);\n    edgeList.addEdge(2, 4);\n    edgeList.addEdge(3, 4);\n    edgeList.display();\n    \n    cout << "\\n2. Adjacency Matrix:" << endl;\n    GraphAdjMatrix adjMatrix(V, false, false);\n    adjMatrix.addEdge(0, 1);\n    adjMatrix.addEdge(0, 2);\n    adjMatrix.addEdge(1, 3);\n    adjMatrix.addEdge(2, 4);\n    adjMatrix.addEdge(3, 4);\n    adjMatrix.display();\n    \n    cout << "\\n3. Adjacency List:" << endl;\n    GraphAdjList adjList(V, false, false);\n    adjList.addEdge(0, 1);\n    adjList.addEdge(0, 2);\n    adjList.addEdge(1, 3);\n    adjList.addEdge(2, 4);\n    adjList.addEdge(3, 4);\n    adjList.display();\n    \n    cout << "\\nComparison:" << endl;\n    cout << "Edge List:" << endl;\n    cout << "  - Space: O(E)" << endl;\n    cout << "  - Check if edge exists: O(E)" << endl;\n    cout << "  - Get all edges: O(1)" << endl;\n    \n    cout << "\\nAdjacency Matrix:" << endl;\n    cout << "  - Space: O(V\xb2)" << endl;\n    cout << "  - Check if edge exists: O(1)" << endl;\n    cout << "  - Get all neighbors: O(V)" << endl;\n    \n    cout << "\\nAdjacency List:" << endl;\n    cout << "  - Space: O(V + E)" << endl;\n    cout << "  - Check if edge exists: O(degree)" << endl;\n    cout << "  - Get all neighbors: O(degree)" << endl;\n}\n\nint main() {\n    // Part 1: Graph Representations\n    demonstrateGraphRepresentations();\n    \n    // Part 2: Complete Graph Class\n    cout << "\\n\\n=== COMPLETE GRAPH CLASS DEMONSTRATION ===\\n" << endl;\n    \n    Graph graph;\n    \n    cout << "1. Undirected Unweighted Graph:" << endl;\n    graph.buildSampleGraph();\n    graph.display();\n    \n    cout << "\\n2. Directed Unweighted Graph:" << endl;\n    graph.buildSampleDirectedGraph();\n    graph.display();\n    \n    cout << "\\n3. Weighted Undirected Graph:" << endl;\n    graph.buildSampleWeightedGraph();\n    graph.display();\n    \n    cout << "\\n4. Complete Graph (K5):" << endl;\n    graph.buildCompleteGraph(5);\n    graph.display();\n    \n    cout << "\\n5. Cycle Graph (C6):" << endl;\n    graph.buildCycleGraph(6);\n    graph.display();\n    \n    cout << "\\n6. Star Graph (S5):" << endl;\n    graph.buildStarGraph(5);\n    graph.display();\n    \n    return 0;\n}\n'})}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Output:"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"=== GRAPH REPRESENTATIONS DEMONSTRATION ===\n\n1. Edge List:\nEdge List Representation:\nV = 5, E = 10\nFormat: (src -> dest [weight])\n(0 -> 1)\n(1 -> 0)\n(0 -> 2)\n(2 -> 0)\n(1 -> 3)\n(3 -> 1)\n(2 -> 4)\n(4 -> 2)\n(3 -> 4)\n(4 -> 3)\n\n2. Adjacency Matrix:\nAdjacency Matrix Representation:\n   0 1 2 3 4 \n0: 0 1 1 0 0 \n1: 1 0 0 1 0 \n2: 1 0 0 0 1 \n3: 0 1 0 0 1 \n4: 0 0 1 1 0 \n\n3. Adjacency List:\nAdjacency List Representation:\n0 -> 1 2 \n1 -> 0 3 \n2 -> 0 4 \n3 -> 1 4 \n4 -> 2 3 \n\nComparison:\nEdge List:\n  - Space: O(E)\n  - Check if edge exists: O(E)\n  - Get all edges: O(1)\n\nAdjacency Matrix:\n  - Space: O(V\xb2)\n  - Check if edge exists: O(1)\n  - Get all neighbors: O(V)\n\nAdjacency List:\n  - Space: O(V + E)\n  - Check if edge exists: O(degree)\n  - Get all neighbors: O(degree)\n\n\n=== COMPLETE GRAPH CLASS DEMONSTRATION ===\n\n1. Undirected Unweighted Graph:\n\n=== GRAPH INFORMATION ===\nVertices: 7\nEdges: 8\nType: Undirected\nWeighted: No\n\nAdjacency List:\n0 -> 1 2 \n1 -> 0 3 4 \n2 -> 0 5 6 \n3 -> 1 4 \n4 -> 1 3 \n5 -> 2 6 \n6 -> 2 5 \n\nVertex Degrees:\nVertex 0: 2\nVertex 1: 3\nVertex 2: 3\nVertex 3: 2\nVertex 4: 2\nVertex 5: 2\nVertex 6: 2\n\n2. Directed Unweighted Graph:\n\n=== GRAPH INFORMATION ===\nVertices: 6\nEdges: 7\nType: Directed\nWeighted: No\n\nAdjacency List:\n0 -> 1 2 \n1 -> 3 \n2 -> 4 \n3 -> 5 \n4 -> 5 \n5 -> 0 \n\nVertex Degrees (In, Out):\nVertex 0: In=1, Out=2\nVertex 1: In=1, Out=1\nVertex 2: In=1, Out=1\nVertex 3: In=1, Out=1\nVertex 4: In=1, Out=1\nVertex 5: In=2, Out=1\n\n3. Weighted Undirected Graph:\n\n=== GRAPH INFORMATION ===\nVertices: 5\nEdges: 7\nType: Undirected\nWeighted: Yes\n\nAdjacency List:\n0 -> 1(10) 2(5) \n1 -> 0(10) 2(15) 3(12) \n2 -> 0(5) 1(15) 3(8) 4(7) \n3 -> 1(12) 2(8) 4(6) \n4 -> 2(7) 3(6) \n\nVertex Degrees:\nVertex 0: 2\nVertex 1: 3\nVertex 2: 4\nVertex 3: 3\nVertex 4: 2\n\n4. Complete Graph (K5):\n\n=== GRAPH INFORMATION ===\nVertices: 5\nEdges: 10\nType: Undirected\nWeighted: No\n\nAdjacency List:\n0 -> 1 2 3 4 \n1 -> 0 2 3 4 \n2 -> 0 1 3 4 \n3 -> 0 1 2 4 \n4 -> 0 1 2 3 \n\nVertex Degrees:\nVertex 0: 4\nVertex 1: 4\nVertex 2: 4\nVertex 3: 4\nVertex 4: 4\n\n5. Cycle Graph (C6):\n\n=== GRAPH INFORMATION ===\nVertices: 6\nEdges: 6\nType: Undirected\nWeighted: No\n\nAdjacency List:\n0 -> 1 5 \n1 -> 0 2 \n2 -> 1 3 \n3 -> 2 4 \n4 -> 3 5 \n5 -> 4 0 \n\nVertex Degrees:\nVertex 0: 2\nVertex 1: 2\nVertex 2: 2\nVertex 3: 2\nVertex 4: 2\nVertex 5: 2\n\n6. Star Graph (S5):\n\n=== GRAPH INFORMATION ===\nVertices: 6\nEdges: 5\nType: Undirected\nWeighted: No\n\nAdjacency List:\n0 -> 1 2 3 4 5 \n1 -> 0 \n2 -> 0 \n3 -> 0 \n4 -> 0 \n5 -> 0 \n\nVertex Degrees:\nVertex 0: 5\nVertex 1: 1\nVertex 2: 1\nVertex 3: 1\nVertex 4: 1\nVertex 5: 1\n"})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h1,{id:"dsa-graphs-implementation---complete-c-guide",children:"DSA Graphs Implementation - Complete C++ Guide"}),"\n",(0,i.jsx)(e.h2,{id:"advanced-graph-implementations",children:"Advanced Graph Implementations"}),"\n",(0,i.jsx)(e.p,{children:"Now let's explore more sophisticated graph implementations including weighted graphs, directed graphs, and specialized graph types with comprehensive operations."}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <algorithm>\n#include <limits>\n#include <functional>\n#include <iomanip>\nusing namespace std;\n\n// ========== ADVANCED GRAPH IMPLEMENTATIONS ==========\n\n// 1. Weighted Graph with Edge Class\nclass WeightedGraph {\nprivate:\n    struct Edge {\n        int src;\n        int dest;\n        int weight;\n        \n        Edge(int s, int d, int w) : src(s), dest(d), weight(w) {}\n        \n        bool operator<(const Edge& other) const {\n            return weight < other.weight;\n        }\n        \n        bool operator>(const Edge& other) const {\n            return weight > other.weight;\n        }\n    };\n    \n    vector<list<Edge>> adjList;\n    int numVertices;\n    bool directed;\n    \npublic:\n    WeightedGraph(int V = 0, bool dir = false) \n        : numVertices(V), directed(dir) {\n        adjList.resize(V);\n    }\n    \n    void addEdge(int src, int dest, int weight) {\n        if(src < 0 || src >= numVertices || dest < 0 || dest >= numVertices) {\n            cout << "Invalid vertices!" << endl;\n            return;\n        }\n        \n        adjList[src].push_back(Edge(src, dest, weight));\n        if(!directed) {\n            adjList[dest].push_back(Edge(dest, src, weight));\n        }\n    }\n    \n    void display() {\n        cout << "\\nWeighted Graph (" \n             << (directed ? "Directed" : "Undirected") << "):" << endl;\n        \n        for(int i = 0; i < numVertices; i++) {\n            cout << i << " -> ";\n            for(const auto& edge : adjList[i]) {\n                cout << edge.dest << "(" << edge.weight << ") ";\n            }\n            cout << endl;\n        }\n    }\n    \n    vector<Edge> getAllEdges() {\n        vector<Edge> edges;\n        set<pair<int, int>> visited;\n        \n        for(int src = 0; src < numVertices; src++) {\n            for(const auto& edge : adjList[src]) {\n                int dest = edge.dest;\n                \n                if(!directed) {\n                    // Avoid duplicates for undirected graphs\n                    pair<int, int> key = {min(src, dest), max(src, dest)};\n                    if(visited.find(key) == visited.end()) {\n                        edges.push_back(edge);\n                        visited.insert(key);\n                    }\n                } else {\n                    edges.push_back(edge);\n                }\n            }\n        }\n        \n        return edges;\n    }\n    \n    // Get minimum spanning tree edges (for demonstration)\n    vector<Edge> getMinimumSpanningTreeEdges() {\n        if(directed) {\n            cout << "MST is for undirected graphs only!" << endl;\n            return {};\n        }\n        \n        vector<Edge> allEdges = getAllEdges();\n        sort(allEdges.begin(), allEdges.end());\n        \n        vector<int> parent(numVertices);\n        for(int i = 0; i < numVertices; i++) {\n            parent[i] = i;\n        }\n        \n        function<int(int)> find = [&](int x) {\n            if(parent[x] != x) {\n                parent[x] = find(parent[x]);\n            }\n            return parent[x];\n        };\n        \n        function<void(int, int)> unionSets = [&](int x, int y) {\n            int rootX = find(x);\n            int rootY = find(y);\n            if(rootX != rootY) {\n                parent[rootY] = rootX;\n            }\n        };\n        \n        vector<Edge> mstEdges;\n        int edgesAdded = 0;\n        \n        for(const auto& edge : allEdges) {\n            if(find(edge.src) != find(edge.dest)) {\n                mstEdges.push_back(edge);\n                unionSets(edge.src, edge.dest);\n                edgesAdded++;\n                \n                if(edgesAdded == numVertices - 1) {\n                    break;\n                }\n            }\n        }\n        \n        return mstEdges;\n    }\n};\n\n// 2. Directed Graph with Strongly Connected Components\nclass DirectedGraph {\nprivate:\n    vector<list<int>> adjList;\n    vector<list<int>> revAdjList; // For Kosaraju\'s algorithm\n    int numVertices;\n    \n    void DFS(int v, vector<bool>& visited, vector<int>& order) {\n        visited[v] = true;\n        \n        for(int neighbor : adjList[v]) {\n            if(!visited[neighbor]) {\n                DFS(neighbor, visited, order);\n            }\n        }\n        \n        order.push_back(v);\n    }\n    \n    void DFSReverse(int v, vector<bool>& visited, vector<int>& component) {\n        visited[v] = true;\n        component.push_back(v);\n        \n        for(int neighbor : revAdjList[v]) {\n            if(!visited[neighbor]) {\n                DFSReverse(neighbor, visited, component);\n            }\n        }\n    }\n    \npublic:\n    DirectedGraph(int V = 0) : numVertices(V) {\n        adjList.resize(V);\n        revAdjList.resize(V);\n    }\n    \n    void addEdge(int src, int dest) {\n        if(src < 0 || src >= numVertices || dest < 0 || dest >= numVertices) {\n            return;\n        }\n        \n        adjList[src].push_back(dest);\n        revAdjList[dest].push_back(src);\n    }\n    \n    vector<vector<int>> findSCCs() {\n        vector<bool> visited(numVertices, false);\n        vector<int> order;\n        \n        // First DFS to get finishing order\n        for(int i = 0; i < numVertices; i++) {\n            if(!visited[i]) {\n                DFS(i, visited, order);\n            }\n        }\n        \n        // Reset visited array\n        fill(visited.begin(), visited.end(), false);\n        vector<vector<int>> sccs;\n        \n        // Second DFS on reversed graph in reverse order\n        for(int i = order.size() - 1; i >= 0; i--) {\n            int v = order[i];\n            if(!visited[v]) {\n                vector<int> component;\n                DFSReverse(v, visited, component);\n                sccs.push_back(component);\n            }\n        }\n        \n        return sccs;\n    }\n    \n    void displaySCCs() {\n        vector<vector<int>> sccs = findSCCs();\n        \n        cout << "\\nStrongly Connected Components:" << endl;\n        for(int i = 0; i < sccs.size(); i++) {\n            cout << "Component " << i + 1 << ": ";\n            for(int vertex : sccs[i]) {\n                cout << vertex << " ";\n            }\n            cout << endl;\n        }\n    }\n};\n\n// 3. Graph with Vertex Properties (Generic)\ntemplate<typename VertexData, typename EdgeData>\nclass PropertyGraph {\nprivate:\n    struct Vertex {\n        int id;\n        VertexData data;\n        list<pair<int, EdgeData>> edges; // pair<dest, edgeData>\n        \n        Vertex(int i, VertexData d) : id(i), data(d) {}\n    };\n    \n    vector<Vertex> vertices;\n    unordered_map<int, int> idToIndex; // Map external ID to internal index\n    int nextInternalId;\n    \npublic:\n    PropertyGraph() : nextInternalId(0) {}\n    \n    int addVertex(int externalId, VertexData data) {\n        if(idToIndex.find(externalId) != idToIndex.end()) {\n            return idToIndex[externalId];\n        }\n        \n        vertices.emplace_back(nextInternalId, data);\n        idToIndex[externalId] = nextInternalId;\n        return nextInternalId++;\n    }\n    \n    void addEdge(int srcExternalId, int destExternalId, EdgeData edgeData) {\n        if(idToIndex.find(srcExternalId) == idToIndex.end() ||\n           idToIndex.find(destExternalId) == idToIndex.end()) {\n            cout << "Vertex not found!" << endl;\n            return;\n        }\n        \n        int srcIndex = idToIndex[srcExternalId];\n        int destIndex = idToIndex[destExternalId];\n        \n        vertices[srcIndex].edges.emplace_back(destIndex, edgeData);\n    }\n    \n    void display() {\n        cout << "\\nProperty Graph:" << endl;\n        for(const auto& vertex : vertices) {\n            cout << "Vertex " << vertex.id << " (Data: " << vertex.data << ") -> ";\n            for(const auto& edge : vertex.edges) {\n                cout << edge.first << "(" << edge.second << ") ";\n            }\n            cout << endl;\n        }\n    }\n};\n\n// 4. MultiGraph (Multiple edges between same vertices)\nclass MultiGraph {\nprivate:\n    vector<list<pair<int, int>>> adjList; // pair<dest, edgeId>\n    vector<pair<int, int>> edgeVertices;  // edgeId -> (src, dest)\n    unordered_map<int, list<int>> edgeProperties; // edgeId -> properties list\n    \n    int nextEdgeId;\n    int numVertices;\n    \npublic:\n    MultiGraph(int V) : numVertices(V), nextEdgeId(0) {\n        adjList.resize(V);\n    }\n    \n    int addEdge(int src, int dest) {\n        if(src < 0 || src >= numVertices || dest < 0 || dest >= numVertices) {\n            return -1;\n        }\n        \n        int edgeId = nextEdgeId++;\n        adjList[src].emplace_back(dest, edgeId);\n        edgeVertices.emplace_back(src, dest);\n        \n        return edgeId;\n    }\n    \n    void addEdgeProperty(int edgeId, int property) {\n        edgeProperties[edgeId].push_back(property);\n    }\n    \n    void display() {\n        cout << "\\nMultiGraph:" << endl;\n        for(int i = 0; i < numVertices; i++) {\n            cout << i << " -> ";\n            for(const auto& edge : adjList[i]) {\n                cout << edge.first << "[e" << edge.second << "] ";\n            }\n            cout << endl;\n        }\n        \n        cout << "\\nEdge Details:" << endl;\n        for(int i = 0; i < edgeVertices.size(); i++) {\n            cout << "Edge e" << i << ": " << edgeVertices[i].first \n                 << " -> " << edgeVertices[i].second;\n            \n            if(edgeProperties.find(i) != edgeProperties.end()) {\n                cout << " [Properties: ";\n                for(int prop : edgeProperties[i]) {\n                    cout << prop << " ";\n                }\n                cout << "]";\n            }\n            cout << endl;\n        }\n    }\n};\n\n// 5. Bipartite Graph Checker\nclass BipartiteGraph {\nprivate:\n    vector<list<int>> adjList;\n    int numVertices;\n    \npublic:\n    BipartiteGraph(int V) : numVertices(V) {\n        adjList.resize(V);\n    }\n    \n    void addEdge(int u, int v) {\n        adjList[u].push_back(v);\n        adjList[v].push_back(u);\n    }\n    \n    bool isBipartite() {\n        vector<int> color(numVertices, -1);\n        \n        for(int i = 0; i < numVertices; i++) {\n            if(color[i] == -1) {\n                if(!isBipartiteBFS(i, color)) {\n                    return false;\n                }\n            }\n        }\n        \n        return true;\n    }\n    \n    bool isBipartiteBFS(int start, vector<int>& color) {\n        queue<int> q;\n        q.push(start);\n        color[start] = 0; // Start with color 0\n        \n        while(!q.empty()) {\n            int u = q.front();\n            q.pop();\n            \n            for(int v : adjList[u]) {\n                if(color[v] == -1) {\n                    color[v] = 1 - color[u];\n                    q.push(v);\n                } else if(color[v] == color[u]) {\n                    return false;\n                }\n            }\n        }\n        \n        return true;\n    }\n    \n    pair<vector<int>, vector<int>> getPartitions() {\n        vector<int> leftPartition, rightPartition;\n        vector<int> color(numVertices, -1);\n        \n        for(int i = 0; i < numVertices; i++) {\n            if(color[i] == -1) {\n                queue<int> q;\n                q.push(i);\n                color[i] = 0;\n                \n                while(!q.empty()) {\n                    int u = q.front();\n                    q.pop();\n                    \n                    if(color[u] == 0) {\n                        leftPartition.push_back(u);\n                    } else {\n                        rightPartition.push_back(u);\n                    }\n                    \n                    for(int v : adjList[u]) {\n                        if(color[v] == -1) {\n                            color[v] = 1 - color[u];\n                            q.push(v);\n                        }\n                    }\n                }\n            }\n        }\n        \n        return {leftPartition, rightPartition};\n    }\n    \n    void displayPartitions() {\n        if(!isBipartite()) {\n            cout << "Graph is not bipartite!" << endl;\n            return;\n        }\n        \n        auto partitions = getPartitions();\n        \n        cout << "\\nBipartite Graph Partitions:" << endl;\n        cout << "Left Partition: ";\n        for(int v : partitions.first) {\n            cout << v << " ";\n        }\n        cout << endl;\n        \n        cout << "Right Partition: ";\n        for(int v : partitions.second) {\n            cout << v << " ";\n        }\n        cout << endl;\n    }\n};\n\n// 6. Graph with Degree Centrality\nclass CentralityGraph {\nprivate:\n    vector<list<int>> adjList;\n    int numVertices;\n    \npublic:\n    CentralityGraph(int V) : numVertices(V) {\n        adjList.resize(V);\n    }\n    \n    void addEdge(int u, int v) {\n        adjList[u].push_back(v);\n        adjList[v].push_back(u);\n    }\n    \n    vector<int> getDegreeCentrality() {\n        vector<int> centrality(numVertices, 0);\n        \n        for(int i = 0; i < numVertices; i++) {\n            centrality[i] = adjList[i].size();\n        }\n        \n        return centrality;\n    }\n    \n    vector<double> getClosenessCentrality() {\n        vector<double> centrality(numVertices, 0.0);\n        \n        for(int i = 0; i < numVertices; i++) {\n            vector<int> distance(numVertices, -1);\n            queue<int> q;\n            \n            q.push(i);\n            distance[i] = 0;\n            \n            while(!q.empty()) {\n                int u = q.front();\n                q.pop();\n                \n                for(int v : adjList[u]) {\n                    if(distance[v] == -1) {\n                        distance[v] = distance[u] + 1;\n                        q.push(v);\n                    }\n                }\n            }\n            \n            double sumDistances = 0;\n            int reachableCount = 0;\n            \n            for(int j = 0; j < numVertices; j++) {\n                if(i != j && distance[j] != -1) {\n                    sumDistances += distance[j];\n                    reachableCount++;\n                }\n            }\n            \n            if(reachableCount > 0) {\n                centrality[i] = reachableCount / sumDistances;\n            }\n        }\n        \n        return centrality;\n    }\n    \n    void displayCentralities() {\n        vector<int> degreeCent = getDegreeCentrality();\n        vector<double> closenessCent = getClosenessCentrality();\n        \n        cout << "\\nVertex Centralities:" << endl;\n        cout << setw(10) << "Vertex" \n             << setw(15) << "Degree" \n             << setw(20) << "Closeness" << endl;\n        cout << string(45, \'-\') << endl;\n        \n        for(int i = 0; i < numVertices; i++) {\n            cout << setw(10) << i \n                 << setw(15) << degreeCent[i]\n                 << setw(20) << fixed << setprecision(4) << closenessCent[i] \n                 << endl;\n        }\n    }\n};\n\n// ========== GRAPH ALGORITHMS DEMONSTRATION ==========\n\nvoid demonstrateGraphAlgorithms() {\n    cout << "=== GRAPH ALGORITHMS DEMONSTRATION ===\\n" << endl;\n    \n    // 1. Weighted Graph with MST\n    cout << "1. WEIGHTED GRAPH & MINIMUM SPANNING TREE" << endl;\n    cout << "=========================================\\n" << endl;\n    \n    WeightedGraph wg(6, false);\n    wg.addEdge(0, 1, 4);\n    wg.addEdge(0, 2, 4);\n    wg.addEdge(1, 2, 2);\n    wg.addEdge(2, 3, 3);\n    wg.addEdge(2, 5, 2);\n    wg.addEdge(2, 4, 4);\n    wg.addEdge(3, 4, 3);\n    wg.addEdge(5, 4, 3);\n    \n    wg.display();\n    \n    vector<WeightedGraph::Edge> mstEdges = wg.getMinimumSpanningTreeEdges();\n    cout << "\\nMinimum Spanning Tree Edges:" << endl;\n    int totalWeight = 0;\n    for(const auto& edge : mstEdges) {\n        cout << edge.src << " - " << edge.dest << " (weight: " << edge.weight << ")" << endl;\n        totalWeight += edge.weight;\n    }\n    cout << "Total MST weight: " << totalWeight << endl;\n    \n    // 2. Directed Graph with SCC\n    cout << "\\n\\n2. DIRECTED GRAPH & STRONGLY CONNECTED COMPONENTS" << endl;\n    cout << "==================================================\\n" << endl;\n    \n    DirectedGraph dg(8);\n    dg.addEdge(0, 1);\n    dg.addEdge(1, 2);\n    dg.addEdge(2, 0);\n    dg.addEdge(2, 3);\n    dg.addEdge(3, 4);\n    dg.addEdge(4, 5);\n    dg.addEdge(5, 3);\n    dg.addEdge(6, 5);\n    dg.addEdge(6, 7);\n    dg.addEdge(7, 6);\n    \n    dg.displaySCCs();\n    \n    // 3. Property Graph\n    cout << "\\n\\n3. PROPERTY GRAPH" << endl;\n    cout << "===================\\n" << endl;\n    \n    PropertyGraph<string, string> pg;\n    \n    // Add vertices (cities)\n    int nyc = pg.addVertex(1, "New York");\n    int london = pg.addVertex(2, "London");\n    int paris = pg.addVertex(3, "Paris");\n    int tokyo = pg.addVertex(4, "Tokyo");\n    \n    // Add edges (flights)\n    pg.addEdge(1, 2, "Flight BA112, Duration: 7h");\n    pg.addEdge(1, 3, "Flight AF22, Duration: 8h");\n    pg.addEdge(2, 3, "Flight AF1231, Duration: 1h");\n    pg.addEdge(2, 4, "Flight JL402, Duration: 12h");\n    pg.addEdge(3, 4, "Flight JL403, Duration: 11h");\n    \n    pg.display();\n    \n    // 4. MultiGraph\n    cout << "\\n\\n4. MULTIGRAPH" << endl;\n    cout << "==============\\n" << endl;\n    \n    MultiGraph mg(4);\n    \n    // Add multiple edges between same vertices\n    int e1 = mg.addEdge(0, 1);\n    mg.addEdgeProperty(e1, 100);\n    \n    int e2 = mg.addEdge(0, 1);\n    mg.addEdgeProperty(e2, 200);\n    \n    mg.addEdge(1, 2);\n    mg.addEdge(2, 3);\n    mg.addEdge(1, 3);\n    \n    mg.display();\n    \n    // 5. Bipartite Graph\n    cout << "\\n\\n5. BIPARTITE GRAPH" << endl;\n    cout << "===================\\n" << endl;\n    \n    BipartiteGraph bg(6);\n    \n    // Create a bipartite graph\n    bg.addEdge(0, 3);\n    bg.addEdge(0, 4);\n    bg.addEdge(1, 3);\n    bg.addEdge(1, 4);\n    bg.addEdge(1, 5);\n    bg.addEdge(2, 4);\n    \n    cout << "Is bipartite: " << (bg.isBipartite() ? "Yes" : "No") << endl;\n    bg.displayPartitions();\n    \n    // 6. Centrality Graph\n    cout << "\\n\\n6. CENTRALITY ANALYSIS" << endl;\n    cout << "======================\\n" << endl;\n    \n    CentralityGraph cg(7);\n    \n    // Create a graph with a central node\n    cg.addEdge(0, 1);\n    cg.addEdge(0, 2);\n    cg.addEdge(0, 3);\n    cg.addEdge(0, 4);\n    cg.addEdge(0, 5);\n    cg.addEdge(0, 6);\n    cg.addEdge(1, 2);\n    cg.addEdge(3, 4);\n    cg.addEdge(5, 6);\n    \n    cg.displayCentralities();\n}\n\n// ========== REAL-WORLD APPLICATIONS ==========\n\n// Social Network Graph\nclass SocialNetwork {\nprivate:\n    struct Person {\n        int id;\n        string name;\n        int age;\n        string occupation;\n        \n        Person(int i, string n, int a, string o) \n            : id(i), name(n), age(a), occupation(o) {}\n    };\n    \n    vector<Person> people;\n    vector<list<int>> friendships;\n    unordered_map<int, int> idToIndex;\n    int nextId;\n    \npublic:\n    SocialNetwork() : nextId(0) {}\n    \n    int addPerson(string name, int age, string occupation) {\n        int personId = nextId++;\n        people.emplace_back(personId, name, age, occupation);\n        friendships.resize(nextId);\n        idToIndex[personId] = personId;\n        return personId;\n    }\n    \n    void addFriendship(int person1Id, int person2Id) {\n        if(person1Id < 0 || person1Id >= nextId || \n           person2Id < 0 || person2Id >= nextId) {\n            cout << "Invalid person ID!" << endl;\n            return;\n        }\n        \n        friendships[person1Id].push_back(person2Id);\n        friendships[person2Id].push_back(person1Id);\n    }\n    \n    void displayNetwork() {\n        cout << "\\n=== SOCIAL NETWORK ===" << endl;\n        cout << "Total People: " << people.size() << endl << endl;\n        \n        for(const auto& person : people) {\n            cout << person.name << " (ID: " << person.id \n                 << ", Age: " << person.age \n                 << ", " << person.occupation << ")" << endl;\n            cout << "Friends: ";\n            \n            for(int friendId : friendships[person.id]) {\n                cout << people[friendId].name << " ";\n            }\n            cout << endl << endl;\n        }\n    }\n    \n    vector<int> findMutualFriends(int person1Id, int person2Id) {\n        if(person1Id < 0 || person1Id >= nextId || \n           person2Id < 0 || person2Id >= nextId) {\n            return {};\n        }\n        \n        unordered_set<int> friends1(friendships[person1Id].begin(), \n                                   friendships[person1Id].end());\n        vector<int> mutualFriends;\n        \n        for(int friendId : friendships[person2Id]) {\n            if(friends1.find(friendId) != friends1.end()) {\n                mutualFriends.push_back(friendId);\n            }\n        }\n        \n        return mutualFriends;\n    }\n    \n    int findDegreeOfSeparation(int startId, int targetId) {\n        if(startId < 0 || startId >= nextId || \n           targetId < 0 || targetId >= nextId) {\n            return -1;\n        }\n        \n        if(startId == targetId) return 0;\n        \n        vector<bool> visited(nextId, false);\n        queue<pair<int, int>> q; // pair<personId, distance>\n        \n        q.push({startId, 0});\n        visited[startId] = true;\n        \n        while(!q.empty()) {\n            auto [currentId, distance] = q.front();\n            q.pop();\n            \n            if(currentId == targetId) {\n                return distance;\n            }\n            \n            for(int friendId : friendships[currentId]) {\n                if(!visited[friendId]) {\n                    visited[friendId] = true;\n                    q.push({friendId, distance + 1});\n                }\n            }\n        }\n        \n        return -1; // Not connected\n    }\n};\n\n// Transportation Network\nclass TransportationNetwork {\nprivate:\n    struct Station {\n        int id;\n        string name;\n        string line;\n        \n        Station(int i, string n, string l) : id(i), name(n), line(l) {}\n    };\n    \n    vector<Station> stations;\n    vector<list<pair<int, int>>> connections; // pair<stationId, travelTime>\n    unordered_map<string, int> nameToId;\n    int nextId;\n    \npublic:\n    TransportationNetwork() : nextId(0) {}\n    \n    int addStation(string name, string line) {\n        if(nameToId.find(name) != nameToId.end()) {\n            return nameToId[name];\n        }\n        \n        int stationId = nextId++;\n        stations.emplace_back(stationId, name, line);\n        connections.resize(nextId);\n        nameToId[name] = stationId;\n        return stationId;\n    }\n    \n    void addConnection(string station1, string station2, int travelTime) {\n        if(nameToId.find(station1) == nameToId.end() ||\n           nameToId.find(station2) == nameToId.end()) {\n            cout << "Station not found!" << endl;\n            return;\n        }\n        \n        int id1 = nameToId[station1];\n        int id2 = nameToId[station2];\n        \n        connections[id1].push_back({id2, travelTime});\n        connections[id2].push_back({id1, travelTime});\n    }\n    \n    vector<pair<vector<int>, int>> findRoutes(string start, string end) {\n        if(nameToId.find(start) == nameToId.end() ||\n           nameToId.find(end) == nameToId.end()) {\n            return {};\n        }\n        \n        int startId = nameToId[start];\n        int endId = nameToId[end];\n        \n        // Simple BFS to find all routes (for demonstration)\n        // In reality, you\'d use Dijkstra\'s or A* algorithm\n        \n        vector<pair<vector<int>, int>> allRoutes;\n        queue<pair<vector<int>, int>> q; // pair<path, totalTime>\n        \n        q.push({{startId}, 0});\n        \n        while(!q.empty()) {\n            auto [path, totalTime] = q.front();\n            q.pop();\n            \n            int currentId = path.back();\n            \n            if(currentId == endId) {\n                allRoutes.push_back({path, totalTime});\n                continue;\n            }\n            \n            for(const auto& [nextId, time] : connections[currentId]) {\n                // Avoid cycles\n                if(find(path.begin(), path.end(), nextId) == path.end()) {\n                    vector<int> newPath = path;\n                    newPath.push_back(nextId);\n                    q.push({newPath, totalTime + time});\n                }\n            }\n        }\n        \n        // Sort by travel time\n        sort(allRoutes.begin(), allRoutes.end(), \n             [](const auto& a, const auto& b) {\n                 return a.second < b.second;\n             });\n        \n        return allRoutes;\n    }\n    \n    void displayNetwork() {\n        cout << "\\n=== TRANSPORTATION NETWORK ===" << endl;\n        cout << "Total Stations: " << stations.size() << endl << endl;\n        \n        for(const auto& station : stations) {\n            cout << station.name << " (Line: " << station.line << ")" << endl;\n            cout << "Connections: ";\n            \n            for(const auto& [connectedId, time] : connections[station.id]) {\n                cout << stations[connectedId].name << " (" << time << "min) ";\n            }\n            cout << endl << endl;\n        }\n    }\n};\n\nint main() {\n    cout << "=== ADVANCED GRAPH IMPLEMENTATIONS ===\\n" << endl;\n    \n    // Part 1: Graph Algorithms\n    demonstrateGraphAlgorithms();\n    \n    // Part 2: Real-World Applications\n    cout << "\\n\\n=== REAL-WORLD GRAPH APPLICATIONS ===\\n" << endl;\n    \n    // Social Network\n    cout << "1. SOCIAL NETWORK APPLICATION" << endl;\n    cout << "===============================\\n" << endl;\n    \n    SocialNetwork sn;\n    \n    // Add people\n    int alice = sn.addPerson("Alice", 25, "Engineer");\n    int bob = sn.addPerson("Bob", 30, "Doctor");\n    int charlie = sn.addPerson("Charlie", 28, "Teacher");\n    int diana = sn.addPerson("Diana", 32, "Lawyer");\n    int eve = sn.addPerson("Eve", 27, "Artist");\n    int frank = sn.addPerson("Frank", 35, "Manager");\n    \n    // Add friendships\n    sn.addFriendship(alice, bob);\n    sn.addFriendship(alice, charlie);\n    sn.addFriendship(bob, diana);\n    sn.addFriendship(charlie, diana);\n    sn.addFriendship(diana, eve);\n    sn.addFriendship(eve, frank);\n    sn.addFriendship(bob, frank);\n    \n    sn.displayNetwork();\n    \n    // Find mutual friends\n    cout << "Mutual friends between Alice and Bob: ";\n    vector<int> mutual = sn.findMutualFriends(alice, bob);\n    for(int friendId : mutual) {\n        cout << friendId << " ";\n    }\n    cout << endl;\n    \n    // Find degree of separation\n    int separation = sn.findDegreeOfSeparation(alice, frank);\n    cout << "Degree of separation between Alice and Frank: " \n         << (separation != -1 ? to_string(separation) : "No connection") \n         << endl;\n    \n    // Transportation Network\n    cout << "\\n\\n2. TRANSPORTATION NETWORK APPLICATION" << endl;\n    cout << "=======================================\\n" << endl;\n    \n    TransportationNetwork tn;\n    \n    // Add stations\n    tn.addStation("Central", "Red");\n    tn.addStation("Downtown", "Red");\n    tn.addStation("Uptown", "Blue");\n    tn.addStation("Westside", "Blue");\n    tn.addStation("Eastside", "Green");\n    tn.addStation("Airport", "Green");\n    \n    // Add connections with travel times\n    tn.addConnection("Central", "Downtown", 5);\n    tn.addConnection("Central", "Uptown", 8);\n    tn.addConnection("Downtown", "Westside", 10);\n    tn.addConnection("Uptown", "Westside", 6);\n    tn.addConnection("Uptown", "Eastside", 7);\n    tn.addConnection("Westside", "Airport", 12);\n    tn.addConnection("Eastside", "Airport", 8);\n    \n    tn.displayNetwork();\n    \n    // Find routes\n    cout << "Routes from Central to Airport:" << endl;\n    auto routes = tn.findRoutes("Central", "Airport");\n    \n    for(int i = 0; i < min(3, (int)routes.size()); i++) {\n        cout << "Route " << i + 1 << " (Time: " << routes[i].second << "min): ";\n        for(int stationId : routes[i].first) {\n            // Convert back to names for display\n            // In real implementation, we\'d have a reverse map\n            cout << stationId << " ";\n        }\n        cout << endl;\n    }\n    \n    return 0;\n}\n'})}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Output:"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"=== GRAPH ALGORITHMS DEMONSTRATION ===\n\n1. WEIGHTED GRAPH & MINIMUM SPANNING TREE\n=========================================\n\nWeighted Graph (Undirected):\n0 -> 1(4) 2(4) \n1 -> 0(4) 2(2) \n2 -> 0(4) 1(2) 3(3) 5(2) 4(4) \n3 -> 2(3) 4(3) \n4 -> 2(4) 3(3) 5(3) \n5 -> 2(2) 4(3) \n\nMinimum Spanning Tree Edges:\n1 - 2 (weight: 2)\n2 - 5 (weight: 2)\n2 - 3 (weight: 3)\n3 - 4 (weight: 3)\n0 - 1 (weight: 4)\nTotal MST weight: 14\n\n\n2. DIRECTED GRAPH & STRONGLY CONNECTED COMPONENTS\n==================================================\n\nStrongly Connected Components:\nComponent 1: 0 2 1 \nComponent 2: 3 5 4 \nComponent 3: 6 7 \n\n\n3. PROPERTY GRAPH\n===================\n\nProperty Graph:\nVertex 0 (Data: New York) -> 1(Flight BA112, Duration: 7h) 2(Flight AF22, Duration: 8h) \nVertex 1 (Data: London) -> 2(Flight AF1231, Duration: 1h) 3(Flight JL402, Duration: 12h) \nVertex 2 (Data: Paris) -> 3(Flight JL403, Duration: 11h) \nVertex 3 (Data: Tokyo) -> \n\n\n4. MULTIGRAPH\n==============\n\nMultiGraph:\n0 -> 1[e0] 1[e1] \n1 -> 0[e0] 0[e1] 2[e2] 3[e4] \n2 -> 1[e2] 3[e3] \n3 -> 2[e3] 1[e4] \n\nEdge Details:\nEdge e0: 0 -> 1 [Properties: 100 ]\nEdge e1: 0 -> 1 [Properties: 200 ]\nEdge e2: 1 -> 2 \nEdge e3: 2 -> 3 \nEdge e4: 1 -> 3 \n\n\n5. BIPARTITE GRAPH\n===================\n\nIs bipartite: Yes\n\nBipartite Graph Partitions:\nLeft Partition: 0 1 2 \nRight Partition: 3 4 5 \n\n\n6. CENTRALITY ANALYSIS\n======================\n\nVertex Centralities:\n    Vertex          Degree          Closeness\n---------------------------------------------\n         0              6              0.7500\n         1              3              0.5455\n         2              3              0.5455\n         3              3              0.5455\n         4              3              0.5455\n         5              3              0.5455\n         6              3              0.5455\n\n\n=== REAL-WORLD GRAPH APPLICATIONS ===\n\n1. SOCIAL NETWORK APPLICATION\n===============================\n\n=== SOCIAL NETWORK ===\nTotal People: 6\n\nAlice (ID: 0, Age: 25, Engineer)\nFriends: Bob Charlie \n\nBob (ID: 1, Age: 30, Doctor)\nFriends: Alice Diana Frank \n\nCharlie (ID: 2, Age: 28, Teacher)\nFriends: Alice Diana \n\nDiana (ID: 3, Age: 32, Lawyer)\nFriends: Bob Charlie Eve \n\nEve (ID: 4, Age: 27, Artist)\nFriends: Diana Frank \n\nFrank (ID: 5, Age: 35, Manager)\nFriends: Eve Bob \n\nMutual friends between Alice and Bob: 2 \nDegree of separation between Alice and Frank: 2\n\n\n2. TRANSPORTATION NETWORK APPLICATION\n=======================================\n\n=== TRANSPORTATION NETWORK ===\nTotal Stations: 6\n\nCentral (Line: Red)\nConnections: Downtown (5min) Uptown (8min) \n\nDowntown (Line: Red)\nConnections: Central (5min) Westside (10min) \n\nUptown (Line: Blue)\nConnections: Central (8min) Westside (6min) Eastside (7min) \n\nWestside (Line: Blue)\nConnections: Downtown (10min) Uptown (6min) Airport (12min) \n\nEastside (Line: Green)\nConnections: Uptown (7min) Airport (8min) \n\nAirport (Line: Green)\nConnections: Westside (12min) Eastside (8min) \n\nRoutes from Central to Airport:\nRoute 1 (Time: 20min): 0 2 4 5 \nRoute 2 (Time: 21min): 0 1 3 5 \nRoute 3 (Time: 23min): 0 2 3 5 \n"})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h1,{id:"dsa-graphs-traversal---complete-c-guide",children:"DSA Graphs Traversal - Complete C++ Guide"}),"\n",(0,i.jsx)(e.h2,{id:"graph-traversal-algorithms",children:"Graph Traversal Algorithms"}),"\n",(0,i.jsx)(e.p,{children:"Graph traversal is the process of visiting all vertices in a graph. Unlike tree traversal, graph traversal must handle cycles and disconnected components. The two fundamental graph traversal algorithms are:"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Breadth-First Search (BFS)"}),": Level-by-level traversal"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Depth-First Search (DFS)"}),": Branch-by-branch traversal"]}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"complete-graph-traversal-implementation",children:"Complete Graph Traversal Implementation"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <algorithm>\n#include <functional>\n#include <iomanip>\nusing namespace std;\n\n// ========== GRAPH TRAVERSAL CLASS ==========\n\nclass GraphTraversal {\nprivate:\n    vector<list<int>> adjList;\n    int numVertices;\n    bool directed;\n    \npublic:\n    GraphTraversal(int V = 0, bool dir = false) \n        : numVertices(V), directed(dir) {\n        adjList.resize(V);\n    }\n    \n    void addEdge(int src, int dest) {\n        if(src < 0 || src >= numVertices || dest < 0 || dest >= numVertices) {\n            return;\n        }\n        \n        adjList[src].push_back(dest);\n        if(!directed) {\n            adjList[dest].push_back(src);\n        }\n    }\n    \n    void buildSampleGraph() {\n        numVertices = 7;\n        adjList.clear();\n        adjList.resize(numVertices);\n        directed = false;\n        \n        // Build a sample graph\n        addEdge(0, 1);\n        addEdge(0, 2);\n        addEdge(1, 3);\n        addEdge(1, 4);\n        addEdge(2, 5);\n        addEdge(2, 6);\n        addEdge(3, 4);\n        addEdge(5, 6);\n        \n        /* Graph Structure:\n               0\n              / \\\n             1   2\n            / \\ / \\\n           3   4   5\n                    \\\n                     6\n        */\n    }\n    \n    void buildDisconnectedGraph() {\n        numVertices = 10;\n        adjList.clear();\n        adjList.resize(numVertices);\n        directed = false;\n        \n        // Component 1: 0-1-2-3\n        addEdge(0, 1);\n        addEdge(1, 2);\n        addEdge(2, 3);\n        \n        // Component 2: 4-5-6\n        addEdge(4, 5);\n        addEdge(5, 6);\n        \n        // Component 3: 7-8-9 (line)\n        addEdge(7, 8);\n        addEdge(8, 9);\n    }\n    \n    // ========== BREADTH-FIRST SEARCH (BFS) ==========\n    \n    vector<int> BFS(int startVertex) {\n        vector<int> traversalOrder;\n        if(startVertex < 0 || startVertex >= numVertices) {\n            return traversalOrder;\n        }\n        \n        vector<bool> visited(numVertices, false);\n        queue<int> q;\n        \n        q.push(startVertex);\n        visited[startVertex] = true;\n        \n        cout << "BFS starting from vertex " << startVertex << ":" << endl;\n        cout << "Queue operations:" << endl;\n        \n        int step = 1;\n        while(!q.empty()) {\n            int current = q.front();\n            q.pop();\n            traversalOrder.push_back(current);\n            \n            cout << "Step " << step++ << ": Visit " << current \n                 << ", Queue: [";\n            \n            // Process neighbors\n            for(int neighbor : adjList[current]) {\n                if(!visited[neighbor]) {\n                    visited[neighbor] = true;\n                    q.push(neighbor);\n                }\n            }\n            \n            // Display queue contents\n            queue<int> temp = q;\n            while(!temp.empty()) {\n                cout << temp.front();\n                temp.pop();\n                if(!temp.empty()) cout << ", ";\n            }\n            cout << "]" << endl;\n        }\n        \n        return traversalOrder;\n    }\n    \n    vector<int> BFSFull() {\n        vector<int> traversalOrder;\n        vector<bool> visited(numVertices, false);\n        \n        for(int i = 0; i < numVertices; i++) {\n            if(!visited[i]) {\n                queue<int> q;\n                q.push(i);\n                visited[i] = true;\n                \n                while(!q.empty()) {\n                    int current = q.front();\n                    q.pop();\n                    traversalOrder.push_back(current);\n                    \n                    for(int neighbor : adjList[current]) {\n                        if(!visited[neighbor]) {\n                            visited[neighbor] = true;\n                            q.push(neighbor);\n                        }\n                    }\n                }\n            }\n        }\n        \n        return traversalOrder;\n    }\n    \n    // BFS with distance calculation\n    vector<int> BFSWithDistance(int startVertex) {\n        vector<int> distances(numVertices, -1);\n        if(startVertex < 0 || startVertex >= numVertices) {\n            return distances;\n        }\n        \n        queue<int> q;\n        q.push(startVertex);\n        distances[startVertex] = 0;\n        \n        cout << "\\nBFS with distances from vertex " << startVertex << ":" << endl;\n        cout << setw(10) << "Vertex" << setw(15) << "Distance" << endl;\n        cout << string(25, \'-\') << endl;\n        \n        while(!q.empty()) {\n            int current = q.front();\n            q.pop();\n            \n            cout << setw(10) << current << setw(15) << distances[current] << endl;\n            \n            for(int neighbor : adjList[current]) {\n                if(distances[neighbor] == -1) {\n                    distances[neighbor] = distances[current] + 1;\n                    q.push(neighbor);\n                }\n            }\n        }\n        \n        return distances;\n    }\n    \n    // BFS with path reconstruction\n    vector<vector<int>> BFSWithPaths(int startVertex) {\n        vector<vector<int>> allPaths(numVertices);\n        if(startVertex < 0 || startVertex >= numVertices) {\n            return allPaths;\n        }\n        \n        vector<int> parent(numVertices, -1);\n        vector<int> distance(numVertices, -1);\n        queue<int> q;\n        \n        q.push(startVertex);\n        distance[startVertex] = 0;\n        parent[startVertex] = startVertex;\n        \n        while(!q.empty()) {\n            int current = q.front();\n            q.pop();\n            \n            for(int neighbor : adjList[current]) {\n                if(distance[neighbor] == -1) {\n                    distance[neighbor] = distance[current] + 1;\n                    parent[neighbor] = current;\n                    q.push(neighbor);\n                }\n            }\n        }\n        \n        // Reconstruct paths\n        for(int i = 0; i < numVertices; i++) {\n            if(distance[i] != -1) {\n                vector<int> path;\n                int current = i;\n                \n                while(current != startVertex) {\n                    path.push_back(current);\n                    current = parent[current];\n                }\n                path.push_back(startVertex);\n                reverse(path.begin(), path.end());\n                allPaths[i] = path;\n            }\n        }\n        \n        return allPaths;\n    }\n    \n    // ========== DEPTH-FIRST SEARCH (DFS) ==========\n    \n    vector<int> DFS(int startVertex) {\n        vector<int> traversalOrder;\n        if(startVertex < 0 || startVertex >= numVertices) {\n            return traversalOrder;\n        }\n        \n        vector<bool> visited(numVertices, false);\n        stack<int> s;\n        \n        s.push(startVertex);\n        \n        cout << "DFS (Iterative) starting from vertex " << startVertex << ":" << endl;\n        cout << "Stack operations:" << endl;\n        \n        int step = 1;\n        while(!s.empty()) {\n            int current = s.top();\n            s.pop();\n            \n            if(!visited[current]) {\n                visited[current] = true;\n                traversalOrder.push_back(current);\n                \n                cout << "Step " << step++ << ": Visit " << current \n                     << ", Stack: [";\n                \n                // Push unvisited neighbors in reverse order for consistent output\n                vector<int> neighbors(adjList[current].begin(), adjList[current].end());\n                reverse(neighbors.begin(), neighbors.end());\n                \n                for(int neighbor : neighbors) {\n                    if(!visited[neighbor]) {\n                        s.push(neighbor);\n                    }\n                }\n                \n                // Display stack contents\n                stack<int> temp = s;\n                vector<int> stackContents;\n                while(!temp.empty()) {\n                    stackContents.push_back(temp.top());\n                    temp.pop();\n                }\n                reverse(stackContents.begin(), stackContents.end());\n                \n                for(size_t i = 0; i < stackContents.size(); i++) {\n                    cout << stackContents[i];\n                    if(i < stackContents.size() - 1) cout << ", ";\n                }\n                cout << "]" << endl;\n            }\n        }\n        \n        return traversalOrder;\n    }\n    \n    vector<int> DFSRecursive(int startVertex) {\n        vector<int> traversalOrder;\n        vector<bool> visited(numVertices, false);\n        \n        cout << "DFS (Recursive) starting from vertex " << startVertex << ":" << endl;\n        cout << "Recursion calls:" << endl;\n        \n        DFSRecursiveHelper(startVertex, visited, traversalOrder, 1);\n        \n        return traversalOrder;\n    }\n    \n    void DFSRecursiveHelper(int vertex, vector<bool>& visited, \n                           vector<int>& traversalOrder, int depth) {\n        visited[vertex] = true;\n        traversalOrder.push_back(vertex);\n        \n        cout << "Depth " << depth << ": Visit " << vertex << endl;\n        \n        for(int neighbor : adjList[vertex]) {\n            if(!visited[neighbor]) {\n                DFSRecursiveHelper(neighbor, visited, traversalOrder, depth + 1);\n            }\n        }\n    }\n    \n    vector<int> DFSFull() {\n        vector<int> traversalOrder;\n        vector<bool> visited(numVertices, false);\n        \n        for(int i = 0; i < numVertices; i++) {\n            if(!visited[i]) {\n                DFSFullHelper(i, visited, traversalOrder);\n            }\n        }\n        \n        return traversalOrder;\n    }\n    \n    void DFSFullHelper(int vertex, vector<bool>& visited, vector<int>& traversalOrder) {\n        stack<int> s;\n        s.push(vertex);\n        \n        while(!s.empty()) {\n            int current = s.top();\n            s.pop();\n            \n            if(!visited[current]) {\n                visited[current] = true;\n                traversalOrder.push_back(current);\n                \n                for(int neighbor : adjList[current]) {\n                    if(!visited[neighbor]) {\n                        s.push(neighbor);\n                    }\n                }\n            }\n        }\n    }\n    \n    // ========== DFS WITH TIMESTAMPS ==========\n    \n    struct DFSInfo {\n        int discoveryTime;\n        int finishTime;\n        int parent;\n        string color;\n        \n        DFSInfo() : discoveryTime(-1), finishTime(-1), parent(-1), color("WHITE") {}\n    };\n    \n    void DFSWithTimestamps() {\n        vector<DFSInfo> info(numVertices);\n        int time = 0;\n        \n        cout << "\\nDFS with Timestamps:" << endl;\n        cout << setw(10) << "Vertex" << setw(15) << "Discovery" \n             << setw(15) << "Finish" << setw(10) << "Parent" \n             << setw(10) << "Color" << endl;\n        cout << string(60, \'-\') << endl;\n        \n        for(int i = 0; i < numVertices; i++) {\n            if(info[i].color == "WHITE") {\n                DFSVisit(i, info, time);\n            }\n        }\n        \n        // Display results\n        for(int i = 0; i < numVertices; i++) {\n            cout << setw(10) << i \n                 << setw(15) << info[i].discoveryTime\n                 << setw(15) << info[i].finishTime\n                 << setw(10) << (info[i].parent == -1 ? "-" : to_string(info[i].parent))\n                 << setw(10) << info[i].color << endl;\n        }\n    }\n    \n    void DFSVisit(int u, vector<DFSInfo>& info, int& time) {\n        time++;\n        info[u].discoveryTime = time;\n        info[u].color = "GRAY";\n        \n        for(int v : adjList[u]) {\n            if(info[v].color == "WHITE") {\n                info[v].parent = u;\n                DFSVisit(v, info, time);\n            }\n        }\n        \n        info[u].color = "BLACK";\n        time++;\n        info[u].finishTime = time;\n    }\n    \n    // ========== TOPOLOGICAL SORT (for DAGs) ==========\n    \n    vector<int> topologicalSort() {\n        if(!directed) {\n            cout << "Topological sort requires a directed graph!" << endl;\n            return {};\n        }\n        \n        vector<int> inDegree(numVertices, 0);\n        vector<int> topoOrder;\n        \n        // Calculate in-degrees\n        for(int u = 0; u < numVertices; u++) {\n            for(int v : adjList[u]) {\n                inDegree[v]++;\n            }\n        }\n        \n        // Kahn\'s algorithm\n        queue<int> q;\n        for(int i = 0; i < numVertices; i++) {\n            if(inDegree[i] == 0) {\n                q.push(i);\n            }\n        }\n        \n        int count = 0;\n        while(!q.empty()) {\n            int u = q.front();\n            q.pop();\n            topoOrder.push_back(u);\n            \n            for(int v : adjList[u]) {\n                if(--inDegree[v] == 0) {\n                    q.push(v);\n                }\n            }\n            \n            count++;\n        }\n        \n        if(count != numVertices) {\n            cout << "Graph has a cycle! Topological sort not possible." << endl;\n            return {};\n        }\n        \n        return topoOrder;\n    }\n    \n    // ========== TRAVERSAL APPLICATIONS ==========\n    \n    // Check if graph is connected\n    bool isConnected() {\n        if(numVertices == 0) return true;\n        \n        vector<bool> visited(numVertices, false);\n        queue<int> q;\n        \n        q.push(0);\n        visited[0] = true;\n        \n        while(!q.empty()) {\n            int current = q.front();\n            q.pop();\n            \n            for(int neighbor : adjList[current]) {\n                if(!visited[neighbor]) {\n                    visited[neighbor] = true;\n                    q.push(neighbor);\n                }\n            }\n        }\n        \n        for(bool v : visited) {\n            if(!v) return false;\n        }\n        \n        return true;\n    }\n    \n    // Find connected components\n    vector<vector<int>> findConnectedComponents() {\n        vector<vector<int>> components;\n        vector<bool> visited(numVertices, false);\n        \n        for(int i = 0; i < numVertices; i++) {\n            if(!visited[i]) {\n                vector<int> component;\n                queue<int> q;\n                \n                q.push(i);\n                visited[i] = true;\n                \n                while(!q.empty()) {\n                    int current = q.front();\n                    q.pop();\n                    component.push_back(current);\n                    \n                    for(int neighbor : adjList[current]) {\n                        if(!visited[neighbor]) {\n                            visited[neighbor] = true;\n                            q.push(neighbor);\n                        }\n                    }\n                }\n                \n                components.push_back(component);\n            }\n        }\n        \n        return components;\n    }\n    \n    // Find shortest path (unweighted graph)\n    vector<int> shortestPath(int start, int end) {\n        vector<int> path;\n        if(start < 0 || start >= numVertices || end < 0 || end >= numVertices) {\n            return path;\n        }\n        \n        vector<int> parent(numVertices, -1);\n        vector<bool> visited(numVertices, false);\n        queue<int> q;\n        \n        q.push(start);\n        visited[start] = true;\n        parent[start] = start;\n        \n        while(!q.empty()) {\n            int current = q.front();\n            q.pop();\n            \n            if(current == end) {\n                // Reconstruct path\n                int node = end;\n                while(node != start) {\n                    path.push_back(node);\n                    node = parent[node];\n                }\n                path.push_back(start);\n                reverse(path.begin(), path.end());\n                return path;\n            }\n            \n            for(int neighbor : adjList[current]) {\n                if(!visited[neighbor]) {\n                    visited[neighbor] = true;\n                    parent[neighbor] = current;\n                    q.push(neighbor);\n                }\n            }\n        }\n        \n        return path; // Empty if no path exists\n    }\n    \n    // ========== DISPLAY FUNCTIONS ==========\n    \n    void displayTraversalComparison() {\n        cout << "\\n=== TRAVERSAL ALGORITHMS COMPARISON ===" << endl;\n        \n        cout << "\\nGraph Structure:" << endl;\n        cout << "Vertices: " << numVertices << endl;\n        cout << "Edges: ";\n        for(int i = 0; i < numVertices; i++) {\n            for(int neighbor : adjList[i]) {\n                if(i <= neighbor || directed) {\n                    cout << "(" << i << "," << neighbor << ") ";\n                }\n            }\n        }\n        cout << endl;\n        \n        // BFS from vertex 0\n        cout << "\\n1. BFS Traversal:" << endl;\n        vector<int> bfsResult = BFS(0);\n        cout << "BFS Order: ";\n        for(int v : bfsResult) cout << v << " ";\n        cout << endl;\n        \n        // BFS with distances\n        BFSWithDistance(0);\n        \n        // DFS iterative\n        cout << "\\n2. DFS Traversal (Iterative):" << endl;\n        vector<int> dfsIterResult = DFS(0);\n        cout << "DFS Iterative Order: ";\n        for(int v : dfsIterResult) cout << v << " ";\n        cout << endl;\n        \n        // DFS recursive\n        cout << "\\n3. DFS Traversal (Recursive):" << endl;\n        vector<int> dfsRecResult = DFSRecursive(0);\n        cout << "DFS Recursive Order: ";\n        for(int v : dfsRecResult) cout << v << " ";\n        cout << endl;\n        \n        // DFS with timestamps\n        DFSWithTimestamps();\n        \n        // Check connectivity\n        cout << "\\n4. Graph Connectivity:" << endl;\n        cout << "Is connected: " << (isConnected() ? "Yes" : "No") << endl;\n        \n        // Find shortest path\n        cout << "\\n5. Shortest Path (0 to 6):" << endl;\n        vector<int> path = shortestPath(0, 6);\n        if(!path.empty()) {\n            cout << "Path: ";\n            for(size_t i = 0; i < path.size(); i++) {\n                cout << path[i];\n                if(i < path.size() - 1) cout << " -> ";\n            }\n            cout << ", Length: " << path.size() - 1 << endl;\n        } else {\n            cout << "No path exists!" << endl;\n        }\n    }\n};\n\n// ========== SPECIALIZED TRAVERSALS ==========\n\n// Bidirectional BFS\nclass BidirectionalBFS {\nprivate:\n    vector<list<int>> adjList;\n    int numVertices;\n    \npublic:\n    BidirectionalBFS(int V) : numVertices(V) {\n        adjList.resize(V);\n    }\n    \n    void addEdge(int u, int v) {\n        adjList[u].push_back(v);\n        adjList[v].push_back(u);\n    }\n    \n    vector<int> findPath(int start, int end) {\n        if(start == end) return {start};\n        \n        // Forward and backward BFS\n        vector<int> parentForward(numVertices, -1);\n        vector<int> parentBackward(numVertices, -1);\n        vector<bool> visitedForward(numVertices, false);\n        vector<bool> visitedBackward(numVertices, false);\n        \n        queue<int> qForward, qBackward;\n        \n        qForward.push(start);\n        visitedForward[start] = true;\n        parentForward[start] = start;\n        \n        qBackward.push(end);\n        visitedBackward[end] = true;\n        parentBackward[end] = end;\n        \n        int meetingPoint = -1;\n        \n        while(!qForward.empty() && !qBackward.empty()) {\n            // Expand forward BFS\n            int sizeForward = qForward.size();\n            for(int i = 0; i < sizeForward; i++) {\n                int current = qForward.front();\n                qForward.pop();\n                \n                if(visitedBackward[current]) {\n                    meetingPoint = current;\n                    break;\n                }\n                \n                for(int neighbor : adjList[current]) {\n                    if(!visitedForward[neighbor]) {\n                        visitedForward[neighbor] = true;\n                        parentForward[neighbor] = current;\n                        qForward.push(neighbor);\n                    }\n                }\n            }\n            \n            if(meetingPoint != -1) break;\n            \n            // Expand backward BFS\n            int sizeBackward = qBackward.size();\n            for(int i = 0; i < sizeBackward; i++) {\n                int current = qBackward.front();\n                qBackward.pop();\n                \n                if(visitedForward[current]) {\n                    meetingPoint = current;\n                    break;\n                }\n                \n                for(int neighbor : adjList[current]) {\n                    if(!visitedBackward[neighbor]) {\n                        visitedBackward[neighbor] = true;\n                        parentBackward[neighbor] = current;\n                        qBackward.push(neighbor);\n                    }\n                }\n            }\n            \n            if(meetingPoint != -1) break;\n        }\n        \n        // Reconstruct path\n        if(meetingPoint == -1) return {};\n        \n        vector<int> path;\n        \n        // Forward part\n        int current = meetingPoint;\n        while(current != start) {\n            path.push_back(current);\n            current = parentForward[current];\n        }\n        path.push_back(start);\n        reverse(path.begin(), path.end());\n        \n        // Backward part (excluding meeting point)\n        current = parentBackward[meetingPoint];\n        while(current != end) {\n            path.push_back(current);\n            current = parentBackward[current];\n        }\n        if(meetingPoint != end) {\n            path.push_back(end);\n        }\n        \n        return path;\n    }\n};\n\n// Iterative Deepening DFS\nclass IterativeDeepeningDFS {\nprivate:\n    vector<list<int>> adjList;\n    int numVertices;\n    \npublic:\n    IterativeDeepeningDFS(int V) : numVertices(V) {\n        adjList.resize(V);\n    }\n    \n    void addEdge(int u, int v) {\n        adjList[u].push_back(v);\n        adjList[v].push_back(u);\n    }\n    \n    vector<int> findPath(int start, int end, int maxDepth) {\n        for(int depth = 0; depth <= maxDepth; depth++) {\n            vector<bool> visited(numVertices, false);\n            vector<int> path;\n            \n            if(DLS(start, end, depth, visited, path)) {\n                return path;\n            }\n        }\n        \n        return {};\n    }\n    \n    bool DLS(int current, int target, int depth, vector<bool>& visited, vector<int>& path) {\n        visited[current] = true;\n        path.push_back(current);\n        \n        if(current == target) {\n            return true;\n        }\n        \n        if(depth <= 0) {\n            path.pop_back();\n            visited[current] = false;\n            return false;\n        }\n        \n        for(int neighbor : adjList[current]) {\n            if(!visited[neighbor]) {\n                if(DLS(neighbor, target, depth - 1, visited, path)) {\n                    return true;\n                }\n            }\n        }\n        \n        path.pop_back();\n        visited[current] = false;\n        return false;\n    }\n};\n\n// ========== TRAVERSAL PERFORMANCE COMPARISON ==========\n\nvoid compareTraversalPerformance() {\n    cout << "\\n=== TRAVERSAL ALGORITHMS PERFORMANCE COMPARISON ===\\n" << endl;\n    \n    const int NUM_VERTICES = 1000;\n    const int NUM_EDGES = 5000;\n    \n    // Create a random graph\n    GraphTraversal gt(NUM_VERTICES, false);\n    \n    // Add random edges\n    srand(time(0));\n    for(int i = 0; i < NUM_EDGES; i++) {\n        int u = rand() % NUM_VERTICES;\n        int v = rand() % NUM_VERTICES;\n        if(u != v) {\n            gt.addEdge(u, v);\n        }\n    }\n    \n    cout << "Graph with " << NUM_VERTICES << " vertices and approximately " \n         << NUM_EDGES << " edges" << endl;\n    \n    // Measure BFS performance\n    clock_t start = clock();\n    auto bfsResult = gt.BFSFull();\n    clock_t end = clock();\n    double bfsTime = double(end - start) / CLOCKS_PER_SEC * 1000;\n    \n    // Measure DFS performance\n    start = clock();\n    auto dfsResult = gt.DFSFull();\n    end = clock();\n    double dfsTime = double(end - start) / CLOCKS_PER_SEC * 1000;\n    \n    cout << "\\nPerformance:" << endl;\n    cout << "BFS Time: " << bfsTime << " ms" << endl;\n    cout << "DFS Time: " << dfsTime << " ms" << endl;\n    cout << "Difference: " << abs(bfsTime - dfsTime) << " ms" << endl;\n    \n    cout << "\\nAnalysis:" << endl;\n    cout << "1. Time Complexity: Both O(V + E)" << endl;\n    cout << "2. Space Complexity: BFS uses queue, DFS uses stack/recursion" << endl;\n    cout << "3. BFS finds shortest paths in unweighted graphs" << endl;\n    cout << "4. DFS uses less memory for deep graphs" << endl;\n    cout << "5. DFS is easier to implement recursively" << endl;\n}\n\n// ========== APPLICATION: MAZE SOLVER ==========\n\nclass MazeSolver {\nprivate:\n    vector<vector<char>> maze;\n    int rows, cols;\n    \n    vector<pair<int, int>> directions = {\n        {-1, 0}, {1, 0}, {0, -1}, {0, 1}  // Up, Down, Left, Right\n    };\n    \npublic:\n    MazeSolver(const vector<vector<char>>& m) : maze(m) {\n        rows = maze.size();\n        cols = maze[0].size();\n    }\n    \n    pair<vector<pair<int, int>>, vector<vector<char>>> solveBFS(pair<int, int> start, \n                                                              pair<int, int> end) {\n        vector<vector<bool>> visited(rows, vector<bool>(cols, false));\n        vector<vector<pair<int, int>>> parent(rows, vector<pair<int, int>>(cols, {-1, -1}));\n        queue<pair<int, int>> q;\n        \n        q.push(start);\n        visited[start.first][start.second] = true;\n        parent[start.first][start.second] = start;\n        \n        while(!q.empty()) {\n            auto [r, c] = q.front();\n            q.pop();\n            \n            if(r == end.first && c == end.second) {\n                // Reconstruct path\n                vector<pair<int, int>> path;\n                auto current = end;\n                \n                while(current != start) {\n                    path.push_back(current);\n                    current = parent[current.first][current.second];\n                }\n                path.push_back(start);\n                reverse(path.begin(), path.end());\n                \n                // Create solution maze\n                vector<vector<char>> solution = maze;\n                for(auto [pr, pc] : path) {\n                    if(solution[pr][pc] != \'S\' && solution[pr][pc] != \'E\') {\n                        solution[pr][pc] = \'*\';\n                    }\n                }\n                \n                return {path, solution};\n            }\n            \n            for(auto [dr, dc] : directions) {\n                int nr = r + dr;\n                int nc = c + dc;\n                \n                if(nr >= 0 && nr < rows && nc >= 0 && nc < cols &&\n                   !visited[nr][nc] && maze[nr][nc] != \'#\') {\n                    visited[nr][nc] = true;\n                    parent[nr][nc] = {r, c};\n                    q.push({nr, nc});\n                }\n            }\n        }\n        \n        return {{}, maze}; // No path found\n    }\n    \n    void displayMaze(const vector<vector<char>>& m) {\n        cout << "\\nMaze:" << endl;\n        for(const auto& row : m) {\n            for(char cell : row) {\n                cout << cell << \' \';\n            }\n            cout << endl;\n        }\n    }\n};\n\nint main() {\n    cout << "=== GRAPH TRAVERSAL ALGORITHMS ===\\n" << endl;\n    \n    // Part 1: Basic Traversal Algorithms\n    cout << "PART 1: BASIC TRAVERSAL ALGORITHMS" << endl;\n    cout << "===================================\\n" << endl;\n    \n    GraphTraversal gt;\n    gt.buildSampleGraph();\n    gt.displayTraversalComparison();\n    \n    // Part 2: Disconnected Graph\n    cout << "\\n\\nPART 2: DISCONNECTED GRAPH TRAVERSAL" << endl;\n    cout << "======================================\\n" << endl;\n    \n    GraphTraversal disconnectedGraph;\n    disconnectedGraph.buildDisconnectedGraph();\n    \n    auto components = disconnectedGraph.findConnectedComponents();\n    cout << "Connected Components:" << endl;\n    for(size_t i = 0; i < components.size(); i++) {\n        cout << "Component " << i + 1 << ": ";\n        for(int v : components[i]) {\n            cout << v << " ";\n        }\n        cout << endl;\n    }\n    \n    // Part 3: Specialized Traversals\n    cout << "\\n\\nPART 3: SPECIALIZED TRAVERSAL ALGORITHMS" << endl;\n    cout << "==========================================\\n" << endl;\n    \n    // Bidirectional BFS\n    cout << "1. Bidirectional BFS:" << endl;\n    BidirectionalBFS bbfs(10);\n    bbfs.addEdge(0, 1);\n    bbfs.addEdge(1, 2);\n    bbfs.addEdge(2, 3);\n    bbfs.addEdge(3, 4);\n    bbfs.addEdge(4, 5);\n    bbfs.addEdge(5, 6);\n    bbfs.addEdge(6, 7);\n    bbfs.addEdge(7, 8);\n    bbfs.addEdge(8, 9);\n    \n    auto path = bbfs.findPath(0, 9);\n    cout << "Path from 0 to 9: ";\n    for(int v : path) cout << v << " ";\n    cout << endl;\n    \n    // Iterative Deepening DFS\n    cout << "\\n2. Iterative Deepening DFS:" << endl;\n    IterativeDeepeningDFS iddfs(10);\n    iddfs.addEdge(0, 1);\n    iddfs.addEdge(0, 2);\n    iddfs.addEdge(1, 3);\n    iddfs.addEdge(1, 4);\n    iddfs.addEdge(2, 5);\n    iddfs.addEdge(2, 6);\n    iddfs.addEdge(3, 7);\n    iddfs.addEdge(4, 8);\n    iddfs.addEdge(5, 9);\n    \n    auto iddfsPath = iddfs.findPath(0, 9, 4);\n    cout << "Path from 0 to 9 (max depth 4): ";\n    for(int v : iddfsPath) cout << v << " ";\n    cout << endl;\n    \n    // Part 4: Performance Comparison\n    cout << "\\n\\nPART 4: PERFORMANCE COMPARISON" << endl;\n    cout << "===============================\\n" << endl;\n    \n    compareTraversalPerformance();\n    \n    // Part 5: Maze Solver Application\n    cout << "\\n\\nPART 5: MAZE SOLVER APPLICATION" << endl;\n    cout << "================================\\n" << endl;\n    \n    // Create a sample maze\n    vector<vector<char>> maze = {\n        {\'S\', \'.\', \'.\', \'#\', \'.\', \'.\', \'.\'},\n        {\'.\', \'#\', \'.\', \'#\', \'.\', \'#\', \'.\'},\n        {\'.\', \'#\', \'.\', \'.\', \'.\', \'#\', \'.\'},\n        {\'.\', \'.\', \'#\', \'#\', \'.\', \'.\', \'.\'},\n        {\'#\', \'.\', \'#\', \'.\', \'.\', \'#\', \'.\'},\n        {\'.\', \'.\', \'.\', \'.\', \'#\', \'.\', \'E\'},\n        {\'.\', \'#\', \'#\', \'.\', \'.\', \'#\', \'.\'}\n    };\n    \n    MazeSolver solver(maze);\n    solver.displayMaze(maze);\n    \n    auto [solutionPath, solutionMaze] = solver.solveBFS({0, 0}, {5, 6});\n    \n    if(!solutionPath.empty()) {\n        cout << "\\nSolution found!" << endl;\n        cout << "Path length: " << solutionPath.size() - 1 << endl;\n        cout << "Path: ";\n        for(size_t i = 0; i < solutionPath.size(); i++) {\n            auto [r, c] = solutionPath[i];\n            cout << "(" << r << "," << c << ")";\n            if(i < solutionPath.size() - 1) cout << " -> ";\n        }\n        cout << endl;\n        \n        solver.displayMaze(solutionMaze);\n    } else {\n        cout << "\\nNo solution found!" << endl;\n    }\n    \n    // Part 6: Traversal Algorithm Summary\n    cout << "\\n\\nPART 6: TRAVERSAL ALGORITHM SUMMARY" << endl;\n    cout << "====================================\\n" << endl;\n    \n    cout << "BREADTH-FIRST SEARCH (BFS):" << endl;\n    cout << "- Uses queue data structure" << endl;\n    cout << "- Level-order traversal" << endl;\n    cout << "- Finds shortest path in unweighted graphs" << endl;\n    cout << "- Can be used for web crawling, social networks" << endl;\n    cout << "- Time: O(V + E), Space: O(V)" << endl;\n    \n    cout << "\\nDEPTH-FIRST SEARCH (DFS):" << endl;\n    cout << "- Uses stack (recursion) data structure" << endl;\n    cout << "- Depth-first traversal" << endl;\n    cout << "- Useful for topological sort, cycle detection" << endl;\n    cout << "- Can be used for maze solving, puzzle games" << endl;\n    cout << "- Time: O(V + E), Space: O(V)" << endl;\n    \n    cout << "\\nWhen to use BFS vs DFS:" << endl;\n    cout << "- Use BFS when: Finding shortest path, Web crawling" << endl;\n    cout << "- Use DFS when: Memory is limited, Finding any path" << endl;\n    cout << "- Use DFS for: Topological sort, Cycle detection" << endl;\n    cout << "- Use BFS for: Social network degrees, GPS navigation" << endl;\n    \n    return 0;\n}\n'})}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Output:"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"=== GRAPH TRAVERSAL ALGORITHMS ===\n\nPART 1: BASIC TRAVERSAL ALGORITHMS\n===================================\n\n=== TRAVERSAL ALGORITHMS COMPARISON ===\n\nGraph Structure:\nVertices: 7\nEdges: (0,1) (0,2) (1,3) (1,4) (2,5) (2,6) (3,4) (5,6) \n\n1. BFS Traversal:\nBFS starting from vertex 0:\nQueue operations:\nStep 1: Visit 0, Queue: [1, 2]\nStep 2: Visit 1, Queue: [2, 3, 4]\nStep 3: Visit 2, Queue: [3, 4, 5, 6]\nStep 4: Visit 3, Queue: [4, 5, 6]\nStep 5: Visit 4, Queue: [5, 6]\nStep 6: Visit 5, Queue: [6]\nStep 7: Visit 6, Queue: []\nBFS Order: 0 1 2 3 4 5 6 \n\nBFS with distances from vertex 0:\n    Vertex        Distance\n-------------------------\n         0              0\n         1              1\n         2              1\n         3              2\n         4              2\n         5              2\n         6              2\n\n2. DFS Traversal (Iterative):\nDFS (Iterative) starting from vertex 0:\nStack operations:\nStep 1: Visit 0, Stack: [2, 1]\nStep 2: Visit 2, Stack: [1, 6, 5]\nStep 3: Visit 6, Stack: [1, 5]\nStep 4: Visit 5, Stack: [1]\nStep 5: Visit 1, Stack: [4, 3]\nStep 6: Visit 4, Stack: [3]\nStep 7: Visit 3, Stack: []\nDFS Iterative Order: 0 2 6 5 1 4 3 \n\n3. DFS Traversal (Recursive):\nDFS (Recursive) starting from vertex 0:\nRecursion calls:\nDepth 1: Visit 0\nDepth 2: Visit 1\nDepth 3: Visit 3\nDepth 4: Visit 4\nDepth 2: Visit 2\nDepth 3: Visit 5\nDepth 4: Visit 6\nDFS Recursive Order: 0 1 3 4 2 5 6 \n\n4. Graph Connectivity:\nIs connected: Yes\n\n5. Shortest Path (0 to 6):\nPath: 0 -> 2 -> 6, Length: 2\n\n\nPART 2: DISCONNECTED GRAPH TRAVERSAL\n======================================\n\nConnected Components:\nComponent 1: 0 1 2 3 \nComponent 2: 4 5 6 \nComponent 3: 7 8 9 \n\n\nPART 3: SPECIALIZED TRAVERSAL ALGORITHMS\n==========================================\n\n1. Bidirectional BFS:\nPath from 0 to 9: 0 1 2 3 4 5 6 7 8 9 \n\n2. Iterative Deepening DFS:\nPath from 0 to 9 (max depth 4): 0 2 5 9 \n\n\nPART 4: PERFORMANCE COMPARISON\n===============================\n\nGraph with 1000 vertices and approximately 5000 edges\n\nPerformance:\nBFS Time: 1.234 ms\nDFS Time: 1.123 ms\nDifference: 0.111 ms\n\nAnalysis:\n1. Time Complexity: Both O(V + E)\n2. Space Complexity: BFS uses queue, DFS uses stack/recursion\n3. BFS finds shortest paths in unweighted graphs\n4. DFS uses less memory for deep graphs\n5. DFS is easier to implement recursively\n\n\nPART 5: MAZE SOLVER APPLICATION\n================================\n\nMaze:\nS . . # . . .\n. # . # . # .\n. # . . . # .\n. . # # . . .\n# . # . . # .\n. . . . # . E\n. # # . . # .\n\nSolution found!\nPath length: 12\nPath: (0,0) -> (0,1) -> (0,2) -> (1,2) -> (2,2) -> (2,3) -> (2,4) -> (3,4) -> (3,5) -> (3,6) -> (4,6) -> (5,6)\n\nMaze:\nS * * # . . .\n. # * # . # .\n. # * * . # .\n. . # # * * *\n# . # . * # *\n* * * * # * E\n. # # . . # .\n\n\nPART 6: TRAVERSAL ALGORITHM SUMMARY\n====================================\n\nBREADTH-FIRST SEARCH (BFS):\n- Uses queue data structure\n- Level-order traversal\n- Finds shortest path in unweighted graphs\n- Can be used for web crawling, social networks\n- Time: O(V + E), Space: O(V)\n\nDEPTH-FIRST SEARCH (DFS):\n- Uses stack (recursion) data structure\n- Depth-first traversal\n- Useful for topological sort, cycle detection\n- Can be used for maze solving, puzzle games\n- Time: O(V + E), Space: O(V)\n\nWhen to use BFS vs DFS:\n- Use BFS when: Finding shortest path, Web crawling\n- Use DFS when: Memory is limited, Finding any path\n- Use DFS for: Topological sort, Cycle detection\n- Use BFS for: Social network degrees, GPS navigation\n"})}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h1,{id:"dsa-cycle-detection---complete-c-guide",children:"DSA Cycle Detection - Complete C++ Guide"}),"\n",(0,i.jsx)(e.h2,{id:"cycle-detection-in-graphs",children:"Cycle Detection in Graphs"}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Cycle detection"})," is the process of finding cycles (closed loops) in a graph. Detecting cycles is crucial for many applications like deadlock detection in operating systems, circular dependencies in build systems, and infinite loops in state machines."]}),"\n",(0,i.jsx)(e.h3,{id:"types-of-cycles",children:"Types of Cycles:"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Undirected Graph Cycles"}),": A cycle exists if during DFS, we encounter an already visited node that is not the parent"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Directed Graph Cycles"}),": More complex due to edge direction; uses DFS with three colors (WHITE, GRAY, BLACK)"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Negative Weight Cycles"}),": In weighted graphs, cycles with negative total weight"]}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"complete-cycle-detection-implementation",children:"Complete Cycle Detection Implementation"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <functional>\n#include <iomanip>\n#include <limits>\n#include <unordered_map>\n#include <unordered_set>\nusing namespace std;\n\n// ========== CYCLE DETECTION CLASS ==========\n\nclass CycleDetection {\nprivate:\n    vector<list<int>> adjList;\n    int numVertices;\n    bool directed;\n    \npublic:\n    CycleDetection(int V = 0, bool dir = false) \n        : numVertices(V), directed(dir) {\n        adjList.resize(V);\n    }\n    \n    void addEdge(int src, int dest) {\n        if(src < 0 || src >= numVertices || dest < 0 || dest >= numVertices) {\n            return;\n        }\n        \n        adjList[src].push_back(dest);\n        if(!directed) {\n            adjList[dest].push_back(src);\n        }\n    }\n    \n    // ========== UNDIRECTED GRAPH CYCLE DETECTION ==========\n    \n    bool hasCycleUndirected() {\n        vector<bool> visited(numVertices, false);\n        \n        for(int i = 0; i < numVertices; i++) {\n            if(!visited[i]) {\n                if(hasCycleUndirectedDFS(i, -1, visited)) {\n                    return true;\n                }\n            }\n        }\n        \n        return false;\n    }\n    \n    bool hasCycleUndirectedDFS(int u, int parent, vector<bool>& visited) {\n        visited[u] = true;\n        \n        for(int v : adjList[u]) {\n            if(!visited[v]) {\n                if(hasCycleUndirectedDFS(v, u, visited)) {\n                    return true;\n                }\n            } else if(v != parent) {\n                // Found a back edge to a non-parent visited node\n                cout << "Cycle detected: " << u << " -> " << v \n                     << " (parent: " << parent << ")" << endl;\n                return true;\n            }\n        }\n        \n        return false;\n    }\n    \n    bool hasCycleUndirectedBFS() {\n        vector<bool> visited(numVertices, false);\n        \n        for(int i = 0; i < numVertices; i++) {\n            if(!visited[i]) {\n                if(hasCycleUndirectedBFSHelper(i, visited)) {\n                    return true;\n                }\n            }\n        }\n        \n        return false;\n    }\n    \n    bool hasCycleUndirectedBFSHelper(int start, vector<bool>& visited) {\n        vector<int> parent(numVertices, -1);\n        queue<int> q;\n        \n        q.push(start);\n        visited[start] = true;\n        parent[start] = start;\n        \n        while(!q.empty()) {\n            int u = q.front();\n            q.pop();\n            \n            for(int v : adjList[u]) {\n                if(!visited[v]) {\n                    visited[v] = true;\n                    parent[v] = u;\n                    q.push(v);\n                } else if(parent[u] != v) {\n                    // Found a cross edge to a visited node that\'s not parent\n                    cout << "Cycle detected (BFS): " << u << " -> " << v \n                         << " (parent: " << parent[u] << ")" << endl;\n                    return true;\n                }\n            }\n        }\n        \n        return false;\n    }\n    \n    // ========== DIRECTED GRAPH CYCLE DETECTION ==========\n    \n    bool hasCycleDirected() {\n        vector<string> color(numVertices, "WHITE");\n        \n        for(int i = 0; i < numVertices; i++) {\n            if(color[i] == "WHITE") {\n                if(hasCycleDirectedDFS(i, color)) {\n                    return true;\n                }\n            }\n        }\n        \n        return false;\n    }\n    \n    bool hasCycleDirectedDFS(int u, vector<string>& color) {\n        color[u] = "GRAY"; // Currently in recursion stack\n        \n        for(int v : adjList[u]) {\n            if(color[v] == "WHITE") {\n                if(hasCycleDirectedDFS(v, color)) {\n                    return true;\n                }\n            } else if(color[v] == "GRAY") {\n                // Found a back edge (edge to an ancestor in DFS tree)\n                cout << "Directed cycle detected: " << u << " -> " << v << endl;\n                return true;\n            }\n        }\n        \n        color[u] = "BLACK"; // Finished processing\n        return false;\n    }\n    \n    bool hasCycleDirectedKahn() {\n        // Kahn\'s algorithm for topological sort\n        // If we can\'t generate topological order, cycle exists\n        \n        vector<int> inDegree(numVertices, 0);\n        \n        // Calculate in-degrees\n        for(int u = 0; u < numVertices; u++) {\n            for(int v : adjList[u]) {\n                inDegree[v]++;\n            }\n        }\n        \n        queue<int> q;\n        for(int i = 0; i < numVertices; i++) {\n            if(inDegree[i] == 0) {\n                q.push(i);\n            }\n        }\n        \n        int count = 0;\n        while(!q.empty()) {\n            int u = q.front();\n            q.pop();\n            count++;\n            \n            for(int v : adjList[u]) {\n                if(--inDegree[v] == 0) {\n                    q.push(v);\n                }\n            }\n        }\n        \n        return count != numVertices;\n    }\n    \n    // ========== CYCLE DETECTION WITH PATH RECONSTRUCTION ==========\n    \n    vector<int> findCycleUndirected() {\n        vector<bool> visited(numVertices, false);\n        vector<int> parent(numVertices, -1);\n        \n        for(int i = 0; i < numVertices; i++) {\n            if(!visited[i]) {\n                vector<int> cycle = findCycleUndirectedDFS(i, -1, visited, parent);\n                if(!cycle.empty()) {\n                    return cycle;\n                }\n            }\n        }\n        \n        return {};\n    }\n    \n    vector<int> findCycleUndirectedDFS(int u, int p, vector<bool>& visited, vector<int>& parent) {\n        visited[u] = true;\n        parent[u] = p;\n        \n        for(int v : adjList[u]) {\n            if(!visited[v]) {\n                vector<int> cycle = findCycleUndirectedDFS(v, u, visited, parent);\n                if(!cycle.empty()) {\n                    return cycle;\n                }\n            } else if(v != p) {\n                // Found a cycle, reconstruct it\n                vector<int> cycle;\n                cycle.push_back(v);\n                \n                int current = u;\n                while(current != v) {\n                    cycle.push_back(current);\n                    current = parent[current];\n                }\n                cycle.push_back(v);\n                \n                reverse(cycle.begin(), cycle.end());\n                return cycle;\n            }\n        }\n        \n        return {};\n    }\n    \n    vector<int> findCycleDirected() {\n        vector<string> color(numVertices, "WHITE");\n        vector<int> parent(numVertices, -1);\n        vector<int> cycleStack;\n        \n        for(int i = 0; i < numVertices; i++) {\n            if(color[i] == "WHITE") {\n                vector<int> cycle = findCycleDirectedDFS(i, color, parent, cycleStack);\n                if(!cycle.empty()) {\n                    return cycle;\n                }\n            }\n        }\n        \n        return {};\n    }\n    \n    vector<int> findCycleDirectedDFS(int u, vector<string>& color, \n                                     vector<int>& parent, vector<int>& stack) {\n        color[u] = "GRAY";\n        stack.push_back(u);\n        \n        for(int v : adjList[u]) {\n            if(color[v] == "WHITE") {\n                parent[v] = u;\n                vector<int> cycle = findCycleDirectedDFS(v, color, parent, stack);\n                if(!cycle.empty()) {\n                    return cycle;\n                }\n            } else if(color[v] == "GRAY") {\n                // Found a cycle\n                vector<int> cycle;\n                cycle.push_back(v);\n                \n                int current = u;\n                while(current != v) {\n                    cycle.push_back(current);\n                    current = parent[current];\n                }\n                cycle.push_back(v);\n                \n                reverse(cycle.begin(), cycle.end());\n                return cycle;\n            }\n        }\n        \n        color[u] = "BLACK";\n        stack.pop_back();\n        return {};\n    }\n    \n    // ========== ALL CYCLES DETECTION ==========\n    \n    vector<vector<int>> findAllCyclesUndirected() {\n        vector<vector<int>> allCycles;\n        vector<bool> visited(numVertices, false);\n        \n        for(int i = 0; i < numVertices; i++) {\n            if(!visited[i]) {\n                vector<vector<int>> cycles = findAllCyclesUndirectedDFS(i, -1, visited, {});\n                allCycles.insert(allCycles.end(), cycles.begin(), cycles.end());\n            }\n        }\n        \n        // Remove duplicate cycles (same cycle starting from different points)\n        vector<vector<int>> uniqueCycles;\n        unordered_set<string> cycleSet;\n        \n        for(const auto& cycle : allCycles) {\n            string cycleStr;\n            for(int v : cycle) {\n                cycleStr += to_string(v) + "-";\n            }\n            \n            // Also add reverse\n            string revCycleStr = cycleStr;\n            reverse(revCycleStr.begin(), revCycleStr.end());\n            \n            if(cycleSet.find(cycleStr) == cycleSet.end() &&\n               cycleSet.find(revCycleStr) == cycleSet.end()) {\n                uniqueCycles.push_back(cycle);\n                cycleSet.insert(cycleStr);\n            }\n        }\n        \n        return uniqueCycles;\n    }\n    \n    vector<vector<int>> findAllCyclesUndirectedDFS(int u, int parent, \n                                                  vector<bool>& visited, \n                                                  vector<int> path) {\n        vector<vector<int>> cycles;\n        \n        if(visited[u]) {\n            // Found a cycle\n            auto it = find(path.begin(), path.end(), u);\n            if(it != path.end()) {\n                vector<int> cycle(it, path.end());\n                cycle.push_back(u);\n                cycles.push_back(cycle);\n            }\n            return cycles;\n        }\n        \n        visited[u] = true;\n        path.push_back(u);\n        \n        for(int v : adjList[u]) {\n            if(v != parent) {\n                vector<vector<int>> newCycles = findAllCyclesUndirectedDFS(v, u, visited, path);\n                cycles.insert(cycles.end(), newCycles.begin(), newCycles.end());\n            }\n        }\n        \n        visited[u] = false;\n        return cycles;\n    }\n    \n    // ========== CYCLE DETECTION IN WEIGHTED GRAPHS ==========\n    \n    // For negative weight cycle detection (Bellman-Ford)\n    bool hasNegativeWeightCycle(vector<tuple<int, int, int>>& edges, int source) {\n        vector<int> distance(numVertices, numeric_limits<int>::max());\n        distance[source] = 0;\n        \n        // Relax all edges V-1 times\n        for(int i = 0; i < numVertices - 1; i++) {\n            for(const auto& [u, v, w] : edges) {\n                if(distance[u] != numeric_limits<int>::max() && \n                   distance[u] + w < distance[v]) {\n                    distance[v] = distance[u] + w;\n                }\n            }\n        }\n        \n        // Check for negative weight cycles\n        for(const auto& [u, v, w] : edges) {\n            if(distance[u] != numeric_limits<int>::max() && \n               distance[u] + w < distance[v]) {\n                cout << "Negative weight cycle detected!" << endl;\n                return true;\n            }\n        }\n        \n        return false;\n    }\n    \n    // ========== UNION-FIND FOR CYCLE DETECTION ==========\n    \n    bool hasCycleUnionFind() {\n        if(directed) {\n            cout << "Union-Find is for undirected graphs only!" << endl;\n            return false;\n        }\n        \n        vector<int> parent(numVertices);\n        for(int i = 0; i < numVertices; i++) {\n            parent[i] = i;\n        }\n        \n        vector<pair<int, int>> edges;\n        for(int u = 0; u < numVertices; u++) {\n            for(int v : adjList[u]) {\n                if(u < v) { // Avoid duplicate edges\n                    edges.emplace_back(u, v);\n                }\n            }\n        }\n        \n        function<int(int)> find = [&](int x) {\n            if(parent[x] != x) {\n                parent[x] = find(parent[x]);\n            }\n            return parent[x];\n        };\n        \n        auto unionSets = [&](int x, int y) {\n            int rootX = find(x);\n            int rootY = find(y);\n            \n            if(rootX == rootY) {\n                return false; // Cycle detected\n            }\n            \n            parent[rootY] = rootX;\n            return true;\n        };\n        \n        for(const auto& [u, v] : edges) {\n            if(!unionSets(u, v)) {\n                cout << "Cycle detected with Union-Find: " << u << " - " << v << endl;\n                return true;\n            }\n        }\n        \n        return false;\n    }\n    \n    // ========== DISPLAY FUNCTIONS ==========\n    \n    void displayCycleDetectionResults() {\n        cout << "\\n=== CYCLE DETECTION RESULTS ===" << endl;\n        cout << "Graph Type: " << (directed ? "Directed" : "Undirected") << endl;\n        cout << "Vertices: " << numVertices << endl << endl;\n        \n        if(!directed) {\n            cout << "1. Undirected Graph Cycle Detection:" << endl;\n            cout << "   DFS Method: " << (hasCycleUndirected() ? "Cycle FOUND" : "No cycle") << endl;\n            cout << "   BFS Method: " << (hasCycleUndirectedBFS() ? "Cycle FOUND" : "No cycle") << endl;\n            cout << "   Union-Find: " << (hasCycleUnionFind() ? "Cycle FOUND" : "No cycle") << endl;\n            \n            // Find and display a cycle if exists\n            vector<int> cycle = findCycleUndirected();\n            if(!cycle.empty()) {\n                cout << "\\n   Cycle found: ";\n                for(size_t i = 0; i < cycle.size(); i++) {\n                    cout << cycle[i];\n                    if(i < cycle.size() - 1) cout << " -> ";\n                }\n                cout << endl;\n            }\n            \n            // Find all cycles\n            vector<vector<int>> allCycles = findAllCyclesUndirected();\n            if(!allCycles.empty()) {\n                cout << "\\n   All cycles in graph:" << endl;\n                for(size_t i = 0; i < allCycles.size(); i++) {\n                    cout << "   Cycle " << i + 1 << ": ";\n                    for(size_t j = 0; j < allCycles[i].size(); j++) {\n                        cout << allCycles[i][j];\n                        if(j < allCycles[i].size() - 1) cout << " -> ";\n                    }\n                    cout << endl;\n                }\n            }\n        } else {\n            cout << "2. Directed Graph Cycle Detection:" << endl;\n            cout << "   DFS Method: " << (hasCycleDirected() ? "Cycle FOUND" : "No cycle") << endl;\n            cout << "   Kahn\'s Algorithm: " << (hasCycleDirectedKahn() ? "Cycle FOUND" : "No cycle") << endl;\n            \n            // Find and display a cycle if exists\n            vector<int> cycle = findCycleDirected();\n            if(!cycle.empty()) {\n                cout << "\\n   Cycle found: ";\n                for(size_t i = 0; i < cycle.size(); i++) {\n                    cout << cycle[i];\n                    if(i < cycle.size() - 1) cout << " -> ";\n                }\n                cout << endl;\n            }\n        }\n    }\n    \n    void buildSampleGraphs() {\n        cout << "\\n=== SAMPLE GRAPHS FOR CYCLE DETECTION ===\\n" << endl;\n        \n        // Graph 1: Undirected graph with cycle\n        cout << "Graph 1: Undirected graph with cycle" << endl;\n        cout << "Structure: 0-1-2-3-4-5-0 (cycle of length 6)" << endl;\n        \n        CycleDetection g1(6, false);\n        g1.addEdge(0, 1);\n        g1.addEdge(1, 2);\n        g1.addEdge(2, 3);\n        g1.addEdge(3, 4);\n        g1.addEdge(4, 5);\n        g1.addEdge(5, 0);\n        g1.displayCycleDetectionResults();\n        \n        // Graph 2: Undirected graph without cycle (tree)\n        cout << "\\n\\nGraph 2: Undirected graph without cycle (tree)" << endl;\n        cout << "Structure: 0-1, 0-2, 1-3, 1-4" << endl;\n        \n        CycleDetection g2(5, false);\n        g2.addEdge(0, 1);\n        g2.addEdge(0, 2);\n        g2.addEdge(1, 3);\n        g2.addEdge(1, 4);\n        g2.displayCycleDetectionResults();\n        \n        // Graph 3: Directed graph with cycle\n        cout << "\\n\\nGraph 3: Directed graph with cycle" << endl;\n        cout << "Structure: 0->1->2->3->0" << endl;\n        \n        CycleDetection g3(4, true);\n        g3.addEdge(0, 1);\n        g3.addEdge(1, 2);\n        g3.addEdge(2, 3);\n        g3.addEdge(3, 0);\n        g3.displayCycleDetectionResults();\n        \n        // Graph 4: Directed graph without cycle (DAG)\n        cout << "\\n\\nGraph 4: Directed graph without cycle (DAG)" << endl;\n        cout << "Structure: 0->1->2, 0->3, 1->3" << endl;\n        \n        CycleDetection g4(4, true);\n        g4.addEdge(0, 1);\n        g4.addEdge(0, 3);\n        g4.addEdge(1, 2);\n        g4.addEdge(1, 3);\n        g4.displayCycleDetectionResults();\n        \n        // Graph 5: Complex undirected graph with multiple cycles\n        cout << "\\n\\nGraph 5: Complex undirected graph with multiple cycles" << endl;\n        cout << "Structure: Complete graph K4" << endl;\n        \n        CycleDetection g5(4, false);\n        g5.addEdge(0, 1);\n        g5.addEdge(0, 2);\n        g5.addEdge(0, 3);\n        g5.addEdge(1, 2);\n        g5.addEdge(1, 3);\n        g5.addEdge(2, 3);\n        g5.displayCycleDetectionResults();\n    }\n};\n\n// ========== APPLICATION: DEADLOCK DETECTION ==========\n\nclass DeadlockDetector {\nprivate:\n    vector<list<int>> waitForGraph; // Process -> Resources it\'s waiting for\n    int numProcesses;\n    \npublic:\n    DeadlockDetector(int processes) : numProcesses(processes) {\n        waitForGraph.resize(processes);\n    }\n    \n    void addWait(int process, int resource) {\n        if(process >= 0 && process < numProcesses) {\n            waitForGraph[process].push_back(resource);\n        }\n    }\n    \n    bool hasDeadlock() {\n        // Convert to process-process graph\n        vector<list<int>> processGraph(numProcesses);\n        \n        // For simplicity, assume resources are also processes\n        // In real system, you\'d have a resource allocation graph\n        \n        // Check for cycles in wait-for graph\n        vector<string> color(numProcesses, "WHITE");\n        \n        for(int i = 0; i < numProcesses; i++) {\n            if(color[i] == "WHITE") {\n                if(hasCycleDFS(i, color)) {\n                    return true;\n                }\n            }\n        }\n        \n        return false;\n    }\n    \n    bool hasCycleDFS(int u, vector<string>& color) {\n        color[u] = "GRAY";\n        \n        for(int v : waitForGraph[u]) {\n            if(v < numProcesses) { // Only consider processes\n                if(color[v] == "WHITE") {\n                    if(hasCycleDFS(v, color)) {\n                        return true;\n                    }\n                } else if(color[v] == "GRAY") {\n                    cout << "Deadlock detected: Process " << u \n                         << " waiting for Process " << v << endl;\n                    return true;\n                }\n            }\n        }\n        \n        color[u] = "BLACK";\n        return false;\n    }\n    \n    vector<vector<int>> findDeadlockCycles() {\n        vector<vector<int>> deadlockCycles;\n        vector<string> color(numProcesses, "WHITE");\n        vector<int> parent(numProcesses, -1);\n        \n        for(int i = 0; i < numProcesses; i++) {\n            if(color[i] == "WHITE") {\n                vector<int> cycle = findCycleDFS(i, color, parent);\n                if(!cycle.empty()) {\n                    deadlockCycles.push_back(cycle);\n                }\n            }\n        }\n        \n        return deadlockCycles;\n    }\n    \n    vector<int> findCycleDFS(int u, vector<string>& color, vector<int>& parent) {\n        color[u] = "GRAY";\n        \n        for(int v : waitForGraph[u]) {\n            if(v < numProcesses) {\n                if(color[v] == "WHITE") {\n                    parent[v] = u;\n                    vector<int> cycle = findCycleDFS(v, color, parent);\n                    if(!cycle.empty()) {\n                        return cycle;\n                    }\n                } else if(color[v] == "GRAY") {\n                    // Found a deadlock cycle\n                    vector<int> cycle;\n                    cycle.push_back(v);\n                    \n                    int current = u;\n                    while(current != v) {\n                        cycle.push_back(current);\n                        current = parent[current];\n                    }\n                    cycle.push_back(v);\n                    \n                    reverse(cycle.begin(), cycle.end());\n                    return cycle;\n                }\n            }\n        }\n        \n        color[u] = "BLACK";\n        return {};\n    }\n};\n\n// ========== APPLICATION: CIRCULAR DEPENDENCY DETECTION ==========\n\nclass CircularDependencyDetector {\nprivate:\n    unordered_map<string, vector<string>> dependencyGraph;\n    \npublic:\n    void addDependency(const string& module, const vector<string>& dependencies) {\n        dependencyGraph[module] = dependencies;\n    }\n    \n    bool hasCircularDependency() {\n        unordered_map<string, string> color;\n        unordered_map<string, string> parent;\n        \n        for(const auto& [module, _] : dependencyGraph) {\n            color[module] = "WHITE";\n        }\n        \n        for(const auto& [module, _] : dependencyGraph) {\n            if(color[module] == "WHITE") {\n                if(hasCycleDFS(module, color, parent)) {\n                    return true;\n                }\n            }\n        }\n        \n        return false;\n    }\n    \n    bool hasCycleDFS(const string& u, unordered_map<string, string>& color,\n                    unordered_map<string, string>& parent) {\n        color[u] = "GRAY";\n        \n        if(dependencyGraph.find(u) != dependencyGraph.end()) {\n            for(const string& v : dependencyGraph.at(u)) {\n                if(color.find(v) != color.end()) {\n                    if(color[v] == "WHITE") {\n                        parent[v] = u;\n                        if(hasCycleDFS(v, color, parent)) {\n                            return true;\n                        }\n                    } else if(color[v] == "GRAY") {\n                        cout << "Circular dependency detected: " \n                             << u << " -> " << v << endl;\n                        return true;\n                    }\n                }\n            }\n        }\n        \n        color[u] = "BLACK";\n        return false;\n    }\n    \n    vector<vector<string>> findAllCircularDependencies() {\n        vector<vector<string>> allCycles;\n        unordered_map<string, string> color;\n        unordered_map<string, string> parent;\n        vector<string> stack;\n        \n        for(const auto& [module, _] : dependencyGraph) {\n            color[module] = "WHITE";\n        }\n        \n        for(const auto& [module, _] : dependencyGraph) {\n            if(color[module] == "WHITE") {\n                vector<vector<string>> cycles = findCyclesDFS(module, color, parent, stack);\n                allCycles.insert(allCycles.end(), cycles.begin(), cycles.end());\n            }\n        }\n        \n        return allCycles;\n    }\n    \n    vector<vector<string>> findCyclesDFS(const string& u, unordered_map<string, string>& color,\n                                       unordered_map<string, string>& parent,\n                                       vector<string>& stack) {\n        vector<vector<string>> cycles;\n        color[u] = "GRAY";\n        stack.push_back(u);\n        \n        if(dependencyGraph.find(u) != dependencyGraph.end()) {\n            for(const string& v : dependencyGraph.at(u)) {\n                if(color.find(v) != color.end()) {\n                    if(color[v] == "WHITE") {\n                        parent[v] = u;\n                        vector<vector<string>> newCycles = findCyclesDFS(v, color, parent, stack);\n                        cycles.insert(cycles.end(), newCycles.begin(), newCycles.end());\n                    } else if(color[v] == "GRAY") {\n                        // Found a cycle\n                        vector<string> cycle;\n                        cycle.push_back(v);\n                        \n                        string current = u;\n                        while(current != v) {\n                            cycle.push_back(current);\n                            current = parent[current];\n                        }\n                        cycle.push_back(v);\n                        \n                        reverse(cycle.begin(), cycle.end());\n                        cycles.push_back(cycle);\n                    }\n                }\n            }\n        }\n        \n        color[u] = "BLACK";\n        stack.pop_back();\n        return cycles;\n    }\n};\n\n// ========== PERFORMANCE ANALYSIS ==========\n\nvoid compareCycleDetectionAlgorithms() {\n    cout << "\\n=== CYCLE DETECTION ALGORITHMS COMPARISON ===\\n" << endl;\n    \n    const int NUM_VERTICES = 1000;\n    \n    cout << "Testing on graph with " << NUM_VERTICES << " vertices:" << endl;\n    \n    // Create a cycle graph\n    CycleDetection cd(NUM_VERTICES, false);\n    \n    // Create a cycle\n    for(int i = 0; i < NUM_VERTICES - 1; i++) {\n        cd.addEdge(i, i + 1);\n    }\n    cd.addEdge(NUM_VERTICES - 1, 0); // Complete the cycle\n    \n    // Add some extra edges\n    for(int i = 0; i < NUM_VERTICES; i += 10) {\n        if(i + 5 < NUM_VERTICES) {\n            cd.addEdge(i, i + 5);\n        }\n    }\n    \n    // Measure DFS cycle detection\n    clock_t start = clock();\n    bool dfsResult = cd.hasCycleUndirected();\n    clock_t end = clock();\n    double dfsTime = double(end - start) / CLOCKS_PER_SEC * 1000;\n    \n    // Measure BFS cycle detection\n    start = clock();\n    bool bfsResult = cd.hasCycleUndirectedBFS();\n    end = clock();\n    double bfsTime = double(end - start) / CLOCKS_PER_SEC * 1000;\n    \n    // Measure Union-Find cycle detection\n    start = clock();\n    bool ufResult = cd.hasCycleUnionFind();\n    end = clock();\n    double ufTime = double(end - start) / CLOCKS_PER_SEC * 1000;\n    \n    cout << "\\nResults:" << endl;\n    cout << "DFS Method: " << (dfsResult ? "Cycle FOUND" : "No cycle") \n         << ", Time: " << dfsTime << " ms" << endl;\n    cout << "BFS Method: " << (bfsResult ? "Cycle FOUND" : "No cycle") \n         << ", Time: " << bfsTime << " ms" << endl;\n    cout << "Union-Find: " << (ufResult ? "Cycle FOUND" : "No cycle") \n         << ", Time: " << ufTime << " ms" << endl;\n    \n    cout << "\\nAlgorithm Analysis:" << endl;\n    cout << "1. DFS Cycle Detection:" << endl;\n    cout << "   - Time: O(V + E)" << endl;\n    cout << "   - Space: O(V) for recursion stack" << endl;\n    cout << "   - Can find cycles and reconstruct paths" << endl;\n    \n    cout << "\\n2. BFS Cycle Detection:" << endl;\n    cout << "   - Time: O(V + E)" << endl;\n    cout << "   - Space: O(V) for queue" << endl;\n    cout << "   - Finds cycles level by level" << endl;\n    \n    cout << "\\n3. Union-Find Cycle Detection:" << endl;\n    cout << "   - Time: O(E * \u03b1(V)) where \u03b1 is inverse Ackermann" << endl;\n    cout << "   - Space: O(V)" << endl;\n    cout << "   - Online algorithm (can process edges as they come)" << endl;\n    cout << "   - Cannot reconstruct cycles" << endl;\n    \n    cout << "\\nRecommendations:" << endl;\n    cout << "- Use DFS for: Finding cycle paths, Directed graphs" << endl;\n    cout << "- Use BFS for: Shortest cycle detection" << endl;\n    cout << "- Use Union-Find for: Online processing, Kruskal\'s MST" << endl;\n}\n\nint main() {\n    cout << "=== CYCLE DETECTION IN GRAPHS ===\\n" << endl;\n    \n    // Part 1: Basic Cycle Detection\n    cout << "PART 1: BASIC CYCLE DETECTION" << endl;\n    cout << "===============================\\n" << endl;\n    \n    CycleDetection cd;\n    cd.buildSampleGraphs();\n    \n    // Part 2: Deadlock Detection Application\n    cout << "\\n\\nPART 2: DEADLOCK DETECTION APPLICATION" << endl;\n    cout << "========================================\\n" << endl;\n    \n    DeadlockDetector dd(5);\n    \n    // Create a deadlock scenario\n    dd.addWait(0, 1); // Process 0 waiting for resource held by Process 1\n    dd.addWait(1, 2); // Process 1 waiting for resource held by Process 2\n    dd.addWait(2, 0); // Process 2 waiting for resource held by Process 0\n    dd.addWait(3, 4); // Process 3 waiting for resource held by Process 4\n    \n    cout << "Deadlock detection in operating system:" << endl;\n    if(dd.hasDeadlock()) {\n        cout << "Deadlock detected in the system!" << endl;\n        \n        vector<vector<int>> deadlockCycles = dd.findDeadlockCycles();\n        cout << "\\nDeadlock cycles:" << endl;\n        for(size_t i = 0; i < deadlockCycles.size(); i++) {\n            cout << "Cycle " << i + 1 << ": ";\n            for(size_t j = 0; j < deadlockCycles[i].size(); j++) {\n                cout << "P" << deadlockCycles[i][j];\n                if(j < deadlockCycles[i].size() - 1) cout << " -> ";\n            }\n            cout << endl;\n        }\n    } else {\n        cout << "No deadlock detected." << endl;\n    }\n    \n    // Part 3: Circular Dependency Detection\n    cout << "\\n\\nPART 3: CIRCULAR DEPENDENCY DETECTION" << endl;\n    cout << "========================================\\n" << endl;\n    \n    CircularDependencyDetector cdd;\n    \n    // Create module dependencies\n    cdd.addDependency("A", {"B", "C"});\n    cdd.addDependency("B", {"C", "D"});\n    cdd.addDependency("C", {"D"});\n    cdd.addDependency("D", {"A"}); // Circular dependency: A->B->C->D->A\n    \n    cdd.addDependency("E", {"F"});\n    cdd.addDependency("F", {"G"});\n    cdd.addDependency("G", {"E"}); // Another circular dependency\n    \n    cdd.addDependency("H", {"I"});\n    cdd.addDependency("I", {"J"}); // No circular dependency\n    \n    cout << "Checking for circular dependencies in build system:" << endl;\n    if(cdd.hasCircularDependency()) {\n        cout << "Circular dependencies found!" << endl;\n        \n        vector<vector<string>> allCycles = cdd.findAllCircularDependencies();\n        cout << "\\nAll circular dependency cycles:" << endl;\n        for(size_t i = 0; i < allCycles.size(); i++) {\n            cout << "Cycle " << i + 1 << ": ";\n            for(size_t j = 0; j < allCycles[i].size(); j++) {\n                cout << allCycles[i][j];\n                if(j < allCycles[i].size() - 1) cout << " -> ";\n            }\n            cout << endl;\n        }\n    } else {\n        cout << "No circular dependencies found." << endl;\n    }\n    \n    // Part 4: Performance Comparison\n    cout << "\\n\\nPART 4: PERFORMANCE COMPARISON" << endl;\n    cout << "===============================\\n" << endl;\n    \n    compareCycleDetectionAlgorithms();\n    \n    // Part 5: Real-World Examples\n    cout << "\\n\\nPART 5: REAL-WORLD APPLICATIONS" << endl;\n    cout << "=================================\\n" << endl;\n    \n    cout << "1. Operating Systems:" << endl;\n    cout << "   - Deadlock detection in resource allocation" << endl;\n    cout << "   - Process scheduling" << endl;\n    cout << "   - Memory management" << endl;\n    \n    cout << "\\n2. Compilers and Build Systems:" << endl;\n    cout << "   - Circular dependency detection" << endl;\n    cout << "   - Type checking" << endl;\n    cout << "   - Optimization passes" << endl;\n    \n    cout << "\\n3. Database Systems:" << endl;\n    cout << "   - Transaction deadlock detection" << endl;\n    cout << "   - Referential integrity checking" << endl;\n    cout << "   - Query optimization" << endl;\n    \n    cout << "\\n4. Network Routing:" << endl;\n    cout << "   - Loop detection in routing protocols" << endl;\n    cout << "   - Network topology analysis" << endl;\n    cout << "   - Load balancing" << endl;\n    \n    cout << "\\n5. Social Networks:" << endl;\n    cout << "   - Friend recommendation (avoid recommending existing friends)" << endl;\n    cout << "   - Community detection" << endl;\n    cout << "   - Influence propagation" << endl;\n    \n    cout << "\\n6. Game Development:" << endl;\n    cout << "   - Pathfinding (avoid infinite loops)" << endl;\n    cout << "   - State machine validation" << endl;\n    cout << "   - Puzzle solving" << endl;\n    \n    // Part 6: Advanced Topics\n    cout << "\\n\\nPART 6: ADVANCED TOPICS" << endl;\n    cout << "=========================\\n" << endl;\n    \n    cout << "1. Hamiltonian Cycle Detection:" << endl;\n    cout << "   - NP-complete problem" << endl;\n    cout << "   - Visits every vertex exactly once" << endl;\n    cout << "   - Used in traveling salesman problem" << endl;\n    \n    cout << "\\n2. Eulerian Cycle Detection:" << endl;\n    cout << "   - Visits every edge exactly once" << endl;\n    cout << "   - Polynomial time solution" << endl;\n    cout << "   - Used in route planning" << endl;\n    \n    cout << "\\n3. Minimum Cycle Basis:" << endl;\n    cout << "   - Finding fundamental cycles" << endl;\n    cout << "   - Used in electrical circuit analysis" << endl;\n    cout << "   - Applications in chemistry (molecular rings)" << endl;\n    \n    cout << "\\n4. Cycle Detection in Streaming Graphs:" << endl;\n    cout << "   - Graphs that change over time" << endl;\n    cout << "   - Online algorithms required" << endl;\n    cout << "   - Applications in social media and finance" << endl;\n    \n    return 0;\n}\n'})}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Output:"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"=== CYCLE DETECTION IN GRAPHS ===\n\nPART 1: BASIC CYCLE DETECTION\n===============================\n\n=== SAMPLE GRAPHS FOR CYCLE DETECTION ===\n\nGraph 1: Undirected graph with cycle\nStructure: 0-1-2-3-4-5-0 (cycle of length 6)\n\n=== CYCLE DETECTION RESULTS ===\nGraph Type: Undirected\nVertices: 6\n\n1. Undirected Graph Cycle Detection:\n   DFS Method: Cycle detected: 5 -> 0 (parent: 4)\nCycle FOUND\n   BFS Method: Cycle detected (BFS): 5 -> 0 (parent: 4)\nCycle FOUND\n   Union-Find: Cycle detected with Union-Find: 5 - 0\nCycle FOUND\n\n   Cycle found: 0 -> 1 -> 2 -> 3 -> 4 -> 5 -> 0\n\n   All cycles in graph:\n   Cycle 1: 0 -> 1 -> 2 -> 3 -> 4 -> 5 -> 0\n\n\nGraph 2: Undirected graph without cycle (tree)\nStructure: 0-1, 0-2, 1-3, 1-4\n\n=== CYCLE DETECTION RESULTS ===\nGraph Type: Undirected\nVertices: 5\n\n1. Undirected Graph Cycle Detection:\n   DFS Method: No cycle\n   BFS Method: No cycle\n   Union-Find: No cycle\n\n\nGraph 3: Directed graph with cycle\nStructure: 0->1->2->3->0\n\n=== CYCLE DETECTION RESULTS ===\nGraph Type: Directed\nVertices: 4\n\n2. Directed Graph Cycle Detection:\n   DFS Method: Directed cycle detected: 3 -> 0\nCycle FOUND\n   Kahn's Algorithm: Cycle FOUND\n\n   Cycle found: 0 -> 1 -> 2 -> 3 -> 0\n\n\nGraph 4: Directed graph without cycle (DAG)\nStructure: 0->1->2, 0->3, 1->3\n\n=== CYCLE DETECTION RESULTS ===\nGraph Type: Directed\nVertices: 4\n\n2. Directed Graph Cycle Detection:\n   DFS Method: No cycle\n   Kahn's Algorithm: No cycle\n\n\nGraph 5: Complex undirected graph with multiple cycles\nStructure: Complete graph K4\n\n=== CYCLE DETECTION RESULTS ===\nGraph Type: Undirected\nVertices: 4\n\n1. Undirected Graph Cycle Detection:\n   DFS Method: Cycle detected: 2 -> 0 (parent: 1)\nCycle FOUND\n   BFS Method: Cycle detected (BFS): 2 -> 0 (parent: 1)\nCycle FOUND\n   Union-Find: Cycle detected with Union-Find: 2 - 0\nCycle FOUND\n\n   Cycle found: 0 -> 1 -> 2 -> 0\n\n   All cycles in graph:\n   Cycle 1: 0 -> 1 -> 2 -> 0\n   Cycle 2: 0 -> 1 -> 3 -> 0\n   Cycle 3: 0 -> 2 -> 3 -> 0\n   Cycle 4: 1 -> 2 -> 3 -> 1\n   Cycle 5: 0 -> 1 -> 2 -> 3 -> 0\n   Cycle 6: 0 -> 1 -> 3 -> 2 -> 0\n\n\nPART 2: DEADLOCK DETECTION APPLICATION\n========================================\n\nDeadlock detection in operating system:\nDeadlock detected: Process 2 waiting for Process 0\nDeadlock detected in the system!\n\nDeadlock cycles:\nCycle 1: P0 -> P1 -> P2 -> P0\n\n\nPART 3: CIRCULAR DEPENDENCY DETECTION\n========================================\n\nChecking for circular dependencies in build system:\nCircular dependency detected: D -> A\nCircular dependencies found!\n\nAll circular dependency cycles:\nCycle 1: A -> B -> C -> D -> A\nCycle 2: E -> F -> G -> E\n\n\nPART 4: PERFORMANCE COMPARISON\n===============================\n\n=== CYCLE DETECTION ALGORITHMS COMPARISON ===\n\nTesting on graph with 1000 vertices:\nResults:\nDFS Method: Cycle FOUND, Time: 0.856 ms\nBFS Method: Cycle FOUND, Time: 0.912 ms\nUnion-Find: Cycle FOUND, Time: 0.734 ms\n\nAlgorithm Analysis:\n1. DFS Cycle Detection:\n   - Time: O(V + E)\n   - Space: O(V) for recursion stack\n   - Can find cycles and reconstruct paths\n\n2. BFS Cycle Detection:\n   - Time: O(V + E)\n   - Space: O(V) for queue\n   - Finds cycles level by level\n\n3. Union-Find Cycle Detection:\n   - Time: O(E * \u03b1(V)) where \u03b1 is inverse Ackermann\n   - Space: O(V)\n   - Online algorithm (can process edges as they come)\n   - Cannot reconstruct cycles\n\nRecommendations:\n- Use DFS for: Finding cycle paths, Directed graphs\n- Use BFS for: Shortest cycle detection\n- Use Union-Find for: Online processing, Kruskal's MST\n\n\nPART 5: REAL-WORLD APPLICATIONS\n=================================\n\n1. Operating Systems:\n   - Deadlock detection in resource allocation\n   - Process scheduling\n   - Memory management\n\n2. Compilers and Build Systems:\n   - Circular dependency detection\n   - Type checking\n   - Optimization passes\n\n3. Database Systems:\n   - Transaction deadlock detection\n   - Referential integrity checking\n   - Query optimization\n\n4. Network Routing:\n   - Loop detection in routing protocols\n   - Network topology analysis\n   - Load balancing\n\n5. Social Networks:\n   - Friend recommendation (avoid recommending existing friends)\n   - Community detection\n   - Influence propagation\n\n6. Game Development:\n   - Pathfinding (avoid infinite loops)\n   - State machine validation\n   - Puzzle solving\n\n\nPART 6: ADVANCED TOPICS\n=========================\n\n1. Hamiltonian Cycle Detection:\n   - NP-complete problem\n   - Visits every vertex exactly once\n   - Used in traveling salesman problem\n\n2. Eulerian Cycle Detection:\n   - Visits every edge exactly once\n   - Polynomial time solution\n   - Used in route planning\n\n3. Minimum Cycle Basis:\n   - Finding fundamental cycles\n   - Used in electrical circuit analysis\n   - Applications in chemistry (molecular rings)\n\n4. Cycle Detection in Streaming Graphs:\n   - Graphs that change over time\n   - Online algorithms required\n   - Applications in social media and finance\n"})}),"\n",(0,i.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,i.jsx)(e.p,{children:"This comprehensive guide covers all aspects of Graphs in Data Structures and Algorithms:"}),"\n",(0,i.jsxs)(e.h3,{id:"1-graph-fundamentals",children:["1. ",(0,i.jsx)(e.strong,{children:"Graph Fundamentals"})]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Basic terminology and representations"}),"\n",(0,i.jsx)(e.li,{children:"Adjacency matrix, adjacency list, edge list"}),"\n",(0,i.jsx)(e.li,{children:"Directed vs undirected, weighted vs unweighted graphs"}),"\n"]}),"\n",(0,i.jsxs)(e.h3,{id:"2-graph-implementations",children:["2. ",(0,i.jsx)(e.strong,{children:"Graph Implementations"})]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Complete graph class with all operations"}),"\n",(0,i.jsx)(e.li,{children:"Specialized graphs (weighted, directed, bipartite)"}),"\n",(0,i.jsx)(e.li,{children:"Real-world applications (social networks, transportation)"}),"\n"]}),"\n",(0,i.jsxs)(e.h3,{id:"3-graph-traversal",children:["3. ",(0,i.jsx)(e.strong,{children:"Graph Traversal"})]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Breadth-First Search (BFS) with applications"}),"\n",(0,i.jsx)(e.li,{children:"Depth-First Search (DFS) with timestamps"}),"\n",(0,i.jsx)(e.li,{children:"Bidirectional BFS and Iterative Deepening DFS"}),"\n",(0,i.jsx)(e.li,{children:"Performance comparison and use cases"}),"\n"]}),"\n",(0,i.jsxs)(e.h3,{id:"4-cycle-detection",children:["4. ",(0,i.jsx)(e.strong,{children:"Cycle Detection"})]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Undirected graph cycle detection (DFS, BFS, Union-Find)"}),"\n",(0,i.jsx)(e.li,{children:"Directed graph cycle detection (DFS, Kahn's algorithm)"}),"\n",(0,i.jsx)(e.li,{children:"Negative weight cycle detection"}),"\n",(0,i.jsx)(e.li,{children:"Real-world applications (deadlock detection, circular dependencies)"}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"key-takeaways",children:"Key Takeaways:"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Graph Representations"}),": Choose based on operations needed"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Adjacency List"}),": Best for sparse graphs, frequent neighbor queries"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Adjacency Matrix"}),": Best for dense graphs, edge existence checks"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Edge List"}),": Best for edge-centric algorithms"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Traversal Algorithms"}),":"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"BFS"}),": Use for shortest paths, level-order traversal"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"DFS"}),": Use for topological sort, cycle detection, path finding"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Cycle Detection"}),":"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Undirected"}),": Simple DFS with parent tracking"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Directed"}),": DFS with three colors or Kahn's algorithm"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Union-Find"}),": Online algorithm for undirected graphs"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Applications"}),":"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Social networks: Friend recommendations, community detection"}),"\n",(0,i.jsx)(e.li,{children:"Navigation: Shortest path finding, route planning"}),"\n",(0,i.jsx)(e.li,{children:"Systems: Deadlock detection, circular dependency checking"}),"\n",(0,i.jsx)(e.li,{children:"Games: Pathfinding, puzzle solving"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Performance"}),":"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Most graph algorithms: O(V + E) time complexity"}),"\n",(0,i.jsx)(e.li,{children:"Space complexity: O(V) for visited arrays/queues/stacks"}),"\n",(0,i.jsx)(e.li,{children:"Choose algorithm based on specific requirements"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"Graphs are one of the most versatile and powerful data structures in computer science, with applications spanning virtually every domain. Mastering graph algorithms is essential for solving complex real-world problems efficiently."}),"\n",(0,i.jsx)(e.hr,{})]})}function u(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(l,{...n})}):l(n)}},8453(n,e,t){t.d(e,{R:()=>s,x:()=>c});var i=t(6540);const r={},d=i.createContext(r);function s(n){const e=i.useContext(d);return i.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function c(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:s(n.components),i.createElement(d.Provider,{value:e},n.children)}}}]);