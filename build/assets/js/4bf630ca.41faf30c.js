"use strict";(globalThis.webpackChunkmarkdown_web_app=globalThis.webpackChunkmarkdown_web_app||[]).push([[224],{7677(n,e,t){t.r(e),t.d(e,{assets:()=>a,contentTitle:()=>o,default:()=>d,frontMatter:()=>s,metadata:()=>u,toc:()=>c});var i=t(4848),r=t(8453);const s={id:"stacks-queues",title:"Stacks Queues"},o="Stacks & Queues",u={id:"stacks-queues",title:"Stacks Queues",description:"Introduction to Stacks & Queues",source:"@site/docs/stacks-queues.md",sourceDirName:".",slug:"/stacks-queues",permalink:"/markdown-web-app/stacks-queues",draft:!1,unlisted:!1,editUrl:"https://github.com/kalyxon/markdown-web-app/tree/main/docs/stacks-queues.md",tags:[],version:"current",frontMatter:{id:"stacks-queues",title:"Stacks Queues"},sidebar:"dsa",previous:{title:"Linked list",permalink:"/markdown-web-app/linked-list"},next:{title:"Hash Tables",permalink:"/markdown-web-app/hash-tables"}},a={},c=[{value:"Introduction to Stacks &amp; Queues",id:"introduction-to-stacks--queues",level:2},{value:"Key Characteristics Comparison:",id:"key-characteristics-comparison",level:3},{value:"DSA Stacks",id:"dsa-stacks",level:2},{value:"1. Introduction to Stacks",id:"1-introduction-to-stacks",level:3},{value:"Visual Representation:",id:"visual-representation",level:4},{value:"2. Stack Operations Complexity",id:"2-stack-operations-complexity",level:3},{value:"3. Stack Implementation using Arrays",id:"3-stack-implementation-using-arrays",level:3},{value:"4. Stack Implementation using Linked Lists",id:"4-stack-implementation-using-linked-lists",level:3},{value:"5. Stack Applications and Use Cases",id:"5-stack-applications-and-use-cases",level:3},{value:"DSA Queues",id:"dsa-queues",level:2},{value:"1. Introduction to Queues",id:"1-introduction-to-queues",level:3},{value:"Visual Representation:",id:"visual-representation-1",level:4},{value:"2. Queue Operations Complexity",id:"2-queue-operations-complexity",level:3},{value:"3. Queue Implementation using Arrays (Linear Queue)",id:"3-queue-implementation-using-arrays-linear-queue",level:3},{value:"4. Circular Queue Implementation",id:"4-circular-queue-implementation",level:3},{value:"5. Queue Implementation using Linked Lists",id:"5-queue-implementation-using-linked-lists",level:3},{value:"6. Queue Applications and Use Cases",id:"6-queue-applications-and-use-cases",level:3},{value:"Comparison: Stack vs Queue Implementations",id:"comparison-stack-vs-queue-implementations",level:2},{value:"STL Stack and Queue",id:"stl-stack-and-queue",level:2},{value:"Common Interview Questions",id:"common-interview-questions",level:2},{value:"1. Implement Stack using Queues",id:"1-implement-stack-using-queues",level:3},{value:"2. Implement Queue using Stacks",id:"2-implement-queue-using-stacks",level:3},{value:"3. Next Greater Element",id:"3-next-greater-element",level:3},{value:"Summary",id:"summary",level:2},{value:"Stacks Summary:",id:"stacks-summary",level:3},{value:"Queues Summary:",id:"queues-summary",level:3},{value:"Key Differences:",id:"key-differences",level:3},{value:"When to Choose:",id:"when-to-choose",level:3},{value:"Best Practices:",id:"best-practices",level:3},{value:"Common Pitfalls:",id:"common-pitfalls",level:3}];function l(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.header,{children:(0,i.jsx)(e.h1,{id:"stacks--queues",children:"Stacks & Queues"})}),"\n",(0,i.jsx)(e.h2,{id:"introduction-to-stacks--queues",children:"Introduction to Stacks & Queues"}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Stacks"})," and ",(0,i.jsx)(e.strong,{children:"Queues"})," are linear data structures that follow specific ",(0,i.jsx)(e.strong,{children:"order of operations"}),". They are fundamental building blocks in computer science with numerous applications in algorithms, system design, and real-world problem-solving."]}),"\n",(0,i.jsx)(e.h3,{id:"key-characteristics-comparison",children:"Key Characteristics Comparison:"}),"\n",(0,i.jsxs)(e.table,{children:[(0,i.jsx)(e.thead,{children:(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.th,{children:"Aspect"}),(0,i.jsx)(e.th,{children:"Stack"}),(0,i.jsx)(e.th,{children:"Queue"})]})}),(0,i.jsxs)(e.tbody,{children:[(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:(0,i.jsx)(e.strong,{children:"Principle"})}),(0,i.jsx)(e.td,{children:"LIFO (Last-In-First-Out)"}),(0,i.jsx)(e.td,{children:"FIFO (First-In-First-Out)"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:(0,i.jsx)(e.strong,{children:"Operations"})}),(0,i.jsx)(e.td,{children:"Push, Pop, Peek"}),(0,i.jsx)(e.td,{children:"Enqueue, Dequeue, Front"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:(0,i.jsx)(e.strong,{children:"Insertion"})}),(0,i.jsx)(e.td,{children:"Top only"}),(0,i.jsx)(e.td,{children:"Rear only"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:(0,i.jsx)(e.strong,{children:"Removal"})}),(0,i.jsx)(e.td,{children:"Top only"}),(0,i.jsx)(e.td,{children:"Front only"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:(0,i.jsx)(e.strong,{children:"Access"})}),(0,i.jsx)(e.td,{children:"Top element only"}),(0,i.jsx)(e.td,{children:"Front element only"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:(0,i.jsx)(e.strong,{children:"Analogy"})}),(0,i.jsx)(e.td,{children:"Stack of plates"}),(0,i.jsx)(e.td,{children:"Line of people"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:(0,i.jsx)(e.strong,{children:"Time Complexity"})}),(0,i.jsx)(e.td,{children:"O(1) for all operations"}),(0,i.jsx)(e.td,{children:"O(1) for all operations"})]})]})]}),"\n",(0,i.jsx)(e.h2,{id:"dsa-stacks",children:"DSA Stacks"}),"\n",(0,i.jsx)(e.h3,{id:"1-introduction-to-stacks",children:"1. Introduction to Stacks"}),"\n",(0,i.jsxs)(e.p,{children:["A ",(0,i.jsx)(e.strong,{children:"Stack"})," is a linear data structure that follows the ",(0,i.jsx)(e.strong,{children:"LIFO (Last-In-First-Out)"})," principle. The last element added is the first one to be removed."]}),"\n",(0,i.jsx)(e.h4,{id:"visual-representation",children:"Visual Representation:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"Operations:       Stack Visualization:\n                 +---+\nPush(10)   \u2192     | 10 |  \u2190 Top\n                 +---+\n                 \nPush(20)   \u2192     +---+\n                 | 20 |  \u2190 Top\n                 +---+\n                 | 10 |\n                 +---+\n                 \nPop()      \u2192     +---+\n                 | 10 |  \u2190 Top\n                 +---+\n                 \nPeek()     \u2192     Returns 10 (doesn't remove)\n"})}),"\n",(0,i.jsx)(e.h3,{id:"2-stack-operations-complexity",children:"2. Stack Operations Complexity"}),"\n",(0,i.jsxs)(e.table,{children:[(0,i.jsx)(e.thead,{children:(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.th,{children:"Operation"}),(0,i.jsx)(e.th,{children:"Time Complexity"}),(0,i.jsx)(e.th,{children:"Description"})]})}),(0,i.jsxs)(e.tbody,{children:[(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:(0,i.jsx)(e.strong,{children:"push()"})}),(0,i.jsx)(e.td,{children:"O(1)"}),(0,i.jsx)(e.td,{children:"Add element to top"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:(0,i.jsx)(e.strong,{children:"pop()"})}),(0,i.jsx)(e.td,{children:"O(1)"}),(0,i.jsx)(e.td,{children:"Remove element from top"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:(0,i.jsx)(e.strong,{children:"peek()/top()"})}),(0,i.jsx)(e.td,{children:"O(1)"}),(0,i.jsx)(e.td,{children:"View top element"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:(0,i.jsx)(e.strong,{children:"isEmpty()"})}),(0,i.jsx)(e.td,{children:"O(1)"}),(0,i.jsx)(e.td,{children:"Check if stack is empty"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:(0,i.jsx)(e.strong,{children:"size()"})}),(0,i.jsx)(e.td,{children:"O(1)"}),(0,i.jsx)(e.td,{children:"Get number of elements"})]})]})]}),"\n",(0,i.jsx)(e.h3,{id:"3-stack-implementation-using-arrays",children:"3. Stack Implementation using Arrays"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <stdexcept>\nusing namespace std;\n\nclass ArrayStack {\nprivate:\n    int* arr;\n    int capacity;\n    int topIndex;\n    \n    // Resize the array when full\n    void resize() {\n        int newCapacity = capacity * 2;\n        int* newArr = new int[newCapacity];\n        \n        for(int i = 0; i < capacity; i++) {\n            newArr[i] = arr[i];\n        }\n        \n        delete[] arr;\n        arr = newArr;\n        capacity = newCapacity;\n        \n        cout << "Stack resized to capacity: " << capacity << endl;\n    }\n    \npublic:\n    // Constructor\n    ArrayStack(int initialCapacity = 5) {\n        capacity = initialCapacity;\n        arr = new int[capacity];\n        topIndex = -1;\n        cout << "Stack created with capacity: " << capacity << endl;\n    }\n    \n    // Destructor\n    ~ArrayStack() {\n        delete[] arr;\n        cout << "Stack destroyed" << endl;\n    }\n    \n    // Push element onto stack\n    void push(int value) {\n        if(isFull()) {\n            resize();\n        }\n        \n        topIndex++;\n        arr[topIndex] = value;\n        cout << "Pushed: " << value << endl;\n        display();\n    }\n    \n    // Pop element from stack\n    int pop() {\n        if(isEmpty()) {\n            throw runtime_error("Stack Underflow! Cannot pop from empty stack.");\n        }\n        \n        int value = arr[topIndex];\n        topIndex--;\n        cout << "Popped: " << value << endl;\n        display();\n        return value;\n    }\n    \n    // Peek at top element\n    int peek() {\n        if(isEmpty()) {\n            throw runtime_error("Stack is empty! Cannot peek.");\n        }\n        \n        int value = arr[topIndex];\n        cout << "Top element: " << value << endl;\n        return value;\n    }\n    \n    // Check if stack is empty\n    bool isEmpty() {\n        return topIndex == -1;\n    }\n    \n    // Check if stack is full\n    bool isFull() {\n        return topIndex == capacity - 1;\n    }\n    \n    // Get current size\n    int size() {\n        return topIndex + 1;\n    }\n    \n    // Get capacity\n    int getCapacity() {\n        return capacity;\n    }\n    \n    // Display stack contents\n    void display() {\n        if(isEmpty()) {\n            cout << "Stack: [Empty]" << endl;\n            return;\n        }\n        \n        cout << "Stack (Top \u2192 Bottom): ";\n        for(int i = topIndex; i >= 0; i--) {\n            cout << arr[i];\n            if(i > 0) cout << " \u2192 ";\n        }\n        cout << " | Size: " << size() << "/" << capacity << endl;\n    }\n    \n    // Visual representation\n    void displayVisual() {\n        cout << "\\n=== Stack Visualization ===" << endl;\n        cout << "Top Index: " << topIndex << endl;\n        cout << "Stack Contents:" << endl;\n        \n        if(isEmpty()) {\n            cout << "  [Empty Stack]" << endl;\n        } else {\n            for(int i = topIndex; i >= 0; i--) {\n                cout << "  +---+" << endl;\n                cout << "  | " << arr[i] << " |";\n                if(i == topIndex) cout << " \u2190 TOP";\n                cout << endl;\n            }\n            cout << "  +---+" << endl;\n            cout << "  BASE" << endl;\n        }\n        cout << "=========================" << endl;\n    }\n};\n\n// Example usage\nvoid demonstrateArrayStack() {\n    cout << "=== Array-Based Stack Implementation ===" << endl;\n    \n    ArrayStack stack(3);  // Small capacity to demonstrate resizing\n    \n    try {\n        // Push operations\n        stack.push(10);\n        stack.push(20);\n        stack.push(30);\n        stack.push(40);  // This will trigger resize\n        \n        // Peek operation\n        stack.peek();\n        \n        // Pop operations\n        stack.pop();\n        stack.pop();\n        \n        // Check size and capacity\n        cout << "\\nCurrent size: " << stack.size() << endl;\n        cout << "Current capacity: " << stack.getCapacity() << endl;\n        \n        // Display visual representation\n        stack.displayVisual();\n        \n        // More operations\n        stack.push(50);\n        stack.push(60);\n        stack.push(70);\n        \n        stack.displayVisual();\n        \n        // Empty the stack\n        while(!stack.isEmpty()) {\n            stack.pop();\n        }\n        \n        // Try to pop from empty stack (will throw exception)\n        // stack.pop();  // Uncomment to see exception\n        \n    } catch(const exception& e) {\n        cout << "Error: " << e.what() << endl;\n    }\n}\n\nint main() {\n    demonstrateArrayStack();\n    return 0;\n}\n'})}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Output:"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"=== Array-Based Stack Implementation ===\nStack created with capacity: 3\nPushed: 10\nStack (Top \u2192 Bottom): 10 | Size: 1/3\nPushed: 20\nStack (Top \u2192 Bottom): 20 \u2192 10 | Size: 2/3\nPushed: 30\nStack (Top \u2192 Bottom): 30 \u2192 20 \u2192 10 | Size: 3/3\nStack resized to capacity: 6\nPushed: 40\nStack (Top \u2192 Bottom): 40 \u2192 30 \u2192 20 \u2192 10 | Size: 4/6\nTop element: 40\nPopped: 40\nStack (Top \u2192 Bottom): 30 \u2192 20 \u2192 10 | Size: 3/6\n\nCurrent size: 3\nCurrent capacity: 6\n\n=== Stack Visualization ===\nTop Index: 2\nStack Contents:\n  +---+\n  | 30 | \u2190 TOP\n  +---+\n  | 20 |\n  +---+\n  | 10 |\n  +---+\n  BASE\n=========================\n"})}),"\n",(0,i.jsx)(e.h3,{id:"4-stack-implementation-using-linked-lists",children:"4. Stack Implementation using Linked Lists"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <stdexcept>\nusing namespace std;\n\nclass LinkedListStack {\nprivate:\n    struct Node {\n        int data;\n        Node* next;\n        \n        Node(int value) : data(value), next(nullptr) {}\n    };\n    \n    Node* top;\n    int stackSize;\n    \npublic:\n    // Constructor\n    LinkedListStack() : top(nullptr), stackSize(0) {\n        cout << "Linked List Stack created" << endl;\n    }\n    \n    // Destructor\n    ~LinkedListStack() {\n        cout << "\\nCleaning up stack..." << endl;\n        while(!isEmpty()) {\n            pop();\n        }\n    }\n    \n    // Push element onto stack\n    void push(int value) {\n        Node* newNode = new Node(value);\n        newNode->next = top;\n        top = newNode;\n        stackSize++;\n        \n        cout << "Pushed: " << value << endl;\n        display();\n    }\n    \n    // Pop element from stack\n    int pop() {\n        if(isEmpty()) {\n            throw runtime_error("Stack Underflow! Cannot pop from empty stack.");\n        }\n        \n        Node* temp = top;\n        int value = temp->data;\n        top = top->next;\n        delete temp;\n        stackSize--;\n        \n        cout << "Popped: " << value << endl;\n        display();\n        return value;\n    }\n    \n    // Peek at top element\n    int peek() {\n        if(isEmpty()) {\n            throw runtime_error("Stack is empty! Cannot peek.");\n        }\n        \n        int value = top->data;\n        cout << "Top element: " << value << endl;\n        return value;\n    }\n    \n    // Check if stack is empty\n    bool isEmpty() {\n        return top == nullptr;\n    }\n    \n    // Get current size\n    int size() {\n        return stackSize;\n    }\n    \n    // Display stack contents\n    void display() {\n        if(isEmpty()) {\n            cout << "Stack: [Empty]" << endl;\n            return;\n        }\n        \n        cout << "Stack (Top \u2192 Bottom): ";\n        Node* current = top;\n        while(current != nullptr) {\n            cout << current->data;\n            if(current->next != nullptr) cout << " \u2192 ";\n            current = current->next;\n        }\n        cout << " | Size: " << size() << endl;\n    }\n    \n    // Visual representation\n    void displayVisual() {\n        cout << "\\n=== Linked List Stack Visualization ===" << endl;\n        cout << "Stack Contents:" << endl;\n        \n        if(isEmpty()) {\n            cout << "  [Empty Stack]" << endl;\n        } else {\n            Node* current = top;\n            while(current != nullptr) {\n                cout << "  +---+" << endl;\n                cout << "  | " << current->data << " |";\n                if(current == top) cout << " \u2190 TOP (address: " << current << ")";\n                cout << endl;\n                cout << "  +---+" << endl;\n                cout << "    |" << endl;\n                cout << "    v" << endl;\n                cout << "  [next: " << (current->next ? to_string(current->next->data) : "NULL") << "]" << endl;\n                \n                current = current->next;\n                if(current != nullptr) {\n                    cout << "    |" << endl;\n                    cout << "    v" << endl;\n                }\n            }\n            cout << "  [NULL]" << endl;\n        }\n        cout << "=====================================" << endl;\n    }\n    \n    // Memory address display for educational purposes\n    void displayMemory() {\n        cout << "\\nMemory Layout:" << endl;\n        Node* current = top;\n        int position = 0;\n        \n        while(current != nullptr) {\n            cout << "Node " << position++ << ": ";\n            cout << "Data=" << current->data << ", ";\n            cout << "Address=" << current << ", ";\n            cout << "Next=" << current->next << endl;\n            current = current->next;\n        }\n    }\n};\n\n// Example usage\nvoid demonstrateLinkedListStack() {\n    cout << "\\n\\n=== Linked List-Based Stack Implementation ===" << endl;\n    \n    LinkedListStack stack;\n    \n    try {\n        // Push operations\n        stack.push(100);\n        stack.push(200);\n        stack.push(300);\n        \n        // Display visual representation\n        stack.displayVisual();\n        \n        // Display memory layout\n        stack.displayMemory();\n        \n        // Peek operation\n        stack.peek();\n        \n        // Pop operations\n        stack.pop();\n        stack.pop();\n        \n        // Check size\n        cout << "\\nCurrent size: " << stack.size() << endl;\n        \n        // More operations\n        stack.push(400);\n        stack.push(500);\n        \n        stack.displayVisual();\n        \n    } catch(const exception& e) {\n        cout << "Error: " << e.what() << endl;\n    }\n}\n\nint main() {\n    demonstrateLinkedListStack();\n    return 0;\n}\n'})}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Output:"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"=== Linked List-Based Stack Implementation ===\nLinked List Stack created\nPushed: 100\nStack: [Empty]\nStack (Top \u2192 Bottom): 100 | Size: 1\nPushed: 200\nStack (Top \u2192 Bottom): 200 \u2192 100 | Size: 2\nPushed: 300\nStack (Top \u2192 Bottom): 300 \u2192 200 \u2192 100 | Size: 3\n\n=== Linked List Stack Visualization ===\nStack Contents:\n  +---+\n  | 300 | \u2190 TOP (address: 0x55a1b2c2deb0)\n  +---+\n    |\n    v\n  [next: 200]\n    |\n    v\n  +---+\n  | 200 |\n  +---+\n    |\n    v\n  [next: 100]\n    |\n    v\n  +---+\n  | 100 |\n  +---+\n    |\n    v\n  [next: NULL]\n  [NULL]\n=====================================\n\nMemory Layout:\nNode 0: Data=300, Address=0x55a1b2c2deb0, Next=0x55a1b2c2de90\nNode 1: Data=200, Address=0x55a1b2c2de90, Next=0x55a1b2c2de70\nNode 2: Data=100, Address=0x55a1b2c2de70, Next=0\n\nTop element: 300\nPopped: 300\nStack (Top \u2192 Bottom): 200 \u2192 100 | Size: 2\nPopped: 200\nStack (Top \u2192 Bottom): 100 | Size: 1\n\nCurrent size: 1\nPushed: 400\nStack (Top \u2192 Bottom): 400 \u2192 100 | Size: 2\nPushed: 500\nStack (Top \u2192 Bottom): 500 \u2192 400 \u2192 100 | Size: 3\n\n=== Linked List Stack Visualization ===\nStack Contents:\n  +---+\n  | 500 | \u2190 TOP (address: 0x55a1b2c2ded0)\n  +---+\n    |\n    v\n  [next: 400]\n    |\n    v\n  +---+\n  | 400 |\n  +---+\n    |\n    v\n  [next: 100]\n    |\n    v\n  +---+\n  | 100 |\n  +---+\n    |\n    v\n  [next: NULL]\n  [NULL]\n=====================================\n\nCleaning up stack...\nPopped: 500\nStack (Top \u2192 Bottom): 400 \u2192 100 | Size: 2\nPopped: 400\nStack (Top \u2192 Bottom): 100 | Size: 1\nPopped: 100\nStack: [Empty]\n"})}),"\n",(0,i.jsx)(e.h3,{id:"5-stack-applications-and-use-cases",children:"5. Stack Applications and Use Cases"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <stack>\n#include <string>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nclass StackApplications {\npublic:\n    // 1. Parentheses Matching\n    static bool isBalancedParentheses(const string& expression) {\n        stack<char> s;\n        cout << "Checking: " << expression << endl;\n        \n        for(char ch : expression) {\n            cout << "  Processing: \'" << ch << "\'" << endl;\n            \n            if(ch == \'(\' || ch == \'[\' || ch == \'{\') {\n                s.push(ch);\n                cout << "    Pushed: " << ch << endl;\n            } \n            else if(ch == \')\' || ch == \']\' || ch == \'}\') {\n                if(s.empty()) {\n                    cout << "    Unmatched closing bracket: " << ch << endl;\n                    return false;\n                }\n                \n                char top = s.top();\n                cout << "    Top of stack: " << top << ", Current: " << ch << endl;\n                \n                if((ch == \')\' && top == \'(\') ||\n                   (ch == \']\' && top == \'[\') ||\n                   (ch == \'}\' && top == \'{\')) {\n                    s.pop();\n                    cout << "    Matched! Popped: " << top << endl;\n                } else {\n                    cout << "    Mismatch! " << top << " vs " << ch << endl;\n                    return false;\n                }\n            }\n        }\n        \n        bool result = s.empty();\n        cout << "  Final result: " << (result ? "Balanced" : "Unbalanced") << endl;\n        return result;\n    }\n    \n    // 2. Expression Evaluation (Postfix)\n    static int evaluatePostfix(const string& expression) {\n        stack<int> s;\n        cout << "\\nEvaluating Postfix: " << expression << endl;\n        \n        for(char ch : expression) {\n            cout << "  Processing: \'" << ch << "\'" << endl;\n            \n            if(isdigit(ch)) {\n                s.push(ch - \'0\');\n                cout << "    Pushed operand: " << (ch - \'0\') << endl;\n            } \n            else if(ch == \' \') {\n                continue;\n            }\n            else {\n                // Operator\n                int operand2 = s.top(); s.pop();\n                int operand1 = s.top(); s.pop();\n                \n                cout << "    Operand1: " << operand1 << ", Operand2: " << operand2;\n                cout << ", Operator: " << ch << endl;\n                \n                int result;\n                switch(ch) {\n                    case \'+\': result = operand1 + operand2; break;\n                    case \'-\': result = operand1 - operand2; break;\n                    case \'*\': result = operand1 * operand2; break;\n                    case \'/\': result = operand1 / operand2; break;\n                    case \'^\': result = pow(operand1, operand2); break;\n                    default: throw runtime_error("Invalid operator");\n                }\n                \n                s.push(result);\n                cout << "    Result: " << result << " pushed to stack" << endl;\n            }\n        }\n        \n        int finalResult = s.top();\n        cout << "  Final result: " << finalResult << endl;\n        return finalResult;\n    }\n    \n    // 3. Infix to Postfix Conversion\n    static string infixToPostfix(const string& infix) {\n        stack<char> s;\n        string postfix;\n        \n        // Define precedence\n        auto precedence = [](char op) -> int {\n            if(op == \'^\') return 3;\n            if(op == \'*\' || op == \'/\') return 2;\n            if(op == \'+\' || op == \'-\') return 1;\n            return 0;\n        };\n        \n        cout << "\\nConverting Infix to Postfix: " << infix << endl;\n        \n        for(char ch : infix) {\n            cout << "  Processing: \'" << ch << "\'" << endl;\n            \n            if(isalnum(ch)) {\n                postfix += ch;\n                cout << "    Added to output: " << ch << endl;\n            }\n            else if(ch == \'(\') {\n                s.push(ch);\n                cout << "    Pushed \'(\' to stack" << endl;\n            }\n            else if(ch == \')\') {\n                cout << "    Found \')\', popping until \'(\'" << endl;\n                while(!s.empty() && s.top() != \'(\') {\n                    postfix += s.top();\n                    cout << "    Popped and added to output: " << s.top() << endl;\n                    s.pop();\n                }\n                s.pop(); // Remove \'(\'\n            }\n            else { // Operator\n                cout << "    Operator: " << ch << ", Precedence: " << precedence(ch) << endl;\n                while(!s.empty() && precedence(s.top()) >= precedence(ch)) {\n                    postfix += s.top();\n                    cout << "    Popped higher precedence: " << s.top() << endl;\n                    s.pop();\n                }\n                s.push(ch);\n                cout << "    Pushed operator: " << ch << endl;\n            }\n            \n            // Show current state\n            cout << "    Current output: " << postfix << endl;\n            cout << "    Stack: ";\n            stack<char> temp = s;\n            while(!temp.empty()) {\n                cout << temp.top() << " ";\n                temp.pop();\n            }\n            cout << endl;\n        }\n        \n        // Pop remaining operators\n        cout << "  Popping remaining operators from stack" << endl;\n        while(!s.empty()) {\n            postfix += s.top();\n            cout << "    Popped: " << s.top() << endl;\n            s.pop();\n        }\n        \n        cout << "  Final postfix: " << postfix << endl;\n        return postfix;\n    }\n    \n    // 4. Reverse a string using stack\n    static string reverseString(const string& str) {\n        stack<char> s;\n        \n        cout << "\\nReversing string: " << str << endl;\n        \n        // Push all characters\n        for(char ch : str) {\n            s.push(ch);\n            cout << "  Pushed: " << ch << endl;\n        }\n        \n        // Pop all characters\n        string reversed;\n        while(!s.empty()) {\n            reversed += s.top();\n            cout << "  Popped: " << s.top() << endl;\n            s.pop();\n        }\n        \n        cout << "  Reversed: " << reversed << endl;\n        return reversed;\n    }\n    \n    // 5. Undo/Redo System Simulation\n    static void demonstrateUndoRedo() {\n        cout << "\\n=== Undo/Redo System Simulation ===" << endl;\n        \n        stack<string> undoStack;\n        stack<string> redoStack;\n        string currentText = "";\n        \n        auto performAction = [&](const string& action) {\n            cout << "\\nPerforming action: " << action << endl;\n            undoStack.push(currentText);\n            currentText = action;\n            redoStack = stack<string>(); // Clear redo stack\n            cout << "Current text: " << currentText << endl;\n        };\n        \n        auto undo = [&]() {\n            if(!undoStack.empty()) {\n                redoStack.push(currentText);\n                currentText = undoStack.top();\n                undoStack.pop();\n                cout << "Undo performed. Current text: " << currentText << endl;\n            } else {\n                cout << "Nothing to undo!" << endl;\n            }\n        };\n        \n        auto redo = [&]() {\n            if(!redoStack.empty()) {\n                undoStack.push(currentText);\n                currentText = redoStack.top();\n                redoStack.pop();\n                cout << "Redo performed. Current text: " << currentText << endl;\n            } else {\n                cout << "Nothing to redo!" << endl;\n            }\n        };\n        \n        // Simulate user actions\n        performAction("Hello");\n        performAction("Hello World");\n        performAction("Hello World!");\n        \n        undo();\n        undo();\n        redo();\n        undo();\n        performAction("New Text");\n        undo();\n        redo();\n    }\n};\n\n// Main demonstration\nvoid demonstrateStackApplications() {\n    cout << "=== Stack Applications and Use Cases ===" << endl;\n    \n    // 1. Parentheses Matching\n    cout << "\\n1. Parentheses Matching:" << endl;\n    vector<string> testExpressions = {\n        "((a+b)*c)",\n        "{[()]}",\n        "({[}]",\n        "((())",\n        "a+(b*c)-(d/e)"\n    };\n    \n    for(const auto& expr : testExpressions) {\n        cout << "\\nExpression: " << expr << endl;\n        bool balanced = StackApplications::isBalancedParentheses(expr);\n        cout << "Result: " << (balanced ? "\u2713 Balanced" : "\u2717 Unbalanced") << endl;\n    }\n    \n    // 2. Expression Evaluation\n    cout << "\\n2. Postfix Expression Evaluation:" << endl;\n    string postfix = "23*54*+9-";  // Equivalent to: 2*3 + 5*4 - 9\n    int result = StackApplications::evaluatePostfix(postfix);\n    cout << "Postfix: " << postfix << " = " << result << endl;\n    \n    // 3. Infix to Postfix\n    cout << "\\n3. Infix to Postfix Conversion:" << endl;\n    string infix = "a+b*(c^d-e)^(f+g*h)-i";\n    string converted = StackApplications::infixToPostfix(infix);\n    cout << "Infix: " << infix << endl;\n    cout << "Postfix: " << converted << endl;\n    \n    // 4. String Reversal\n    cout << "\\n4. String Reversal:" << endl;\n    string original = "StackDemo";\n    string reversed = StackApplications::reverseString(original);\n    cout << "Original: " << original << endl;\n    cout << "Reversed: " << reversed << endl;\n    \n    // 5. Undo/Redo System\n    StackApplications::demonstrateUndoRedo();\n}\n\nint main() {\n    demonstrateStackApplications();\n    return 0;\n}\n'})}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Output:"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"=== Stack Applications and Use Cases ===\n\n1. Parentheses Matching:\n\nExpression: ((a+b)*c)\nChecking: ((a+b)*c)\n  Processing: '('\n    Pushed: (\n  Processing: '('\n    Pushed: (\n  Processing: 'a'\n  Processing: '+'\n  Processing: 'b'\n  Processing: ')'\n    Top of stack: (, Current: )\n    Matched! Popped: (\n  Processing: ')'\n    Top of stack: (, Current: )\n    Matched! Popped: (\n  Processing: '*'\n  Processing: 'c'\n  Processing: ')'\n    Top of stack: (, Current: )\n    Matched! Popped: (\n  Final result: Balanced\nResult: \u2713 Balanced\n\n2. Postfix Expression Evaluation:\n\nEvaluating Postfix: 23*54*+9-\n  Processing: '2'\n    Pushed operand: 2\n  Processing: '3'\n    Pushed operand: 3\n  Processing: '*'\n    Operand1: 2, Operand2: 3, Operator: *\n    Result: 6 pushed to stack\n  Processing: '5'\n    Pushed operand: 5\n  Processing: '4'\n    Pushed operand: 4\n  Processing: '*'\n    Operand1: 5, Operand2: 4, Operator: *\n    Result: 20 pushed to stack\n  Processing: '+'\n    Operand1: 6, Operand2: 20, Operator: +\n    Result: 26 pushed to stack\n  Processing: '9'\n    Pushed operand: 9\n  Processing: '-'\n    Operand1: 26, Operand2: 9, Operator: -\n    Result: 17 pushed to stack\n  Final result: 17\nPostfix: 23*54*+9- = 17\n\n3. Infix to Postfix Conversion:\n\nConverting Infix to Postfix: a+b*(c^d-e)^(f+g*h)-i\n  Processing: 'a'\n    Added to output: a\n    Current output: a\n    Stack: \n  Processing: '+'\n    Operator: +, Precedence: 1\n    Pushed operator: +\n    Current output: a\n    Stack: + \n  ... (more steps) ...\n  Final postfix: abcd^e-fgh*+^*+i-\nInfix: a+b*(c^d-e)^(f+g*h)-i\nPostfix: abcd^e-fgh*+^*+i-\n\n4. String Reversal:\n\nReversing string: StackDemo\n  Pushed: S\n  Pushed: t\n  Pushed: a\n  Pushed: c\n  Pushed: k\n  Pushed: D\n  Pushed: e\n  Pushed: m\n  Pushed: o\n  Popped: o\n  Popped: m\n  Popped: e\n  Popped: D\n  Popped: k\n  Popped: c\n  Popped: a\n  Popped: t\n  Popped: S\n  Reversed: omeDkcatS\nOriginal: StackDemo\nReversed: omeDkcatS\n\n5. Undo/Redo System Simulation:\n=== Undo/Redo System Simulation ===\n\nPerforming action: Hello\nCurrent text: Hello\n\nPerforming action: Hello World\nCurrent text: Hello World\n\nPerforming action: Hello World!\nCurrent text: Hello World!\n\nUndo performed. Current text: Hello World\n\nUndo performed. Current text: Hello\n\nRedo performed. Current text: Hello World\n\nUndo performed. Current text: Hello\n\nPerforming action: New Text\nCurrent text: New Text\n\nUndo performed. Current text: Hello\n\nRedo performed. Current text: New Text\n"})}),"\n",(0,i.jsx)(e.h2,{id:"dsa-queues",children:"DSA Queues"}),"\n",(0,i.jsx)(e.h3,{id:"1-introduction-to-queues",children:"1. Introduction to Queues"}),"\n",(0,i.jsxs)(e.p,{children:["A ",(0,i.jsx)(e.strong,{children:"Queue"})," is a linear data structure that follows the ",(0,i.jsx)(e.strong,{children:"FIFO (First-In-First-Out)"})," principle. The first element added is the first one to be removed."]}),"\n",(0,i.jsx)(e.h4,{id:"visual-representation-1",children:"Visual Representation:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"Operations:       Queue Visualization:\n                 Front           Rear\n                 \u2193               \u2193\nEnqueue(10) \u2192   [10]           [10]\n                 \nEnqueue(20) \u2192   [10, 20]       [20]\n                 Front           Rear\n                 \u2193               \u2193\n                 \nEnqueue(30) \u2192   [10, 20, 30]   [30]\n                 Front           Rear\n                 \u2193               \u2193\n                 \nDequeue()   \u2192   [20, 30]       [30]\n                 Front           Rear\n                 \u2193               \u2193\n                 \nPeek()      \u2192   Returns 20 (front element)\n"})}),"\n",(0,i.jsx)(e.h3,{id:"2-queue-operations-complexity",children:"2. Queue Operations Complexity"}),"\n",(0,i.jsxs)(e.table,{children:[(0,i.jsx)(e.thead,{children:(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.th,{children:"Operation"}),(0,i.jsx)(e.th,{children:"Time Complexity"}),(0,i.jsx)(e.th,{children:"Description"})]})}),(0,i.jsxs)(e.tbody,{children:[(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:(0,i.jsx)(e.strong,{children:"enqueue()"})}),(0,i.jsx)(e.td,{children:"O(1)"}),(0,i.jsx)(e.td,{children:"Add element to rear"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:(0,i.jsx)(e.strong,{children:"dequeue()"})}),(0,i.jsx)(e.td,{children:"O(1)"}),(0,i.jsx)(e.td,{children:"Remove element from front"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:(0,i.jsx)(e.strong,{children:"front()"})}),(0,i.jsx)(e.td,{children:"O(1)"}),(0,i.jsx)(e.td,{children:"View front element"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:(0,i.jsx)(e.strong,{children:"rear()"})}),(0,i.jsx)(e.td,{children:"O(1)"}),(0,i.jsx)(e.td,{children:"View rear element"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:(0,i.jsx)(e.strong,{children:"isEmpty()"})}),(0,i.jsx)(e.td,{children:"O(1)"}),(0,i.jsx)(e.td,{children:"Check if queue is empty"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:(0,i.jsx)(e.strong,{children:"size()"})}),(0,i.jsx)(e.td,{children:"O(1)"}),(0,i.jsx)(e.td,{children:"Get number of elements"})]})]})]}),"\n",(0,i.jsx)(e.h3,{id:"3-queue-implementation-using-arrays-linear-queue",children:"3. Queue Implementation using Arrays (Linear Queue)"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <stdexcept>\nusing namespace std;\n\nclass LinearQueue {\nprivate:\n    int* arr;\n    int capacity;\n    int frontIndex;\n    int rearIndex;\n    int queueSize;\n    \npublic:\n    // Constructor\n    LinearQueue(int initialCapacity = 5) {\n        capacity = initialCapacity;\n        arr = new int[capacity];\n        frontIndex = 0;\n        rearIndex = -1;\n        queueSize = 0;\n        cout << "Linear Queue created with capacity: " << capacity << endl;\n    }\n    \n    // Destructor\n    ~LinearQueue() {\n        delete[] arr;\n        cout << "Queue destroyed" << endl;\n    }\n    \n    // Enqueue element\n    void enqueue(int value) {\n        if(isFull()) {\n            throw runtime_error("Queue Overflow! Cannot enqueue to full queue.");\n        }\n        \n        rearIndex++;\n        arr[rearIndex] = value;\n        queueSize++;\n        \n        cout << "Enqueued: " << value << endl;\n        display();\n    }\n    \n    // Dequeue element\n    int dequeue() {\n        if(isEmpty()) {\n            throw runtime_error("Queue Underflow! Cannot dequeue from empty queue.");\n        }\n        \n        int value = arr[frontIndex];\n        frontIndex++;\n        queueSize--;\n        \n        cout << "Dequeued: " << value << endl;\n        display();\n        return value;\n    }\n    \n    // Get front element\n    int getFront() {\n        if(isEmpty()) {\n            throw runtime_error("Queue is empty! Cannot get front.");\n        }\n        \n        int value = arr[frontIndex];\n        cout << "Front element: " << value << endl;\n        return value;\n    }\n    \n    // Get rear element\n    int getRear() {\n        if(isEmpty()) {\n            throw runtime_error("Queue is empty! Cannot get rear.");\n        }\n        \n        int value = arr[rearIndex];\n        cout << "Rear element: " << value << endl;\n        return value;\n    }\n    \n    // Check if queue is empty\n    bool isEmpty() {\n        return queueSize == 0;\n    }\n    \n    // Check if queue is full\n    bool isFull() {\n        return rearIndex == capacity - 1;\n    }\n    \n    // Get current size\n    int size() {\n        return queueSize;\n    }\n    \n    // Display queue contents\n    void display() {\n        if(isEmpty()) {\n            cout << "Queue: [Empty]" << endl;\n            return;\n        }\n        \n        cout << "Queue (Front \u2192 Rear): ";\n        for(int i = frontIndex; i <= rearIndex; i++) {\n            cout << arr[i];\n            if(i < rearIndex) cout << " \u2190 ";\n        }\n        cout << " | Size: " << size() << "/" << capacity << endl;\n        cout << "Front Index: " << frontIndex << ", Rear Index: " << rearIndex << endl;\n    }\n    \n    // Visual representation\n    void displayVisual() {\n        cout << "\\n=== Linear Queue Visualization ===" << endl;\n        cout << "Indices:  ";\n        for(int i = 0; i < capacity; i++) {\n            cout << "[" << i << "] ";\n        }\n        cout << endl;\n        \n        cout << "Contents: ";\n        for(int i = 0; i < capacity; i++) {\n            if(i >= frontIndex && i <= rearIndex) {\n                cout << " " << arr[i] << "  ";\n            } else if(i < frontIndex && i <= rearIndex) {\n                cout << " X   ";  // Dequeued space\n            } else {\n                cout << " -   ";  // Empty space\n            }\n        }\n        cout << endl;\n        \n        cout << "Markers:  ";\n        for(int i = 0; i < capacity; i++) {\n            if(i == frontIndex && i == rearIndex) {\n                cout << " F/R ";\n            } else if(i == frontIndex) {\n                cout << " F   ";\n            } else if(i == rearIndex) {\n                cout << "  R  ";\n            } else {\n                cout << "     ";\n            }\n        }\n        cout << endl;\n        \n        cout << "Front: " << frontIndex << ", Rear: " << rearIndex;\n        cout << ", Size: " << queueSize << ", Capacity: " << capacity << endl;\n        cout << "==================================" << endl;\n    }\n    \n    // Demonstrate the problem with linear queue\n    void demonstrateWastedSpace() {\n        cout << "\\n=== Demonstrating Wasted Space in Linear Queue ===" << endl;\n        \n        // Enqueue until full\n        while(!isFull()) {\n            enqueue(queueSize + 1);\n        }\n        \n        displayVisual();\n        \n        // Dequeue some elements\n        cout << "\\nDequeueing 3 elements..." << endl;\n        for(int i = 0; i < 3; i++) {\n            dequeue();\n        }\n        \n        displayVisual();\n        \n        cout << "\\nProblem: Even though we have 3 empty spaces at beginning,";\n        cout << "\\nwe cannot enqueue more because rear is at capacity-1!" << endl;\n        cout << "This is why we need Circular Queue." << endl;\n    }\n};\n\n// Example usage\nvoid demonstrateLinearQueue() {\n    cout << "=== Linear Queue Implementation ===" << endl;\n    \n    LinearQueue queue(5);\n    \n    try {\n        // Enqueue operations\n        queue.enqueue(10);\n        queue.enqueue(20);\n        queue.enqueue(30);\n        \n        // Display visual representation\n        queue.displayVisual();\n        \n        // Get front and rear\n        queue.getFront();\n        queue.getRear();\n        \n        // Dequeue operations\n        queue.dequeue();\n        queue.dequeue();\n        \n        // Check size\n        cout << "\\nCurrent size: " << queue.size() << endl;\n        \n        // More operations\n        queue.enqueue(40);\n        queue.enqueue(50);\n        queue.enqueue(60);\n        \n        queue.displayVisual();\n        \n        // Demonstrate wasted space problem\n        queue.demonstrateWastedSpace();\n        \n    } catch(const exception& e) {\n        cout << "Error: " << e.what() << endl;\n    }\n}\n\nint main() {\n    demonstrateLinearQueue();\n    return 0;\n}\n'})}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Output:"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"=== Linear Queue Implementation ===\nLinear Queue created with capacity: 5\nEnqueued: 10\nQueue (Front \u2192 Rear): 10 | Size: 1/5\nFront Index: 0, Rear Index: 0\nEnqueued: 20\nQueue (Front \u2192 Rear): 10 \u2190 20 | Size: 2/5\nFront Index: 0, Rear Index: 1\nEnqueued: 30\nQueue (Front \u2192 Rear): 10 \u2190 20 \u2190 30 | Size: 3/5\nFront Index: 0, Rear Index: 2\n\n=== Linear Queue Visualization ===\nIndices:  [0] [1] [2] [3] [4] \nContents:  10  20  30  -   -  \nMarkers:   F         R        \nFront: 0, Rear: 2, Size: 3, Capacity: 5\n==================================\nFront element: 10\nRear element: 30\nDequeued: 10\nQueue (Front \u2192 Rear): 20 \u2190 30 | Size: 2/5\nFront Index: 1, Rear Index: 2\nDequeued: 20\nQueue (Front \u2192 Rear): 30 | Size: 1/5\nFront Index: 2, Rear Index: 2\n\nCurrent size: 1\nEnqueued: 40\nQueue (Front \u2192 Rear): 30 \u2190 40 | Size: 2/5\nFront Index: 2, Rear Index: 3\nEnqueued: 50\nQueue (Front \u2192 Rear): 30 \u2190 40 \u2190 50 | Size: 3/5\nFront Index: 2, Rear Index: 4\nEnqueued: 60\nQueue (Front \u2192 Rear): 30 \u2190 40 \u2190 50 \u2190 60 | Size: 4/5\nFront Index: 2, Rear Index: 5\n\n=== Linear Queue Visualization ===\nIndices:  [0] [1] [2] [3] [4] [5] \nContents:  -   -   30  40  50  60  \nMarkers:          F             R  \nFront: 2, Rear: 5, Size: 4, Capacity: 6\n==================================\n"})}),"\n",(0,i.jsx)(e.h3,{id:"4-circular-queue-implementation",children:"4. Circular Queue Implementation"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <stdexcept>\nusing namespace std;\n\nclass CircularQueue {\nprivate:\n    int* arr;\n    int capacity;\n    int frontIndex;\n    int rearIndex;\n    int queueSize;\n    \n    // Helper to get next index\n    int nextIndex(int index) {\n        return (index + 1) % capacity;\n    }\n    \n    // Helper to get previous index\n    int prevIndex(int index) {\n        return (index - 1 + capacity) % capacity;\n    }\n    \npublic:\n    // Constructor\n    CircularQueue(int initialCapacity = 5) {\n        capacity = initialCapacity;\n        arr = new int[capacity];\n        frontIndex = -1;\n        rearIndex = -1;\n        queueSize = 0;\n        cout << "Circular Queue created with capacity: " << capacity << endl;\n    }\n    \n    // Destructor\n    ~CircularQueue() {\n        delete[] arr;\n        cout << "Circular Queue destroyed" << endl;\n    }\n    \n    // Enqueue element\n    void enqueue(int value) {\n        if(isFull()) {\n            throw runtime_error("Queue Overflow! Cannot enqueue to full queue.");\n        }\n        \n        if(isEmpty()) {\n            frontIndex = rearIndex = 0;\n        } else {\n            rearIndex = nextIndex(rearIndex);\n        }\n        \n        arr[rearIndex] = value;\n        queueSize++;\n        \n        cout << "Enqueued: " << value << endl;\n        display();\n    }\n    \n    // Dequeue element\n    int dequeue() {\n        if(isEmpty()) {\n            throw runtime_error("Queue Underflow! Cannot dequeue from empty queue.");\n        }\n        \n        int value = arr[frontIndex];\n        \n        if(frontIndex == rearIndex) {\n            // Last element\n            frontIndex = rearIndex = -1;\n        } else {\n            frontIndex = nextIndex(frontIndex);\n        }\n        \n        queueSize--;\n        \n        cout << "Dequeued: " << value << endl;\n        display();\n        return value;\n    }\n    \n    // Get front element\n    int getFront() {\n        if(isEmpty()) {\n            throw runtime_error("Queue is empty! Cannot get front.");\n        }\n        \n        int value = arr[frontIndex];\n        cout << "Front element: " << value << endl;\n        return value;\n    }\n    \n    // Get rear element\n    int getRear() {\n        if(isEmpty()) {\n            throw runtime_error("Queue is empty! Cannot get rear.");\n        }\n        \n        int value = arr[rearIndex];\n        cout << "Rear element: " << value << endl;\n        return value;\n    }\n    \n    // Check if queue is empty\n    bool isEmpty() {\n        return queueSize == 0;\n    }\n    \n    // Check if queue is full\n    bool isFull() {\n        return queueSize == capacity;\n    }\n    \n    // Get current size\n    int size() {\n        return queueSize;\n    }\n    \n    // Get capacity\n    int getCapacity() {\n        return capacity;\n    }\n    \n    // Display queue contents\n    void display() {\n        if(isEmpty()) {\n            cout << "Queue: [Empty]" << endl;\n            return;\n        }\n        \n        cout << "Queue (Front \u2192 Rear): ";\n        int i = frontIndex;\n        int count = 0;\n        \n        while(count < queueSize) {\n            cout << arr[i];\n            if(count < queueSize - 1) cout << " \u2190 ";\n            i = nextIndex(i);\n            count++;\n        }\n        \n        cout << " | Size: " << size() << "/" << capacity << endl;\n        cout << "Front Index: " << frontIndex << ", Rear Index: " << rearIndex << endl;\n    }\n    \n    // Visual representation\n    void displayVisual() {\n        cout << "\\n=== Circular Queue Visualization ===" << endl;\n        cout << "Indices:  ";\n        for(int i = 0; i < capacity; i++) {\n            cout << "[" << i << "] ";\n        }\n        cout << endl;\n        \n        cout << "Contents: ";\n        for(int i = 0; i < capacity; i++) {\n            bool hasElement = false;\n            int elementValue = 0;\n            \n            // Check if this index has an element\n            if(!isEmpty()) {\n                int current = frontIndex;\n                for(int j = 0; j < queueSize; j++) {\n                    if(current == i) {\n                        hasElement = true;\n                        elementValue = arr[i];\n                        break;\n                    }\n                    current = nextIndex(current);\n                }\n            }\n            \n            if(hasElement) {\n                cout << " " << elementValue << "  ";\n            } else {\n                cout << " -   ";\n            }\n        }\n        cout << endl;\n        \n        cout << "Markers:  ";\n        for(int i = 0; i < capacity; i++) {\n            if(isEmpty()) {\n                cout << "     ";\n            } else if(i == frontIndex && i == rearIndex) {\n                cout << " F/R ";\n            } else if(i == frontIndex) {\n                cout << " F   ";\n            } else if(i == rearIndex) {\n                cout << "  R  ";\n            } else {\n                cout << "     ";\n            }\n        }\n        cout << endl;\n        \n        // Circular visualization\n        cout << "\\nCircular View:" << endl;\n        cout << "    ";\n        for(int i = 0; i < capacity; i++) {\n            cout << "+---";\n        }\n        cout << "+" << endl;\n        \n        cout << "    |";\n        for(int i = 0; i < capacity; i++) {\n            if(!isEmpty() && ((frontIndex <= rearIndex && i >= frontIndex && i <= rearIndex) ||\n               (frontIndex > rearIndex && (i >= frontIndex || i <= rearIndex)))) {\n                cout << " " << arr[i] << " |";\n            } else {\n                cout << "   |";\n            }\n        }\n        cout << endl;\n        \n        cout << "    ";\n        for(int i = 0; i < capacity; i++) {\n            cout << "+---";\n        }\n        cout << "+" << endl;\n        \n        cout << "     ";\n        for(int i = 0; i < capacity; i++) {\n            if(i == frontIndex && i == rearIndex) {\n                cout << "F/R ";\n            } else if(i == frontIndex) {\n                cout << "F   ";\n            } else if(i == rearIndex) {\n                cout << " R  ";\n            } else {\n                cout << "    ";\n            }\n        }\n        cout << endl;\n        \n        cout << "Front: " << frontIndex << ", Rear: " << rearIndex;\n        cout << ", Size: " << queueSize << ", Capacity: " << capacity << endl;\n        cout << "======================================" << endl;\n    }\n    \n    // Demonstrate circular nature\n    void demonstrateCircularNature() {\n        cout << "\\n=== Demonstrating Circular Queue Behavior ===" << endl;\n        \n        // Fill the queue\n        cout << "Filling queue to capacity..." << endl;\n        for(int i = 1; i <= capacity; i++) {\n            enqueue(i * 10);\n        }\n        \n        displayVisual();\n        \n        // Dequeue some elements\n        cout << "\\nDequeueing 2 elements..." << endl;\n        dequeue();\n        dequeue();\n        \n        displayVisual();\n        \n        // Enqueue more elements (should wrap around)\n        cout << "\\nEnqueueing 2 more elements (wrapping around)..." << endl;\n        enqueue(60);\n        enqueue(70);\n        \n        displayVisual();\n        \n        // Show the circular movement\n        cout << "\\nCircular Movement:" << endl;\n        cout << "After wrap-around, front is at index " << frontIndex;\n        cout << " and rear is at index " << rearIndex << endl;\n        cout << "Queue effectively uses all available space!" << endl;\n    }\n};\n\n// Example usage\nvoid demonstrateCircularQueue() {\n    cout << "\\n\\n=== Circular Queue Implementation ===" << endl;\n    \n    CircularQueue queue(5);\n    \n    try {\n        // Demonstrate basic operations\n        queue.enqueue(10);\n        queue.enqueue(20);\n        queue.enqueue(30);\n        \n        queue.displayVisual();\n        \n        queue.getFront();\n        queue.getRear();\n        \n        queue.dequeue();\n        queue.dequeue();\n        \n        cout << "\\nCurrent size: " << queue.size() << endl;\n        \n        queue.enqueue(40);\n        queue.enqueue(50);\n        queue.enqueue(60);\n        queue.enqueue(70);\n        \n        queue.displayVisual();\n        \n        // Demonstrate circular nature\n        queue.demonstrateCircularNature();\n        \n    } catch(const exception& e) {\n        cout << "Error: " << e.what() << endl;\n    }\n}\n\nint main() {\n    demonstrateCircularQueue();\n    return 0;\n}\n'})}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Output:"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"=== Circular Queue Implementation ===\nCircular Queue created with capacity: 5\nEnqueued: 10\nQueue: [Empty]\nQueue (Front \u2192 Rear): 10 | Size: 1/5\nFront Index: 0, Rear Index: 0\nEnqueued: 20\nQueue (Front \u2192 Rear): 10 \u2190 20 | Size: 2/5\nFront Index: 0, Rear Index: 1\nEnqueued: 30\nQueue (Front \u2192 Rear): 10 \u2190 20 \u2190 30 | Size: 3/5\nFront Index: 0, Rear Index: 2\n\n=== Circular Queue Visualization ===\nIndices:  [0] [1] [2] [3] [4] \nContents:  10  20  30  -   -  \nMarkers:   F         R        \nCircular View:\n    +---+---+---+---+---+\n    | 10| 20| 30|   |   |\n    +---+---+---+---+---+\n     F           R       \nFront: 0, Rear: 2, Size: 3, Capacity: 5\n======================================\n"})}),"\n",(0,i.jsx)(e.h3,{id:"5-queue-implementation-using-linked-lists",children:"5. Queue Implementation using Linked Lists"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <stdexcept>\nusing namespace std;\n\nclass LinkedListQueue {\nprivate:\n    struct Node {\n        int data;\n        Node* next;\n        \n        Node(int value) : data(value), next(nullptr) {}\n    };\n    \n    Node* front;\n    Node* rear;\n    int queueSize;\n    \npublic:\n    // Constructor\n    LinkedListQueue() : front(nullptr), rear(nullptr), queueSize(0) {\n        cout << "Linked List Queue created" << endl;\n    }\n    \n    // Destructor\n    ~LinkedListQueue() {\n        cout << "\\nCleaning up queue..." << endl;\n        while(!isEmpty()) {\n            dequeue();\n        }\n    }\n    \n    // Enqueue element\n    void enqueue(int value) {\n        Node* newNode = new Node(value);\n        \n        if(isEmpty()) {\n            front = rear = newNode;\n        } else {\n            rear->next = newNode;\n            rear = newNode;\n        }\n        \n        queueSize++;\n        \n        cout << "Enqueued: " << value << endl;\n        display();\n    }\n    \n    // Dequeue element\n    int dequeue() {\n        if(isEmpty()) {\n            throw runtime_error("Queue Underflow! Cannot dequeue from empty queue.");\n        }\n        \n        Node* temp = front;\n        int value = temp->data;\n        \n        if(front == rear) {\n            // Last element\n            front = rear = nullptr;\n        } else {\n            front = front->next;\n        }\n        \n        delete temp;\n        queueSize--;\n        \n        cout << "Dequeued: " << value << endl;\n        display();\n        return value;\n    }\n    \n    // Get front element\n    int getFront() {\n        if(isEmpty()) {\n            throw runtime_error("Queue is empty! Cannot get front.");\n        }\n        \n        int value = front->data;\n        cout << "Front element: " << value << endl;\n        return value;\n    }\n    \n    // Get rear element\n    int getRear() {\n        if(isEmpty()) {\n            throw runtime_error("Queue is empty! Cannot get rear.");\n        }\n        \n        int value = rear->data;\n        cout << "Rear element: " << value << endl;\n        return value;\n    }\n    \n    // Check if queue is empty\n    bool isEmpty() {\n        return front == nullptr;\n    }\n    \n    // Get current size\n    int size() {\n        return queueSize;\n    }\n    \n    // Display queue contents\n    void display() {\n        if(isEmpty()) {\n            cout << "Queue: [Empty]" << endl;\n            return;\n        }\n        \n        cout << "Queue (Front \u2192 Rear): ";\n        Node* current = front;\n        while(current != nullptr) {\n            cout << current->data;\n            if(current->next != nullptr) cout << " \u2190 ";\n            current = current->next;\n        }\n        cout << " | Size: " << size() << endl;\n    }\n    \n    // Visual representation\n    void displayVisual() {\n        cout << "\\n=== Linked List Queue Visualization ===" << endl;\n        \n        if(isEmpty()) {\n            cout << "  [Empty Queue]" << endl;\n            cout << "  Front: NULL, Rear: NULL" << endl;\n        } else {\n            Node* current = front;\n            int position = 0;\n            \n            cout << "Front \u2192 ";\n            while(current != nullptr) {\n                cout << "+---+";\n                if(current->next != nullptr) cout << " \u2192 ";\n                current = current->next;\n            }\n            cout << " NULL" << endl;\n            \n            current = front;\n            cout << "       |";\n            while(current != nullptr) {\n                cout << " " << current->data << " |";\n                if(current->next != nullptr) cout << "     ";\n                current = current->next;\n            }\n            cout << endl;\n            \n            current = front;\n            cout << "       +---+";\n            while(current != nullptr && current->next != nullptr) {\n                cout << "     +---+";\n                current = current->next;\n            }\n            cout << endl;\n            \n            // Show pointers\n            cout << "\\nNode Details:" << endl;\n            current = front;\n            position = 0;\n            while(current != nullptr) {\n                cout << "  Node " << position++ << ": ";\n                cout << "Data=" << current->data << ", ";\n                cout << "Address=" << current << ", ";\n                cout << "Next=" << current->next;\n                if(current == front) cout << " [FRONT]";\n                if(current == rear) cout << " [REAR]";\n                cout << endl;\n                current = current->next;\n            }\n        }\n        \n        cout << "Size: " << queueSize << endl;\n        cout << "======================================" << endl;\n    }\n};\n\n// Example usage\nvoid demonstrateLinkedListQueue() {\n    cout << "\\n\\n=== Linked List Queue Implementation ===" << endl;\n    \n    LinkedListQueue queue;\n    \n    try {\n        // Enqueue operations\n        queue.enqueue(100);\n        queue.enqueue(200);\n        queue.enqueue(300);\n        \n        // Display visual representation\n        queue.displayVisual();\n        \n        // Get front and rear\n        queue.getFront();\n        queue.getRear();\n        \n        // Dequeue operations\n        queue.dequeue();\n        queue.dequeue();\n        \n        // Check size\n        cout << "\\nCurrent size: " << queue.size() << endl;\n        \n        // More operations\n        queue.enqueue(400);\n        queue.enqueue(500);\n        queue.enqueue(600);\n        \n        queue.displayVisual();\n        \n        // Show memory efficiency\n        cout << "\\nMemory Efficiency:" << endl;\n        cout << "Unlike array-based queues, linked list queues:" << endl;\n        cout << "1. Never waste space (no fixed capacity)" << endl;\n        cout << "2. Can grow dynamically" << endl;\n        cout << "3. No need for circular logic" << endl;\n        cout << "4. But have pointer overhead" << endl;\n        \n    } catch(const exception& e) {\n        cout << "Error: " << e.what() << endl;\n    }\n}\n\nint main() {\n    demonstrateLinkedListQueue();\n    return 0;\n}\n'})}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Output:"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"=== Linked List Queue Implementation ===\nLinked List Queue created\nEnqueued: 100\nQueue: [Empty]\nQueue (Front \u2192 Rear): 100 | Size: 1\nEnqueued: 200\nQueue (Front \u2192 Rear): 100 \u2190 200 | Size: 2\nEnqueued: 300\nQueue (Front \u2192 Rear): 100 \u2190 200 \u2190 300 | Size: 3\n\n=== Linked List Queue Visualization ===\nFront \u2192 +---+ \u2192 +---+ \u2192 +---+ NULL\n       | 100 |     | 200 |     | 300 |\n       +---+     +---+     +---+\n\nNode Details:\n  Node 0: Data=100, Address=0x55f1a3a6deb0, Next=0x55f1a3a6de90 [FRONT]\n  Node 1: Data=200, Address=0x55f1a3a6de90, Next=0x55f1a3a6de70\n  Node 2: Data=300, Address=0x55f1a3a6de70, Next=0 [REAR]\nSize: 3\n======================================\nFront element: 100\nRear element: 300\nDequeued: 100\nQueue (Front \u2192 Rear): 200 \u2190 300 | Size: 2\nDequeued: 200\nQueue (Front \u2192 Rear): 300 | Size: 1\n\nCurrent size: 1\nEnqueued: 400\nQueue (Front \u2192 Rear): 300 \u2190 400 | Size: 2\nEnqueued: 500\nQueue (Front \u2192 Rear): 300 \u2190 400 \u2190 500 | Size: 3\nEnqueued: 600\nQueue (Front \u2192 Rear): 300 \u2190 400 \u2190 500 \u2190 600 | Size: 4\n\n=== Linked List Queue Visualization ===\nFront \u2192 +---+ \u2192 +---+ \u2192 +---+ \u2192 +---+ NULL\n       | 300 |     | 400 |     | 500 |     | 600 |\n       +---+     +---+     +---+     +---+\n\nNode Details:\n  Node 0: Data=300, Address=0x55f1a3a6de70, Next=0x55f1a3a6ded0 [FRONT]\n  Node 1: Data=400, Address=0x55f1a3a6ded0, Next=0x55f1a3a6def0\n  Node 2: Data=500, Address=0x55f1a3a6def0, Next=0x55f1a3a6df10\n  Node 3: Data=600, Address=0x55f1a3a6df10, Next=0 [REAR]\nSize: 4\n======================================\n\nCleaning up queue...\nDequeued: 300\nQueue (Front \u2192 Rear): 400 \u2190 500 \u2190 600 | Size: 3\nDequeued: 400\nQueue (Front \u2192 Rear): 500 \u2190 600 | Size: 2\nDequeued: 500\nQueue (Front \u2192 Rear): 600 | Size: 1\nDequeued: 600\nQueue: [Empty]\n"})}),"\n",(0,i.jsx)(e.h3,{id:"6-queue-applications-and-use-cases",children:"6. Queue Applications and Use Cases"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <queue>\n#include <string>\n#include <chrono>\n#include <thread>\n#include <random>\nusing namespace std;\n\nclass QueueApplications {\npublic:\n    // 1. Breadth-First Search (BFS) Simulation\n    static void demonstrateBFS() {\n        cout << "=== Breadth-First Search (BFS) Simulation ===" << endl;\n        \n        // Simple graph representation (adjacency list)\n        vector<vector<int>> graph = {\n            {1, 2},     // Node 0 connected to 1 and 2\n            {0, 3, 4},  // Node 1 connected to 0, 3, 4\n            {0, 5},     // Node 2 connected to 0, 5\n            {1},        // Node 3 connected to 1\n            {1, 5},     // Node 4 connected to 1, 5\n            {2, 4}      // Node 5 connected to 2, 4\n        };\n        \n        int startNode = 0;\n        vector<bool> visited(6, false);\n        queue<int> q;\n        \n        cout << "Graph with 6 nodes" << endl;\n        cout << "Starting BFS from node " << startNode << endl << endl;\n        \n        // Start BFS\n        q.push(startNode);\n        visited[startNode] = true;\n        \n        int level = 0;\n        while(!q.empty()) {\n            int levelSize = q.size();\n            cout << "Level " << level++ << ": ";\n            \n            for(int i = 0; i < levelSize; i++) {\n                int currentNode = q.front();\n                q.pop();\n                \n                cout << currentNode << " ";\n                \n                // Visit all neighbors\n                for(int neighbor : graph[currentNode]) {\n                    if(!visited[neighbor]) {\n                        visited[neighbor] = true;\n                        q.push(neighbor);\n                    }\n                }\n            }\n            cout << endl;\n        }\n        \n        cout << "\\nBFS Traversal Complete!" << endl;\n    }\n    \n    // 2. Print Server Simulation\n    static void demonstratePrintServer() {\n        cout << "\\n\\n=== Print Server Simulation ===" << endl;\n        \n        struct PrintJob {\n            int jobId;\n            string documentName;\n            int pages;\n            \n            void display() const {\n                cout << "Job " << jobId << ": \'" << documentName \n                     << "\' (" << pages << " pages)";\n            }\n        };\n        \n        queue<PrintJob> printQueue;\n        int jobCounter = 1;\n        \n        auto addPrintJob = [&](const string& docName, int pages) {\n            PrintJob job{jobCounter++, docName, pages};\n            printQueue.push(job);\n            cout << "Added: ";\n            job.display();\n            cout << endl;\n        };\n        \n        auto processPrintJob = [&]() {\n            if(printQueue.empty()) {\n                cout << "No jobs to process" << endl;\n                return;\n            }\n            \n            PrintJob job = printQueue.front();\n            printQueue.pop();\n            \n            cout << "Processing: ";\n            job.display();\n            cout << endl;\n            \n            // Simulate printing time\n            this_thread::sleep_for(chrono::milliseconds(500));\n            cout << "  \u2713 Completed!" << endl;\n        };\n        \n        auto showQueueStatus = [&]() {\n            cout << "\\nPrint Queue Status:" << endl;\n            if(printQueue.empty()) {\n                cout << "  Queue is empty" << endl;\n            } else {\n                cout << "  Jobs in queue: " << printQueue.size() << endl;\n                queue<PrintJob> temp = printQueue;\n                int position = 1;\n                while(!temp.empty()) {\n                    cout << "  " << position++ << ". ";\n                    temp.front().display();\n                    cout << endl;\n                    temp.pop();\n                }\n            }\n        };\n        \n        // Simulate print server operations\n        addPrintJob("Report.pdf", 10);\n        addPrintJob("Presentation.pptx", 15);\n        addPrintJob("Invoice.doc", 3);\n        \n        showQueueStatus();\n        \n        cout << "\\n--- Processing Jobs ---" << endl;\n        processPrintJob();\n        processPrintJob();\n        \n        addPrintJob("Letter.txt", 2);\n        \n        showQueueStatus();\n        \n        cout << "\\n--- Processing Remaining Jobs ---" << endl;\n        while(!printQueue.empty()) {\n            processPrintJob();\n        }\n        \n        showQueueStatus();\n    }\n    \n    // 3. Call Center Simulation\n    static void demonstrateCallCenter() {\n        cout << "\\n\\n=== Call Center Simulation ===" << endl;\n        \n        queue<pair<int, string>> callQueue;  // {callId, callerName}\n        int callId = 1;\n        int agents = 2;\n        \n        random_device rd;\n        mt19937 gen(rd());\n        uniform_int_distribution<> callDist(1, 5);  // Calls arrive every 1-5 seconds\n        uniform_int_distribution<> serviceDist(3, 8); // Service takes 3-8 seconds\n        \n        auto newCall = [&](const string& caller) {\n            callQueue.push({callId++, caller});\n            cout << "\ud83d\udcde New call from: " << caller << " (ID: " << (callId-1) \n                 << "), Queue position: " << callQueue.size() << endl;\n        };\n        \n        auto takeCall = [&](int agentId) {\n            if(callQueue.empty()) {\n                cout << "Agent " << agentId << ": No calls waiting" << endl;\n                return;\n            }\n            \n            auto call = callQueue.front();\n            callQueue.pop();\n            \n            cout << "Agent " << agentId << ": Taking call from " << call.second \n                 << " (ID: " << call.first << ")" << endl;\n            \n            // Simulate call duration\n            int duration = serviceDist(gen);\n            this_thread::sleep_for(chrono::milliseconds(duration * 100));\n            \n            cout << "Agent " << agentId << ": Completed call with " << call.second \n                 << " (" << duration << " seconds)" << endl;\n        };\n        \n        // Simulate call center operations\n        cout << "Call center with " << agents << " agents opening..." << endl;\n        \n        // Initial calls\n        newCall("Alice");\n        newCall("Bob");\n        newCall("Charlie");\n        \n        // Process calls\n        for(int i = 0; i < 10; i++) {\n            cout << "\\n--- Time: " << i << " seconds ---" << endl;\n            \n            // Random new calls\n            if(callDist(gen) <= 2) {  // 40% chance of new call\n                vector<string> names = {"David", "Eve", "Frank", "Grace", "Henry"};\n                newCall(names[callDist(gen) % names.size()]);\n            }\n            \n            // Agents take calls\n            for(int agent = 1; agent <= agents; agent++) {\n                takeCall(agent);\n            }\n            \n            // Show queue status\n            if(!callQueue.empty()) {\n                cout << "Calls waiting: " << callQueue.size() << endl;\n            }\n            \n            this_thread::sleep_for(chrono::milliseconds(500));\n        }\n        \n        cout << "\\nCall center closing..." << endl;\n        cout << "Remaining calls in queue: " << callQueue.size() << endl;\n    }\n    \n    // 4. CPU Task Scheduling (Round Robin)\n    static void demonstrateTaskScheduling() {\n        cout << "\\n\\n=== CPU Task Scheduling (Round Robin) ===" << endl;\n        \n        struct Task {\n            int id;\n            string name;\n            int burstTime;  // CPU time needed\n            int remainingTime;\n            \n            Task(int i, string n, int bt) \n                : id(i), name(n), burstTime(bt), remainingTime(bt) {}\n            \n            void display() const {\n                cout << "Task " << id << " (\'" << name << "\'): " \n                     << remainingTime << "/" << burstTime << " ms remaining";\n            }\n        };\n        \n        queue<Task> taskQueue;\n        int timeQuantum = 4;  // ms per time slice\n        \n        // Create tasks\n        vector<Task> tasks = {\n            {1, "System Update", 10},\n            {2, "User Process", 8},\n            {3, "Background Job", 6},\n            {4, "I/O Operation", 12},\n            {5, "Network Request", 7}\n        };\n        \n        // Add all tasks to queue\n        for(auto& task : tasks) {\n            taskQueue.push(task);\n            cout << "Added: ";\n            task.display();\n            cout << endl;\n        }\n        \n        cout << "\\nStarting Round Robin Scheduling (Time Quantum: " \n             << timeQuantum << "ms)" << endl;\n        cout << "==============================================" << endl;\n        \n        int currentTime = 0;\n        int completedTasks = 0;\n        \n        while(!taskQueue.empty()) {\n            Task currentTask = taskQueue.front();\n            taskQueue.pop();\n            \n            cout << "\\nTime " << currentTime << "ms: ";\n            currentTask.display();\n            cout << endl;\n            \n            // Execute for time quantum or remaining time, whichever is smaller\n            int executeTime = min(timeQuantum, currentTask.remainingTime);\n            currentTime += executeTime;\n            currentTask.remainingTime -= executeTime;\n            \n            cout << "  Executed for " << executeTime << "ms, ";\n            cout << "now at time " << currentTime << "ms" << endl;\n            \n            if(currentTask.remainingTime > 0) {\n                // Task not finished, put back in queue\n                taskQueue.push(currentTask);\n                cout << "  Task not finished, requeued" << endl;\n            } else {\n                // Task completed\n                completedTasks++;\n                cout << "  \u2713 Task completed! Total time: " << currentTask.burstTime << "ms" << endl;\n                cout << "  Completed tasks: " << completedTasks << "/" << tasks.size() << endl;\n            }\n            \n            // Show queue status\n            if(!taskQueue.empty()) {\n                cout << "  Tasks in queue: " << taskQueue.size() << endl;\n            }\n        }\n        \n        cout << "\\n==============================================" << endl;\n        cout << "All tasks completed in " << currentTime << "ms" << endl;\n        cout << "Average waiting time would be calculated based on scheduling" << endl;\n    }\n};\n\n// Main demonstration\nvoid demonstrateQueueApplications() {\n    cout << "=== Queue Applications and Use Cases ===" << endl;\n    \n    // 1. BFS Simulation\n    QueueApplications::demonstrateBFS();\n    \n    // 2. Print Server Simulation\n    QueueApplications::demonstratePrintServer();\n    \n    // 3. Call Center Simulation\n    QueueApplications::demonstrateCallCenter();\n    \n    // 4. Task Scheduling\n    QueueApplications::demonstrateTaskScheduling();\n}\n\nint main() {\n    demonstrateQueueApplications();\n    return 0;\n}\n'})}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Output:"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"=== Queue Applications and Use Cases ===\n=== Breadth-First Search (BFS) Simulation ===\nGraph with 6 nodes\nStarting BFS from node 0\n\nLevel 0: 0 \nLevel 1: 1 2 \nLevel 2: 3 4 5 \n\nBFS Traversal Complete!\n\n=== Print Server Simulation ===\nAdded: Job 1: 'Report.pdf' (10 pages)\nAdded: Job 2: 'Presentation.pptx' (15 pages)\nAdded: Job 3: 'Invoice.doc' (3 pages)\n\nPrint Queue Status:\n  Jobs in queue: 3\n  1. Job 1: 'Report.pdf' (10 pages)\n  2. Job 2: 'Presentation.pptx' (15 pages)\n  3. Job 3: 'Invoice.doc' (3 pages)\n\n--- Processing Jobs ---\nProcessing: Job 1: 'Report.pdf' (10 pages)\n  \u2713 Completed!\nProcessing: Job 2: 'Presentation.pptx' (15 pages)\n  \u2713 Completed!\nAdded: Job 4: 'Letter.txt' (2 pages)\n\nPrint Queue Status:\n  Jobs in queue: 2\n  1. Job 3: 'Invoice.doc' (3 pages)\n  2. Job 4: 'Letter.txt' (2 pages)\n\n--- Processing Remaining Jobs ---\nProcessing: Job 3: 'Invoice.doc' (3 pages)\n  \u2713 Completed!\nProcessing: Job 4: 'Letter.txt' (2 pages)\n  \u2713 Completed!\n\nPrint Queue Status:\n  Queue is empty\n\n=== Call Center Simulation ===\nCall center with 2 agents opening...\n\ud83d\udcde New call from: Alice (ID: 1), Queue position: 1\n\ud83d\udcde New call from: Bob (ID: 2), Queue position: 2\n\ud83d\udcde New call from: Charlie (ID: 3), Queue position: 3\n\n--- Time: 0 seconds ---\nAgent 1: Taking call from Alice (ID: 1)\nAgent 2: Taking call from Bob (ID: 2)\n\n--- Time: 1 seconds ---\nAgent 1: Completed call with Alice (5 seconds)\nAgent 1: Taking call from Charlie (ID: 3)\nAgent 2: Completed call with Bob (6 seconds)\nAgent 2: No calls waiting\n... (simulation continues) ...\n\nCall center closing...\nRemaining calls in queue: 1\n\n=== CPU Task Scheduling (Round Robin) ===\nAdded: Task 1 ('System Update'): 10/10 ms remaining\nAdded: Task 2 ('User Process'): 8/8 ms remaining\nAdded: Task 3 ('Background Job'): 6/6 ms remaining\nAdded: Task 4 ('I/O Operation'): 12/12 ms remaining\nAdded: Task 5 ('Network Request'): 7/7 ms remaining\n\nStarting Round Robin Scheduling (Time Quantum: 4ms)\n==============================================\n\nTime 0ms: Task 1 ('System Update'): 10/10 ms remaining\n  Executed for 4ms, now at time 4ms\n  Task not finished, requeued\n  Tasks in queue: 4\n\nTime 4ms: Task 2 ('User Process'): 8/8 ms remaining\n  Executed for 4ms, now at time 8ms\n  Task not finished, requeued\n  Tasks in queue: 4\n... (scheduling continues) ...\n==============================================\nAll tasks completed in 43ms\nAverage waiting time would be calculated based on scheduling\n"})}),"\n",(0,i.jsx)(e.h2,{id:"comparison-stack-vs-queue-implementations",children:"Comparison: Stack vs Queue Implementations"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <chrono>\n#include <iomanip>\nusing namespace std;\nusing namespace chrono;\n\nclass PerformanceComparison {\npublic:\n    static void compareStackImplementations(int n) {\n        cout << "\\n" << string(70, \'=\') << endl;\n        cout << "Performance Comparison: Stack Implementations (n = " << n << ")" << endl;\n        cout << string(70, \'=\') << endl;\n        \n        // 1. STL Stack\n        cout << "\\n1. STL Stack (deque by default):" << endl;\n        stack<int> stlStack;\n        \n        auto start = high_resolution_clock::now();\n        for(int i = 0; i < n; i++) {\n            stlStack.push(i);\n        }\n        auto end = high_resolution_clock::now();\n        auto stlPushTime = duration_cast<microseconds>(end - start).count();\n        \n        start = high_resolution_clock::now();\n        for(int i = 0; i < n; i++) {\n            stlStack.pop();\n        }\n        end = high_resolution_clock::now();\n        auto stlPopTime = duration_cast<microseconds>(end - start).count();\n        \n        // 2. Array-based Stack\n        cout << "\\n2. Custom Array-based Stack:" << endl;\n        vector<int> arrayStack;\n        arrayStack.reserve(n);\n        \n        start = high_resolution_clock::now();\n        for(int i = 0; i < n; i++) {\n            arrayStack.push_back(i);\n        }\n        end = high_resolution_clock::now();\n        auto arrayPushTime = duration_cast<microseconds>(end - start).count();\n        \n        start = high_resolution_clock::now();\n        for(int i = 0; i < n; i++) {\n            arrayStack.pop_back();\n        }\n        end = high_resolution_clock::now();\n        auto arrayPopTime = duration_cast<microseconds>(end - start).count();\n        \n        // 3. Linked List-based Stack\n        cout << "\\n3. Custom Linked List-based Stack:" << endl;\n        struct Node {\n            int data;\n            Node* next;\n        };\n        \n        Node* linkedStack = nullptr;\n        \n        start = high_resolution_clock::now();\n        for(int i = 0; i < n; i++) {\n            Node* newNode = new Node{i, linkedStack};\n            linkedStack = newNode;\n        }\n        end = high_resolution_clock::now();\n        auto linkedPushTime = duration_cast<microseconds>(end - start).count();\n        \n        start = high_resolution_clock::now();\n        while(linkedStack != nullptr) {\n            Node* temp = linkedStack;\n            linkedStack = linkedStack->next;\n            delete temp;\n        }\n        end = high_resolution_clock::now();\n        auto linkedPopTime = duration_cast<microseconds>(end - start).count();\n        \n        // Display results\n        cout << fixed << setprecision(2);\n        cout << "\\n" << string(70, \'-\') << endl;\n        cout << setw(25) << "Implementation" \n             << setw(15) << "Push Time" \n             << setw(15) << "Pop Time" \n             << setw(15) << "Total Time" << endl;\n        cout << string(70, \'-\') << endl;\n        \n        cout << setw(25) << "STL Stack" \n             << setw(15) << stlPushTime << " \u03bcs"\n             << setw(15) << stlPopTime << " \u03bcs"\n             << setw(15) << (stlPushTime + stlPopTime) << " \u03bcs" << endl;\n        \n        cout << setw(25) << "Array-based Stack" \n             << setw(15) << arrayPushTime << " \u03bcs"\n             << setw(15) << arrayPopTime << " \u03bcs"\n             << setw(15) << (arrayPushTime + arrayPopTime) << " \u03bcs" << endl;\n        \n        cout << setw(25) << "Linked List Stack" \n             << setw(15) << linkedPushTime << " \u03bcs"\n             << setw(15) << linkedPopTime << " \u03bcs"\n             << setw(15) << (linkedPushTime + linkedPopTime) << " \u03bcs" << endl;\n        \n        cout << "\\nKey Observations:" << endl;\n        cout << "1. Array-based: Fastest for push/pop, contiguous memory" << endl;\n        cout << "2. Linked List: Dynamic size, no capacity limits" << endl;\n        cout << "3. STL Stack: Good balance, uses deque (double-ended queue)" << endl;\n    }\n    \n    static void compareQueueImplementations(int n) {\n        cout << "\\n\\n" << string(70, \'=\') << endl;\n        cout << "Performance Comparison: Queue Implementations (n = " << n << ")" << endl;\n        cout << string(70, \'=\') << endl;\n        \n        // 1. STL Queue\n        cout << "\\n1. STL Queue (deque by default):" << endl;\n        queue<int> stlQueue;\n        \n        auto start = high_resolution_clock::now();\n        for(int i = 0; i < n; i++) {\n            stlQueue.push(i);\n        }\n        auto end = high_resolution_clock::now();\n        auto stlEnqueueTime = duration_cast<microseconds>(end - start).count();\n        \n        start = high_resolution_clock::now();\n        for(int i = 0; i < n; i++) {\n            stlQueue.pop();\n        }\n        end = high_resolution_clock::now();\n        auto stlDequeueTime = duration_cast<microseconds>(end - start).count();\n        \n        // 2. Circular Queue\n        cout << "\\n2. Custom Circular Queue:" << endl;\n        vector<int> circularQueue(n);\n        int front = 0, rear = -1, size = 0;\n        \n        start = high_resolution_clock::now();\n        for(int i = 0; i < n; i++) {\n            rear = (rear + 1) % n;\n            circularQueue[rear] = i;\n            size++;\n        }\n        end = high_resolution_clock::now();\n        auto circularEnqueueTime = duration_cast<microseconds>(end - start).count();\n        \n        start = high_resolution_clock::now();\n        for(int i = 0; i < n; i++) {\n            front = (front + 1) % n;\n            size--;\n        }\n        end = high_resolution_clock::now();\n        auto circularDequeueTime = duration_cast<microseconds>(end - start).count();\n        \n        // Display results\n        cout << "\\n" << string(70, \'-\') << endl;\n        cout << setw(25) << "Implementation" \n             << setw(15) << "Enqueue Time" \n             << setw(15) << "Dequeue Time" \n             << setw(15) << "Total Time" << endl;\n        cout << string(70, \'-\') << endl;\n        \n        cout << setw(25) << "STL Queue" \n             << setw(15) << stlEnqueueTime << " \u03bcs"\n             << setw(15) << stlDequeueTime << " \u03bcs"\n             << setw(15) << (stlEnqueueTime + stlDequeueTime) << " \u03bcs" << endl;\n        \n        cout << setw(25) << "Circular Queue" \n             << setw(15) << circularEnqueueTime << " \u03bcs"\n             << setw(15) << circularDequeueTime << " \u03bcs"\n             << setw(15) << (circularEnqueueTime + circularDequeueTime) << " \u03bcs" << endl;\n        \n        cout << "\\nKey Observations:" << endl;\n        cout << "1. Circular Queue: Most efficient for fixed-size requirements" << endl;\n        cout << "2. STL Queue: Flexible, good for general use" << endl;\n        cout << "3. Linear Queue: Not shown (wastes space)" << endl;\n    }\n    \n    static void stackVsQueueComparison() {\n        cout << "\\n\\n" << string(70, \'=\') << endl;\n        cout << "Stack vs Queue: When to Use Which?" << endl;\n        cout << string(70, \'=\') << endl;\n        \n        cout << "\\nUse STACK when:" << endl;\n        cout << "1. Need LIFO behavior (last in, first out)" << endl;\n        cout << "2. Implementing undo/redo functionality" << endl;\n        cout << "3. Parsing expressions (postfix, infix)" << endl;\n        cout << "4. Depth-First Search (DFS) algorithms" << endl;\n        cout << "5. Function call management (call stack)" << endl;\n        cout << "6. Backtracking algorithms" << endl;\n        cout << "7. Syntax parsing (parentheses matching)" << endl;\n        \n        cout << "\\nUse QUEUE when:" << endl;\n        cout << "1. Need FIFO behavior (first in, first out)" << endl;\n        cout << "2. Implementing task scheduling" << endl;\n        cout << "3. Breadth-First Search (BFS) algorithms" << endl;\n        cout << "4. Print spooling or job scheduling" << endl;\n        cout << "5. Handling requests (web server, call center)" << endl;\n        cout << "6. Message passing between processes" << endl;\n        cout << "7. Simulating real-world queues" << endl;\n        \n        cout << "\\nCommon Implementations:" << endl;\n        cout << "Stack: Array, Linked List, Vector, Deque" << endl;\n        cout << "Queue: Circular Array, Linked List, Deque, Priority Queue" << endl;\n        \n        cout << "\\nTime Complexities (Average Case):" << endl;\n        cout << setw(20) << "Operation" << setw(15) << "Stack" << setw(15) << "Queue" << endl;\n        cout << string(50, \'-\') << endl;\n        cout << setw(20) << "Insert" << setw(15) << "O(1)" << setw(15) << "O(1)" << endl;\n        cout << setw(20) << "Delete" << setw(15) << "O(1)" << setw(15) << "O(1)" << endl;\n        cout << setw(20) << "Access Top/Front" << setw(15) << "O(1)" << setw(15) << "O(1)" << endl;\n        cout << setw(20) << "Search" << setw(15) << "O(n)" << setw(15) << "O(n)" << endl;\n        \n        cout << "\\nMemory Considerations:" << endl;\n        cout << "\u2022 Stack: Simpler, less overhead" << endl;\n        cout << "\u2022 Queue: May need circular implementation to avoid waste" << endl;\n        cout << "\u2022 Both: Dynamic versions have allocation overhead" << endl;\n    }\n};\n\nint main() {\n    int testSize = 10000;\n    \n    PerformanceComparison::compareStackImplementations(testSize);\n    PerformanceComparison::compareQueueImplementations(testSize);\n    PerformanceComparison::stackVsQueueComparison();\n    \n    return 0;\n}\n'})}),"\n",(0,i.jsx)(e.h2,{id:"stl-stack-and-queue",children:"STL Stack and Queue"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <list>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvoid demonstrateSTLContainers() {\n    cout << "=== STL Stack and Queue Containers ===" << endl;\n    \n    // 1. STL Stack with different underlying containers\n    cout << "\\n1. STL Stack with different containers:" << endl;\n    \n    // Default (uses deque)\n    stack<int> stack1;\n    cout << "Default stack (deque): ";\n    for(int i = 1; i <= 5; i++) stack1.push(i * 10);\n    while(!stack1.empty()) {\n        cout << stack1.top() << " ";\n        stack1.pop();\n    }\n    cout << endl;\n    \n    // Stack with vector\n    stack<int, vector<int>> stack2;\n    cout << "Stack with vector: ";\n    for(int i = 1; i <= 5; i++) stack2.push(i * 10);\n    while(!stack2.empty()) {\n        cout << stack2.top() << " ";\n        stack2.pop();\n    }\n    cout << endl;\n    \n    // Stack with list\n    stack<int, list<int>> stack3;\n    cout << "Stack with list: ";\n    for(int i = 1; i <= 5; i++) stack3.push(i * 10);\n    while(!stack3.empty()) {\n        cout << stack3.top() << " ";\n        stack3.pop();\n    }\n    cout << endl;\n    \n    // 2. STL Queue with different underlying containers\n    cout << "\\n2. STL Queue with different containers:" << endl;\n    \n    // Default (uses deque)\n    queue<int> queue1;\n    cout << "Default queue (deque): ";\n    for(int i = 1; i <= 5; i++) queue1.push(i * 10);\n    while(!queue1.empty()) {\n        cout << queue1.front() << " ";\n        queue1.pop();\n    }\n    cout << endl;\n    \n    // Queue with list\n    queue<int, list<int>> queue2;\n    cout << "Queue with list: ";\n    for(int i = 1; i <= 5; i++) queue2.push(i * 10);\n    while(!queue2.empty()) {\n        cout << queue2.front() << " ";\n        queue2.pop();\n    }\n    cout << endl;\n    \n    // 3. Deque (Double-ended queue) - versatile container\n    cout << "\\n3. Deque (Double-ended queue):" << endl;\n    deque<int> dq;\n    \n    // Add elements at both ends\n    dq.push_back(10);\n    dq.push_front(5);\n    dq.push_back(20);\n    dq.push_front(1);\n    \n    cout << "Deque contents: ";\n    for(int num : dq) {\n        cout << num << " ";\n    }\n    cout << endl;\n    \n    cout << "Front: " << dq.front() << ", Back: " << dq.back() << endl;\n    \n    // Remove from both ends\n    dq.pop_front();\n    dq.pop_back();\n    \n    cout << "After pop_front and pop_back: ";\n    for(int num : dq) {\n        cout << num << " ";\n    }\n    cout << endl;\n    \n    // 4. Priority Queue (Heap)\n    cout << "\\n4. Priority Queue (Max-Heap by default):" << endl;\n    priority_queue<int> pq;\n    \n    pq.push(30);\n    pq.push(10);\n    pq.push(50);\n    pq.push(20);\n    pq.push(40);\n    \n    cout << "Priority queue contents (max first): ";\n    while(!pq.empty()) {\n        cout << pq.top() << " ";\n        pq.pop();\n    }\n    cout << endl;\n    \n    // Min-Heap\n    cout << "Priority queue as min-heap: ";\n    priority_queue<int, vector<int>, greater<int>> minHeap;\n    \n    minHeap.push(30);\n    minHeap.push(10);\n    minHeap.push(50);\n    minHeap.push(20);\n    minHeap.push(40);\n    \n    while(!minHeap.empty()) {\n        cout << minHeap.top() << " ";\n        minHeap.pop();\n    }\n    cout << endl;\n    \n    // 5. Container Adapters Summary\n    cout << "\\n5. Container Adapters Summary:" << endl;\n    cout << "Stack: LIFO, adapts deque/vector/list" << endl;\n    cout << "Queue: FIFO, adapts deque/list" << endl;\n    cout << "Priority Queue: Sorted, adapts vector/deque" << endl;\n    cout << "Deque: Double-ended, base for stack/queue" << endl;\n    \n    cout << "\\nChoosing the right container:" << endl;\n    cout << "\u2022 Need LIFO? Use stack" << endl;\n    cout << "\u2022 Need FIFO? Use queue" << endl;\n    cout << "\u2022 Need sorted access? Use priority_queue" << endl;\n    cout << "\u2022 Need both ends? Use deque directly" << endl;\n    cout << "\u2022 Performance critical? Test with your data" << endl;\n}\n\n// Custom comparator for priority queue\nstruct Task {\n    string name;\n    int priority;\n    int duration;\n    \n    Task(string n, int p, int d) : name(n), priority(p), duration(d) {}\n    \n    // For max-heap based on priority\n    bool operator<(const Task& other) const {\n        return priority < other.priority;\n    }\n    \n    // For min-heap based on priority\n    bool operator>(const Task& other) const {\n        return priority > other.priority;\n    }\n};\n\nvoid demonstrateCustomPriorityQueue() {\n    cout << "\\n\\n=== Custom Objects in Priority Queue ===" << endl;\n    \n    // Max-heap (highest priority first)\n    priority_queue<Task> taskQueue;\n    \n    taskQueue.push(Task("System Update", 1, 10));\n    taskQueue.push(Task("User Request", 3, 5));\n    taskQueue.push(Task("Critical Bug Fix", 5, 8));\n    taskQueue.push(Task("Background Job", 2, 15));\n    taskQueue.push(Task("Security Patch", 4, 6));\n    \n    cout << "Processing tasks by priority (highest first):" << endl;\n    while(!taskQueue.empty()) {\n        Task task = taskQueue.top();\n        taskQueue.pop();\n        cout << "  \u2022 " << task.name << " (Priority: " << task.priority \n             << ", Duration: " << task.duration << "min)" << endl;\n    }\n    \n    // Min-heap (lowest priority first)\n    cout << "\\nProcessing tasks by priority (lowest first):" << endl;\n    priority_queue<Task, vector<Task>, greater<Task>> minPriorityQueue;\n    \n    minPriorityQueue.push(Task("System Update", 1, 10));\n    minPriorityQueue.push(Task("User Request", 3, 5));\n    minPriorityQueue.push(Task("Critical Bug Fix", 5, 8));\n    \n    while(!minPriorityQueue.empty()) {\n        Task task = minPriorityQueue.top();\n        minPriorityQueue.pop();\n        cout << "  \u2022 " << task.name << " (Priority: " << task.priority \n             << ", Duration: " << task.duration << "min)" << endl;\n    }\n}\n\nint main() {\n    demonstrateSTLContainers();\n    demonstrateCustomPriorityQueue();\n    return 0;\n}\n'})}),"\n",(0,i.jsx)(e.h2,{id:"common-interview-questions",children:"Common Interview Questions"}),"\n",(0,i.jsx)(e.h3,{id:"1-implement-stack-using-queues",children:"1. Implement Stack using Queues"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <queue>\nusing namespace std;\n\nclass StackUsingQueues {\nprivate:\n    queue<int> q1;\n    queue<int> q2;\n    \npublic:\n    // Push operation - O(1)\n    void push(int x) {\n        q1.push(x);\n        cout << "Pushed: " << x << endl;\n    }\n    \n    // Pop operation - O(n)\n    int pop() {\n        if(q1.empty()) {\n            throw runtime_error("Stack is empty!");\n        }\n        \n        // Move all elements except last from q1 to q2\n        while(q1.size() > 1) {\n            q2.push(q1.front());\n            q1.pop();\n        }\n        \n        // Last element is the top\n        int topValue = q1.front();\n        q1.pop();\n        \n        // Swap q1 and q2\n        swap(q1, q2);\n        \n        cout << "Popped: " << topValue << endl;\n        return topValue;\n    }\n    \n    // Top operation - O(n)\n    int top() {\n        if(q1.empty()) {\n            throw runtime_error("Stack is empty!");\n        }\n        \n        // Move all elements except last from q1 to q2\n        while(q1.size() > 1) {\n            q2.push(q1.front());\n            q1.pop();\n        }\n        \n        // Last element is the top\n        int topValue = q1.front();\n        q2.push(topValue);\n        q1.pop();\n        \n        // Swap q1 and q2\n        swap(q1, q2);\n        \n        cout << "Top: " << topValue << endl;\n        return topValue;\n    }\n    \n    bool empty() {\n        return q1.empty();\n    }\n    \n    void display() {\n        cout << "Stack (top to bottom): ";\n        queue<int> temp = q1;\n        vector<int> elements;\n        \n        while(!temp.empty()) {\n            elements.push_back(temp.front());\n            temp.pop();\n        }\n        \n        // Display in reverse (top first)\n        for(int i = elements.size() - 1; i >= 0; i--) {\n            cout << elements[i];\n            if(i > 0) cout << " \u2192 ";\n        }\n        cout << endl;\n    }\n};\n\nvoid demonstrateStackUsingQueues() {\n    cout << "=== Implementing Stack using Two Queues ===" << endl;\n    \n    StackUsingQueues stack;\n    \n    stack.push(10);\n    stack.push(20);\n    stack.push(30);\n    \n    stack.display();\n    \n    stack.top();\n    stack.pop();\n    \n    stack.display();\n    \n    stack.push(40);\n    stack.push(50);\n    \n    stack.display();\n    \n    while(!stack.empty()) {\n        stack.pop();\n    }\n}\n'})}),"\n",(0,i.jsx)(e.h3,{id:"2-implement-queue-using-stacks",children:"2. Implement Queue using Stacks"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <stack>\nusing namespace std;\n\nclass QueueUsingStacks {\nprivate:\n    stack<int> s1;  // For enqueue\n    stack<int> s2;  // For dequeue\n    \n    // Transfer elements from s1 to s2 when s2 is empty\n    void transferIfNeeded() {\n        if(s2.empty()) {\n            while(!s1.empty()) {\n                s2.push(s1.top());\n                s1.pop();\n            }\n        }\n    }\n    \npublic:\n    // Enqueue operation - O(1)\n    void enqueue(int x) {\n        s1.push(x);\n        cout << "Enqueued: " << x << endl;\n    }\n    \n    // Dequeue operation - Amortized O(1)\n    int dequeue() {\n        if(empty()) {\n            throw runtime_error("Queue is empty!");\n        }\n        \n        transferIfNeeded();\n        \n        int frontValue = s2.top();\n        s2.pop();\n        \n        cout << "Dequeued: " << frontValue << endl;\n        return frontValue;\n    }\n    \n    // Front operation - Amortized O(1)\n    int front() {\n        if(empty()) {\n            throw runtime_error("Queue is empty!");\n        }\n        \n        transferIfNeeded();\n        \n        int frontValue = s2.top();\n        cout << "Front: " << frontValue << endl;\n        return frontValue;\n    }\n    \n    bool empty() {\n        return s1.empty() && s2.empty();\n    }\n    \n    void display() {\n        cout << "Queue (front to rear): ";\n        \n        // First show elements in s2 (front elements)\n        stack<int> temp = s2;\n        vector<int> elements;\n        \n        while(!temp.empty()) {\n            elements.push_back(temp.top());\n            temp.pop();\n        }\n        \n        // s2 elements are in reverse order in the stack\n        for(int i = elements.size() - 1; i >= 0; i--) {\n            cout << elements[i] << " \u2190 ";\n        }\n        \n        // Then show elements in s1 (rear elements)\n        temp = s1;\n        elements.clear();\n        \n        while(!temp.empty()) {\n            elements.push_back(temp.top());\n            temp.pop();\n        }\n        \n        // s1 elements are already in correct order\n        for(int i = 0; i < elements.size(); i++) {\n            cout << elements[i];\n            if(i < elements.size() - 1) cout << " \u2190 ";\n        }\n        \n        cout << endl;\n    }\n};\n\nvoid demonstrateQueueUsingStacks() {\n    cout << "\\n\\n=== Implementing Queue using Two Stacks ===" << endl;\n    \n    QueueUsingStacks queue;\n    \n    queue.enqueue(10);\n    queue.enqueue(20);\n    queue.enqueue(30);\n    \n    queue.display();\n    \n    queue.front();\n    queue.dequeue();\n    \n    queue.display();\n    \n    queue.enqueue(40);\n    queue.enqueue(50);\n    \n    queue.display();\n    \n    while(!queue.empty()) {\n        queue.dequeue();\n    }\n}\n'})}),"\n",(0,i.jsx)(e.h3,{id:"3-next-greater-element",children:"3. Next Greater Element"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <stack>\n#include <vector>\nusing namespace std;\n\nvector<int> nextGreaterElement(const vector<int>& arr) {\n    int n = arr.size();\n    vector<int> result(n, -1);\n    stack<int> s;\n    \n    cout << "Finding Next Greater Element for each element:" << endl;\n    cout << "Array: ";\n    for(int num : arr) cout << num << " ";\n    cout << endl << endl;\n    \n    for(int i = 0; i < n; i++) {\n        cout << "Processing arr[" << i << "] = " << arr[i] << endl;\n        \n        while(!s.empty() && arr[s.top()] < arr[i]) {\n            int idx = s.top();\n            s.pop();\n            result[idx] = arr[i];\n            cout << "  arr[" << idx << "] = " << arr[idx] \n                 << " \u2192 NGE = " << arr[i] << endl;\n        }\n        \n        s.push(i);\n        cout << "  Pushed index " << i << " to stack" << endl;\n    }\n    \n    cout << "\\nRemaining elements in stack have no NGE" << endl;\n    \n    cout << "\\nResult: ";\n    for(int num : result) cout << num << " ";\n    cout << endl;\n    \n    return result;\n}\n\nvoid demonstrateNextGreaterElement() {\n    cout << "\\n\\n=== Next Greater Element Problem ===" << endl;\n    \n    vector<int> arr = {4, 5, 2, 10, 8};\n    vector<int> result = nextGreaterElement(arr);\n}\n'})}),"\n",(0,i.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,i.jsx)(e.h3,{id:"stacks-summary",children:"Stacks Summary:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Principle"}),": LIFO (Last-In-First-Out)"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Operations"}),": push(), pop(), peek(), isEmpty(), size()"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Implementations"}),": Array, Linked List, Vector, Deque"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Time Complexity"}),": O(1) for all operations"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Applications"}),":","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Function call stack"}),"\n",(0,i.jsx)(e.li,{children:"Expression evaluation"}),"\n",(0,i.jsx)(e.li,{children:"Undo/Redo operations"}),"\n",(0,i.jsx)(e.li,{children:"Parentheses matching"}),"\n",(0,i.jsx)(e.li,{children:"Backtracking algorithms"}),"\n",(0,i.jsx)(e.li,{children:"Depth-First Search"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"queues-summary",children:"Queues Summary:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Principle"}),": FIFO (First-In-First-Out)"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Operations"}),": enqueue(), dequeue(), front(), rear(), isEmpty(), size()"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Implementations"}),":","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Linear Queue (wastes space)"}),"\n",(0,i.jsx)(e.li,{children:"Circular Queue (efficient)"}),"\n",(0,i.jsx)(e.li,{children:"Linked List Queue (dynamic)"}),"\n",(0,i.jsx)(e.li,{children:"Priority Queue (sorted)"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Time Complexity"}),": O(1) for all operations (amortized for some)"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Applications"}),":","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Task scheduling"}),"\n",(0,i.jsx)(e.li,{children:"Breadth-First Search"}),"\n",(0,i.jsx)(e.li,{children:"Print spooling"}),"\n",(0,i.jsx)(e.li,{children:"Message queues"}),"\n",(0,i.jsx)(e.li,{children:"Call center systems"}),"\n",(0,i.jsx)(e.li,{children:"CPU scheduling"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"key-differences",children:"Key Differences:"}),"\n",(0,i.jsxs)(e.table,{children:[(0,i.jsx)(e.thead,{children:(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.th,{children:"Aspect"}),(0,i.jsx)(e.th,{children:"Stack"}),(0,i.jsx)(e.th,{children:"Queue"})]})}),(0,i.jsxs)(e.tbody,{children:[(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:(0,i.jsx)(e.strong,{children:"Order"})}),(0,i.jsx)(e.td,{children:"LIFO"}),(0,i.jsx)(e.td,{children:"FIFO"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:(0,i.jsx)(e.strong,{children:"Insertion"})}),(0,i.jsx)(e.td,{children:"Always at top"}),(0,i.jsx)(e.td,{children:"Always at rear"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:(0,i.jsx)(e.strong,{children:"Removal"})}),(0,i.jsx)(e.td,{children:"Always from top"}),(0,i.jsx)(e.td,{children:"Always from front"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:(0,i.jsx)(e.strong,{children:"Access"})}),(0,i.jsx)(e.td,{children:"Only top element"}),(0,i.jsx)(e.td,{children:"Only front element"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:(0,i.jsx)(e.strong,{children:"Use Case"})}),(0,i.jsx)(e.td,{children:"Depth processing"}),(0,i.jsx)(e.td,{children:"Breadth processing"})]})]})]}),"\n",(0,i.jsx)(e.h3,{id:"when-to-choose",children:"When to Choose:"}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Choose Stack when:"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"You need to process items in reverse order"}),"\n",(0,i.jsx)(e.li,{children:"Implementing recursive algorithms iteratively"}),"\n",(0,i.jsx)(e.li,{children:"Parsing nested structures (HTML/XML, expressions)"}),"\n",(0,i.jsx)(e.li,{children:"Need backtracking capability"}),"\n",(0,i.jsx)(e.li,{children:"Memory management (call stack)"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Choose Queue when:"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"You need to process items in arrival order"}),"\n",(0,i.jsx)(e.li,{children:"Implementing BFS algorithms"}),"\n",(0,i.jsx)(e.li,{children:"Handling requests/tasks in order"}),"\n",(0,i.jsx)(e.li,{children:"Buffer management"}),"\n",(0,i.jsx)(e.li,{children:"Simulating real-world queues"}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"best-practices",children:"Best Practices:"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Use STL containers"})," (",(0,i.jsx)(e.code,{children:"stack"}),", ",(0,i.jsx)(e.code,{children:"queue"}),", ",(0,i.jsx)(e.code,{children:"priority_queue"}),") when possible"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Choose implementation based on needs"}),":","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Fixed size \u2192 Array/Circular Queue"}),"\n",(0,i.jsx)(e.li,{children:"Dynamic size \u2192 Linked List"}),"\n",(0,i.jsx)(e.li,{children:"Need both ends \u2192 Deque"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Consider memory locality"}),": Arrays have better cache performance"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Watch for edge cases"}),": Empty stack/queue operations"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Thread safety"}),": Consider synchronization for concurrent access"]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"common-pitfalls",children:"Common Pitfalls:"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Stack overflow/underflow"}),": Always check bounds"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Queue waste"}),": Use circular implementation for arrays"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Memory leaks"}),": Clean up dynamically allocated nodes"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Iterator invalidation"}),": Be careful with references/pointers"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Concurrent modification"}),": Use proper synchronization"]}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"Stacks and Queues are fundamental building blocks in computer science. Mastering them is essential for understanding more complex data structures and algorithms. They demonstrate elegant solutions to many real-world problems through simple, well-defined operations."}),"\n",(0,i.jsx)(e.hr,{})]})}function d(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(l,{...n})}):l(n)}},8453(n,e,t){t.d(e,{R:()=>o,x:()=>u});var i=t(6540);const r={},s=i.createContext(r);function o(n){const e=i.useContext(s);return i.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function u(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:o(n.components),i.createElement(s.Provider,{value:e},n.children)}}}]);