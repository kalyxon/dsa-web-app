{"allContent":{"docusaurus-plugin-content-docs":{"default":{"loadedVersions":[{"versionName":"current","label":"Next","banner":null,"badge":false,"noIndex":false,"className":"docs-version-current","path":"/markdown-web-app/","tagsPath":"/markdown-web-app/tags","editUrl":"https://github.com/kalyxon/markdown-web-app/tree/main/docs","editUrlLocalized":"https://github.com/kalyxon/markdown-web-app/tree/main/i18n/en/docusaurus-plugin-content-docs/current","isLast":true,"routePriority":-1,"sidebarFilePath":"/home/maya/markdown-web-app/sidebars.js","contentPath":"/home/maya/markdown-web-app/docs","contentPathLocalized":"/home/maya/markdown-web-app/i18n/en/docusaurus-plugin-content-docs/current","docs":[{"id":"arrays","title":"Arrays","description":"Arrays in C++","source":"@site/docs/arrays.md","sourceDirName":".","slug":"/arrays","permalink":"/markdown-web-app/arrays","draft":false,"unlisted":false,"editUrl":"https://github.com/kalyxon/markdown-web-app/tree/main/docs/arrays.md","tags":[],"version":"current","frontMatter":{"id":"arrays","title":"Arrays"},"sidebar":"dsa","previous":{"title":"Intro","permalink":"/markdown-web-app/intro"},"next":{"title":"Linked list","permalink":"/markdown-web-app/linked-list"}},{"id":"exercises","title":"Exercises","description":"Euclidean Algorithm","source":"@site/docs/exercises.md","sourceDirName":".","slug":"/exercises","permalink":"/markdown-web-app/exercises","draft":false,"unlisted":false,"editUrl":"https://github.com/kalyxon/markdown-web-app/tree/main/docs/exercises.md","tags":[],"version":"current","frontMatter":{"id":"exercises","title":"Exercises"},"sidebar":"dsa","previous":{"title":"Shortest Path","permalink":"/markdown-web-app/shortest-path"}},{"id":"graphs","title":"Graphs","description":"Introduction to Graphs","source":"@site/docs/graphs.md","sourceDirName":".","slug":"/graphs","permalink":"/markdown-web-app/graphs","draft":false,"unlisted":false,"editUrl":"https://github.com/kalyxon/markdown-web-app/tree/main/docs/graphs.md","tags":[],"version":"current","frontMatter":{"id":"graphs","title":"Graphs"},"sidebar":"dsa","previous":{"title":"Trees","permalink":"/markdown-web-app/trees"},"next":{"title":"Time Complexity","permalink":"/markdown-web-app/time-complexity"}},{"id":"hash-tables","title":"Hash Tables","description":"Introduction to Hash Tables","source":"@site/docs/hash-tables.md","sourceDirName":".","slug":"/hash-tables","permalink":"/markdown-web-app/hash-tables","draft":false,"unlisted":false,"editUrl":"https://github.com/kalyxon/markdown-web-app/tree/main/docs/hash-tables.md","tags":[],"version":"current","frontMatter":{"id":"hash-tables","title":"Hash Tables"},"sidebar":"dsa","previous":{"title":"Stacks Queues","permalink":"/markdown-web-app/stacks-queues"},"next":{"title":"Trees","permalink":"/markdown-web-app/trees"}},{"id":"intro","title":"Intro","description":"Welcome to Kalyxon's focused DSA learning hub.","source":"@site/docs/intro.md","sourceDirName":".","slug":"/intro","permalink":"/markdown-web-app/intro","draft":false,"unlisted":false,"editUrl":"https://github.com/kalyxon/markdown-web-app/tree/main/docs/intro.md","tags":[],"version":"current","frontMatter":{"id":"intro","title":"Intro"},"sidebar":"dsa","next":{"title":"Arrays","permalink":"/markdown-web-app/arrays"}},{"id":"linked-list","title":"Linked list","description":"Introduction to Linked Lists","source":"@site/docs/linked-list.md","sourceDirName":".","slug":"/linked-list","permalink":"/markdown-web-app/linked-list","draft":false,"unlisted":false,"editUrl":"https://github.com/kalyxon/markdown-web-app/tree/main/docs/linked-list.md","tags":[],"version":"current","frontMatter":{"id":"linked-list","title":"Linked list"},"sidebar":"dsa","previous":{"title":"Arrays","permalink":"/markdown-web-app/arrays"},"next":{"title":"Stacks Queues","permalink":"/markdown-web-app/stacks-queues"}},{"id":"maximum-flow","title":"Maximum Flow","description":"Maximum Flow is a fundamental problem in network theory that involves finding the maximum amount of flow that can be sent from a source node to a sink node in a flow network. A flow network is a directed graph where each edge has a capacity (maximum amount of flow it can carry) and actual flow (amount currently passing through).","source":"@site/docs/maximum-flow.md","sourceDirName":".","slug":"/maximum-flow","permalink":"/markdown-web-app/maximum-flow","draft":false,"unlisted":false,"editUrl":"https://github.com/kalyxon/markdown-web-app/tree/main/docs/maximum-flow.md","tags":[],"version":"current","frontMatter":{"id":"maximum-flow","title":"Maximum Flow"},"sidebar":"dsa","previous":{"title":"Minimum Spanning Tree","permalink":"/markdown-web-app/minimum-spanning-tree"},"next":{"title":"Shortest Path","permalink":"/markdown-web-app/shortest-path"}},{"id":"minimum-spanning-tree","title":"Minimum Spanning Tree","description":"A Minimum Spanning Tree (MST) is a subset of edges of a connected, edge-weighted undirected graph that connects all the vertices together without any cycles and with the minimum possible total edge weight. In simpler terms, it's the most efficient way to connect all points (vertices) in a network with the least total cost (edge weights).","source":"@site/docs/minimum-spanning-tree.md","sourceDirName":".","slug":"/minimum-spanning-tree","permalink":"/markdown-web-app/minimum-spanning-tree","draft":false,"unlisted":false,"editUrl":"https://github.com/kalyxon/markdown-web-app/tree/main/docs/minimum-spanning-tree.md","tags":[],"version":"current","frontMatter":{"id":"minimum-spanning-tree","title":"Minimum Spanning Tree"},"sidebar":"dsa","previous":{"title":"Time Complexity","permalink":"/markdown-web-app/time-complexity"},"next":{"title":"Maximum Flow","permalink":"/markdown-web-app/maximum-flow"}},{"id":"shortest-path","title":"Shortest Path","description":"Introduction to Shortest Path Problems","source":"@site/docs/shortest-path.md","sourceDirName":".","slug":"/shortest-path","permalink":"/markdown-web-app/shortest-path","draft":false,"unlisted":false,"editUrl":"https://github.com/kalyxon/markdown-web-app/tree/main/docs/shortest-path.md","tags":[],"version":"current","frontMatter":{"id":"shortest-path","title":"Shortest Path"},"sidebar":"dsa","previous":{"title":"Maximum Flow","permalink":"/markdown-web-app/maximum-flow"},"next":{"title":"Exercises","permalink":"/markdown-web-app/exercises"}},{"id":"stacks-queues","title":"Stacks Queues","description":"Introduction to Stacks & Queues","source":"@site/docs/stacks-queues.md","sourceDirName":".","slug":"/stacks-queues","permalink":"/markdown-web-app/stacks-queues","draft":false,"unlisted":false,"editUrl":"https://github.com/kalyxon/markdown-web-app/tree/main/docs/stacks-queues.md","tags":[],"version":"current","frontMatter":{"id":"stacks-queues","title":"Stacks Queues"},"sidebar":"dsa","previous":{"title":"Linked list","permalink":"/markdown-web-app/linked-list"},"next":{"title":"Hash Tables","permalink":"/markdown-web-app/hash-tables"}},{"id":"time-complexity","title":"Time Complexity","description":"Time Complexity is a fundamental concept in computer science that describes the amount of computational time an algorithm takes to run as a function of the input size. It provides a theoretical estimate of the time required for an algorithm to complete, helping us understand and compare the efficiency of different algorithms.","source":"@site/docs/time-complexity.md","sourceDirName":".","slug":"/time-complexity","permalink":"/markdown-web-app/time-complexity","draft":false,"unlisted":false,"editUrl":"https://github.com/kalyxon/markdown-web-app/tree/main/docs/time-complexity.md","tags":[],"version":"current","frontMatter":{"id":"time-complexity","title":"Time Complexity"},"sidebar":"dsa","previous":{"title":"Graphs","permalink":"/markdown-web-app/graphs"},"next":{"title":"Minimum Spanning Tree","permalink":"/markdown-web-app/minimum-spanning-tree"}},{"id":"trees","title":"Trees","description":"Introduction to Trees","source":"@site/docs/trees.md","sourceDirName":".","slug":"/trees","permalink":"/markdown-web-app/trees","draft":false,"unlisted":false,"editUrl":"https://github.com/kalyxon/markdown-web-app/tree/main/docs/trees.md","tags":[],"version":"current","frontMatter":{"id":"trees","title":"Trees"},"sidebar":"dsa","previous":{"title":"Hash Tables","permalink":"/markdown-web-app/hash-tables"},"next":{"title":"Graphs","permalink":"/markdown-web-app/graphs"}}],"drafts":[],"sidebars":{"dsa":[{"type":"doc","id":"intro"},{"type":"category","label":"Data Structures","collapsed":false,"items":[{"type":"doc","id":"arrays"},{"type":"doc","id":"linked-list"},{"type":"doc","id":"stacks-queues"},{"type":"doc","id":"hash-tables"},{"type":"doc","id":"trees"},{"type":"doc","id":"graphs"}],"collapsible":true},{"type":"category","label":"Algorithms","collapsed":false,"items":[{"type":"doc","id":"time-complexity"},{"type":"doc","id":"minimum-spanning-tree"},{"type":"doc","id":"maximum-flow"},{"type":"doc","id":"shortest-path"}],"collapsible":true},{"type":"category","label":"Reference & Practice","items":[{"type":"doc","id":"exercises"}],"collapsed":true,"collapsible":true}]}}]}},"docusaurus-plugin-content-pages":{"default":[{"type":"mdx","permalink":"/markdown-web-app/","source":"@site/src/pages/index.md","frontMatter":{},"unlisted":false}]},"docusaurus-plugin-debug":{},"docusaurus-theme-classic":{},"docusaurus-bootstrap-plugin":{},"docusaurus-mdx-fallback-plugin":{}}}