{"allContent":{"docusaurus-plugin-content-docs":{"default":{"loadedVersions":[{"versionName":"current","label":"Next","banner":null,"badge":false,"noIndex":false,"className":"docs-version-current","path":"/","tagsPath":"/tags","editUrl":"https://github.com/yourusername/my-dsa-notes/tree/main/docs","editUrlLocalized":"https://github.com/yourusername/my-dsa-notes/tree/main/i18n/en/docusaurus-plugin-content-docs/current","isLast":true,"routePriority":-1,"sidebarFilePath":"/home/maya/my-dsa-notes/sidebars.js","contentPath":"/home/maya/my-dsa-notes/docs","contentPathLocalized":"/home/maya/my-dsa-notes/i18n/en/docusaurus-plugin-content-docs/current","docs":[{"id":"arrays","title":"Arrays","description":"Arrays in C++","source":"@site/docs/arrays.md","sourceDirName":".","slug":"/arrays","permalink":"/arrays","draft":false,"unlisted":false,"editUrl":"https://github.com/yourusername/my-dsa-notes/tree/main/docs/arrays.md","tags":[],"version":"current","frontMatter":{},"sidebar":"dsa","previous":{"title":"Welcome to DSA Notes","permalink":"/intro"},"next":{"title":"DSA Linked Lists","permalink":"/linked-list"}},{"id":"exercises","title":"DSA Reference","description":"DSA Euclidean Algorithm","source":"@site/docs/exercises.md","sourceDirName":".","slug":"/exercises","permalink":"/exercises","draft":false,"unlisted":false,"editUrl":"https://github.com/yourusername/my-dsa-notes/tree/main/docs/exercises.md","tags":[],"version":"current","frontMatter":{},"sidebar":"dsa","previous":{"title":"DSA Shortest Path Algorithms","permalink":"/shortest-path"}},{"id":"graphs","title":"DSA Graphs","description":"Introduction to Graphs","source":"@site/docs/graphs.md","sourceDirName":".","slug":"/graphs","permalink":"/graphs","draft":false,"unlisted":false,"editUrl":"https://github.com/yourusername/my-dsa-notes/tree/main/docs/graphs.md","tags":[],"version":"current","frontMatter":{},"sidebar":"dsa","previous":{"title":"DSA Trees","permalink":"/trees"},"next":{"title":"Time Complexity","permalink":"/time-complexity"}},{"id":"hash-tables","title":"DSA Hash Tables","description":"Introduction to Hash Tables","source":"@site/docs/hash-tables.md","sourceDirName":".","slug":"/hash-tables","permalink":"/hash-tables","draft":false,"unlisted":false,"editUrl":"https://github.com/yourusername/my-dsa-notes/tree/main/docs/hash-tables.md","tags":[],"version":"current","frontMatter":{},"sidebar":"dsa","previous":{"title":"DSA Stacks & Queues","permalink":"/stacks-queues"},"next":{"title":"DSA Trees","permalink":"/trees"}},{"id":"intro","title":"Welcome to DSA Notes","description":"Welcome to Kalyxon's focused DSA learning hub.","source":"@site/docs/intro.md","sourceDirName":".","slug":"/intro","permalink":"/intro","draft":false,"unlisted":false,"editUrl":"https://github.com/yourusername/my-dsa-notes/tree/main/docs/intro.md","tags":[],"version":"current","frontMatter":{},"sidebar":"dsa","next":{"title":"Arrays","permalink":"/arrays"}},{"id":"linked-list","title":"DSA Linked Lists","description":"Introduction to Linked Lists","source":"@site/docs/linked-list.md","sourceDirName":".","slug":"/linked-list","permalink":"/linked-list","draft":false,"unlisted":false,"editUrl":"https://github.com/yourusername/my-dsa-notes/tree/main/docs/linked-list.md","tags":[],"version":"current","frontMatter":{},"sidebar":"dsa","previous":{"title":"Arrays","permalink":"/arrays"},"next":{"title":"DSA Stacks & Queues","permalink":"/stacks-queues"}},{"id":"maximum-flow","title":"Maximum Flow","description":"Maximum Flow is a fundamental problem in network theory that involves finding the maximum amount of flow that can be sent from a source node to a sink node in a flow network. A flow network is a directed graph where each edge has a capacity (maximum amount of flow it can carry) and actual flow (amount currently passing through).","source":"@site/docs/maximum-flow.md","sourceDirName":".","slug":"/maximum-flow","permalink":"/maximum-flow","draft":false,"unlisted":false,"editUrl":"https://github.com/yourusername/my-dsa-notes/tree/main/docs/maximum-flow.md","tags":[],"version":"current","frontMatter":{},"sidebar":"dsa","previous":{"title":"Minimum Spanning Tree","permalink":"/minimum-spanning-tree"},"next":{"title":"DSA Shortest Path Algorithms","permalink":"/shortest-path"}},{"id":"minimum-spanning-tree","title":"Minimum Spanning Tree","description":"A Minimum Spanning Tree (MST) is a subset of edges of a connected, edge-weighted undirected graph that connects all the vertices together without any cycles and with the minimum possible total edge weight. In simpler terms, it's the most efficient way to connect all points (vertices) in a network with the least total cost (edge weights).","source":"@site/docs/minimum-spanning-tree.md","sourceDirName":".","slug":"/minimum-spanning-tree","permalink":"/minimum-spanning-tree","draft":false,"unlisted":false,"editUrl":"https://github.com/yourusername/my-dsa-notes/tree/main/docs/minimum-spanning-tree.md","tags":[],"version":"current","frontMatter":{},"sidebar":"dsa","previous":{"title":"Time Complexity","permalink":"/time-complexity"},"next":{"title":"Maximum Flow","permalink":"/maximum-flow"}},{"id":"shortest-path","title":"DSA Shortest Path Algorithms","description":"Introduction to Shortest Path Problems","source":"@site/docs/shortest-path.md","sourceDirName":".","slug":"/shortest-path","permalink":"/shortest-path","draft":false,"unlisted":false,"editUrl":"https://github.com/yourusername/my-dsa-notes/tree/main/docs/shortest-path.md","tags":[],"version":"current","frontMatter":{},"sidebar":"dsa","previous":{"title":"Maximum Flow","permalink":"/maximum-flow"},"next":{"title":"DSA Reference","permalink":"/exercises"}},{"id":"stacks-queues","title":"DSA Stacks & Queues","description":"Introduction to Stacks & Queues","source":"@site/docs/stacks-queues.md","sourceDirName":".","slug":"/stacks-queues","permalink":"/stacks-queues","draft":false,"unlisted":false,"editUrl":"https://github.com/yourusername/my-dsa-notes/tree/main/docs/stacks-queues.md","tags":[],"version":"current","frontMatter":{},"sidebar":"dsa","previous":{"title":"DSA Linked Lists","permalink":"/linked-list"},"next":{"title":"DSA Hash Tables","permalink":"/hash-tables"}},{"id":"time-complexity","title":"Time Complexity","description":"Time Complexity is a fundamental concept in computer science that describes the amount of computational time an algorithm takes to run as a function of the input size. It provides a theoretical estimate of the time required for an algorithm to complete, helping us understand and compare the efficiency of different algorithms.","source":"@site/docs/time-complexity.md","sourceDirName":".","slug":"/time-complexity","permalink":"/time-complexity","draft":false,"unlisted":false,"editUrl":"https://github.com/yourusername/my-dsa-notes/tree/main/docs/time-complexity.md","tags":[],"version":"current","frontMatter":{},"sidebar":"dsa","previous":{"title":"DSA Graphs","permalink":"/graphs"},"next":{"title":"Minimum Spanning Tree","permalink":"/minimum-spanning-tree"}},{"id":"trees","title":"DSA Trees","description":"Introduction to Trees","source":"@site/docs/trees.md","sourceDirName":".","slug":"/trees","permalink":"/trees","draft":false,"unlisted":false,"editUrl":"https://github.com/yourusername/my-dsa-notes/tree/main/docs/trees.md","tags":[],"version":"current","frontMatter":{},"sidebar":"dsa","previous":{"title":"DSA Hash Tables","permalink":"/hash-tables"},"next":{"title":"DSA Graphs","permalink":"/graphs"}}],"drafts":[],"sidebars":{"dsa":[{"type":"doc","id":"intro"},{"type":"category","label":"Data Structures","collapsed":false,"items":[{"type":"doc","id":"arrays"},{"type":"doc","id":"linked-list"},{"type":"doc","id":"stacks-queues"},{"type":"doc","id":"hash-tables"},{"type":"doc","id":"trees"},{"type":"doc","id":"graphs"}],"collapsible":true},{"type":"category","label":"Algorithms","collapsed":false,"items":[{"type":"doc","id":"time-complexity"},{"type":"doc","id":"minimum-spanning-tree"},{"type":"doc","id":"maximum-flow"},{"type":"doc","id":"shortest-path"}],"collapsible":true},{"type":"category","label":"Reference & Practice","items":[{"type":"doc","id":"exercises"}],"collapsed":true,"collapsible":true}]}}]}},"docusaurus-plugin-content-pages":{"default":[{"type":"mdx","permalink":"/","source":"@site/src/pages/index.md","frontMatter":{},"unlisted":false}]},"docusaurus-plugin-debug":{},"docusaurus-theme-classic":{},"docusaurus-bootstrap-plugin":{},"docusaurus-mdx-fallback-plugin":{}}}