{"version":{"pluginId":"default","version":"current","label":"Next","banner":null,"badge":false,"noIndex":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"dsa":[{"type":"link","label":"Welcome to DSA Notes","href":"/intro","docId":"intro","unlisted":false},{"type":"category","label":"Data Structures","collapsed":false,"items":[{"type":"link","label":"Arrays","href":"/arrays","docId":"arrays","unlisted":false},{"type":"link","label":"DSA Linked Lists","href":"/linked-list","docId":"linked-list","unlisted":false},{"type":"link","label":"DSA Stacks & Queues","href":"/stacks-queues","docId":"stacks-queues","unlisted":false},{"type":"link","label":"DSA Hash Tables","href":"/hash-tables","docId":"hash-tables","unlisted":false},{"type":"link","label":"DSA Trees","href":"/trees","docId":"trees","unlisted":false},{"type":"link","label":"DSA Graphs","href":"/graphs","docId":"graphs","unlisted":false}],"collapsible":true},{"type":"category","label":"Algorithms","collapsed":false,"items":[{"type":"link","label":"Time Complexity","href":"/time-complexity","docId":"time-complexity","unlisted":false},{"type":"link","label":"Minimum Spanning Tree","href":"/minimum-spanning-tree","docId":"minimum-spanning-tree","unlisted":false},{"type":"link","label":"Maximum Flow","href":"/maximum-flow","docId":"maximum-flow","unlisted":false},{"type":"link","label":"DSA Shortest Path Algorithms","href":"/shortest-path","docId":"shortest-path","unlisted":false}],"collapsible":true},{"type":"category","label":"Reference & Practice","items":[{"type":"link","label":"DSA Reference","href":"/exercises","docId":"exercises","unlisted":false}],"collapsed":true,"collapsible":true}]},"docs":{"arrays":{"id":"arrays","title":"Arrays","description":"Arrays in C++","sidebar":"dsa"},"exercises":{"id":"exercises","title":"DSA Reference","description":"DSA Euclidean Algorithm","sidebar":"dsa"},"graphs":{"id":"graphs","title":"DSA Graphs","description":"Introduction to Graphs","sidebar":"dsa"},"hash-tables":{"id":"hash-tables","title":"DSA Hash Tables","description":"Introduction to Hash Tables","sidebar":"dsa"},"intro":{"id":"intro","title":"Welcome to DSA Notes","description":"Welcome to Kalyxon's focused DSA learning hub.","sidebar":"dsa"},"linked-list":{"id":"linked-list","title":"DSA Linked Lists","description":"Introduction to Linked Lists","sidebar":"dsa"},"maximum-flow":{"id":"maximum-flow","title":"Maximum Flow","description":"Maximum Flow is a fundamental problem in network theory that involves finding the maximum amount of flow that can be sent from a source node to a sink node in a flow network. A flow network is a directed graph where each edge has a capacity (maximum amount of flow it can carry) and actual flow (amount currently passing through).","sidebar":"dsa"},"minimum-spanning-tree":{"id":"minimum-spanning-tree","title":"Minimum Spanning Tree","description":"A Minimum Spanning Tree (MST) is a subset of edges of a connected, edge-weighted undirected graph that connects all the vertices together without any cycles and with the minimum possible total edge weight. In simpler terms, it's the most efficient way to connect all points (vertices) in a network with the least total cost (edge weights).","sidebar":"dsa"},"shortest-path":{"id":"shortest-path","title":"DSA Shortest Path Algorithms","description":"Introduction to Shortest Path Problems","sidebar":"dsa"},"stacks-queues":{"id":"stacks-queues","title":"DSA Stacks & Queues","description":"Introduction to Stacks & Queues","sidebar":"dsa"},"time-complexity":{"id":"time-complexity","title":"Time Complexity","description":"Time Complexity is a fundamental concept in computer science that describes the amount of computational time an algorithm takes to run as a function of the input size. It provides a theoretical estimate of the time required for an algorithm to complete, helping us understand and compare the efficiency of different algorithms.","sidebar":"dsa"},"trees":{"id":"trees","title":"DSA Trees","description":"Introduction to Trees","sidebar":"dsa"}}}}