"use strict";(globalThis.webpackChunkmy_dsa_notes=globalThis.webpackChunkmy_dsa_notes||[]).push([[770],{1045(n,e,i){i.r(e),i.d(e,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>l,metadata:()=>t,toc:()=>a});const t=JSON.parse('{"id":"minimum-spanning-tree","title":"Minimum Spanning Tree","description":"A Minimum Spanning Tree (MST) is a subset of edges of a connected, edge-weighted undirected graph that connects all the vertices together without any cycles and with the minimum possible total edge weight. In simpler terms, it\'s the most efficient way to connect all points (vertices) in a network with the least total cost (edge weights).","source":"@site/docs/minimum-spanning-tree.md","sourceDirName":".","slug":"/minimum-spanning-tree","permalink":"/minimum-spanning-tree","draft":false,"unlisted":false,"editUrl":"https://github.com/kalyxon/markdown-web-app/tree/main/docs/minimum-spanning-tree.md","tags":[],"version":"current","frontMatter":{},"sidebar":"dsa","previous":{"title":"Time Complexity","permalink":"/time-complexity"},"next":{"title":"Maximum Flow","permalink":"/maximum-flow"}}');var r=i(4848),s=i(8453);const l={},o="Minimum Spanning Tree",d={},a=[{value:"Key Properties of MST",id:"key-properties-of-mst",level:2},{value:"DSA Prim&#39;s Algorithm",id:"dsa-prims-algorithm",level:2},{value:"How Prim&#39;s Algorithm Works",id:"how-prims-algorithm-works",level:3},{value:"Prim&#39;s Algorithm Implementation",id:"prims-algorithm-implementation",level:3},{value:"Prim&#39;s Algorithm Complexity",id:"prims-algorithm-complexity",level:3},{value:"DSA Kruskal&#39;s Algorithm",id:"dsa-kruskals-algorithm",level:2},{value:"How Kruskal&#39;s Algorithm Works",id:"how-kruskals-algorithm-works",level:3},{value:"Union-Find Data Structure",id:"union-find-data-structure",level:3},{value:"Kruskal&#39;s Algorithm Complexity",id:"kruskals-algorithm-complexity",level:3},{value:"Comparison: Prim&#39;s vs Kruskal&#39;s",id:"comparison-prims-vs-kruskals",level:2},{value:"Applications of Minimum Spanning Tree",id:"applications-of-minimum-spanning-tree",level:2},{value:"Example: Real-World MST Application",id:"example-real-world-mst-application",level:2},{value:"Visual Example of MST Construction",id:"visual-example-of-mst-construction",level:2},{value:"Practice Problems",id:"practice-problems",level:2},{value:"Common Mistakes to Avoid",id:"common-mistakes-to-avoid",level:2}];function c(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.header,{children:(0,r.jsx)(e.h1,{id:"minimum-spanning-tree",children:"Minimum Spanning Tree"})}),"\n",(0,r.jsx)(e.p,{children:"A Minimum Spanning Tree (MST) is a subset of edges of a connected, edge-weighted undirected graph that connects all the vertices together without any cycles and with the minimum possible total edge weight. In simpler terms, it's the most efficient way to connect all points (vertices) in a network with the least total cost (edge weights)."}),"\n",(0,r.jsx)(e.h2,{id:"key-properties-of-mst",children:"Key Properties of MST"}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Spanning"}),": Connects all vertices in the graph"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Tree"}),": Contains no cycles (acyclic)"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Minimum"}),": Total edge weight is minimized"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Connected"}),": All vertices are reachable from any other vertex"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Edges"}),": Contains exactly V-1 edges for V vertices"]}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"dsa-prims-algorithm",children:"DSA Prim's Algorithm"}),"\n",(0,r.jsx)(e.p,{children:"Prim's algorithm is a greedy algorithm that finds a minimum spanning tree for a weighted undirected graph. It starts from an arbitrary vertex and grows the MST one edge at a time, always adding the smallest-weight edge that connects a vertex in the MST to a vertex outside the MST."}),"\n",(0,r.jsx)(e.h3,{id:"how-prims-algorithm-works",children:"How Prim's Algorithm Works"}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Initialize"}),": Start with an arbitrary vertex, mark it as visited"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Grow Tree"}),": Repeat until all vertices are visited:","\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Find the minimum-weight edge connecting visited and unvisited vertices"}),"\n",(0,r.jsx)(e.li,{children:"Add this edge to the MST"}),"\n",(0,r.jsx)(e.li,{children:"Mark the newly connected vertex as visited"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Terminate"}),": When all vertices are visited, MST is complete"]}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"prims-algorithm-implementation",children:"Prim's Algorithm Implementation"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\nusing namespace std;\n\n// Structure to represent a graph edge\nstruct Edge {\n    int dest;\n    int weight;\n    Edge(int d, int w) : dest(d), weight(w) {}\n};\n\n// Function to implement Prim\'s Algorithm\nvoid primMST(vector<vector<Edge>>& graph, int V) {\n    vector<int> parent(V, -1);       // Store MST structure\n    vector<int> key(V, INT_MAX);     // Key values to pick minimum weight edge\n    vector<bool> inMST(V, false);    // Track vertices included in MST\n    \n    // Min-heap priority queue (weight, vertex)\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\n    \n    // Start with vertex 0\n    key[0] = 0;\n    pq.push({0, 0});\n    \n    while (!pq.empty()) {\n        int u = pq.top().second;\n        pq.pop();\n        \n        inMST[u] = true;\n        \n        // Check all adjacent vertices\n        for (auto& edge : graph[u]) {\n            int v = edge.dest;\n            int weight = edge.weight;\n            \n            // If v is not in MST and weight is smaller than current key\n            if (!inMST[v] && weight < key[v]) {\n                key[v] = weight;\n                parent[v] = u;\n                pq.push({key[v], v});\n            }\n        }\n    }\n    \n    // Print the MST\n    cout << "Minimum Spanning Tree (Prim\'s Algorithm):" << endl;\n    cout << "Edge \\tWeight" << endl;\n    int totalWeight = 0;\n    for (int i = 1; i < V; i++) {\n        cout << parent[i] << " - " << i << " \\t" << key[i] << endl;\n        totalWeight += key[i];\n    }\n    cout << "Total weight of MST: " << totalWeight << endl;\n}\n\nint main() {\n    // Example graph with 5 vertices\n    int V = 5;\n    vector<vector<Edge>> graph(V);\n    \n    // Adding edges (undirected graph)\n    graph[0].push_back(Edge(1, 2));\n    graph[0].push_back(Edge(3, 6));\n    graph[1].push_back(Edge(0, 2));\n    graph[1].push_back(Edge(2, 3));\n    graph[1].push_back(Edge(3, 8));\n    graph[1].push_back(Edge(4, 5));\n    graph[2].push_back(Edge(1, 3));\n    graph[2].push_back(Edge(4, 7));\n    graph[3].push_back(Edge(0, 6));\n    graph[3].push_back(Edge(1, 8));\n    graph[3].push_back(Edge(4, 9));\n    graph[4].push_back(Edge(1, 5));\n    graph[4].push_back(Edge(2, 7));\n    graph[4].push_back(Edge(3, 9));\n    \n    primMST(graph, V);\n    \n    return 0;\n}\n'})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Output:"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:"Minimum Spanning Tree (Prim's Algorithm):\nEdge    Weight\n0 - 1   2\n1 - 2   3\n0 - 3   6\n1 - 4   5\nTotal weight of MST: 16\n"})}),"\n",(0,r.jsx)(e.h3,{id:"prims-algorithm-complexity",children:"Prim's Algorithm Complexity"}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Time Complexity:"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Adjacency Matrix"}),": O(V\xb2)"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Adjacency List with Binary Heap"}),": O(E log V)"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Adjacency List with Fibonacci Heap"}),": O(E + V log V)"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Space Complexity:"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"O(V + E) for storing the graph"}),"\n",(0,r.jsx)(e.li,{children:"O(V) for auxiliary arrays"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Advantages:"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Efficient for dense graphs"}),"\n",(0,r.jsx)(e.li,{children:"Always finds the optimal solution"}),"\n",(0,r.jsx)(e.li,{children:"Easy to implement with priority queues"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Disadvantages:"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Requires graph to be connected"}),"\n",(0,r.jsx)(e.li,{children:"Not as efficient for sparse graphs compared to Kruskal's"}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"dsa-kruskals-algorithm",children:"DSA Kruskal's Algorithm"}),"\n",(0,r.jsx)(e.p,{children:"Kruskal's algorithm is another greedy algorithm for finding a minimum spanning tree. It works by sorting all edges from lowest to highest weight, then picking edges one by one while ensuring no cycles are formed."}),"\n",(0,r.jsx)(e.h3,{id:"how-kruskals-algorithm-works",children:"How Kruskal's Algorithm Works"}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Sort Edges"}),": Sort all edges in non-decreasing order of their weight"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Initialize"}),": Create a forest (set of trees) where each vertex is a separate tree"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Process Edges"}),": For each edge in sorted order:","\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"If adding the edge doesn't form a cycle, add it to MST"}),"\n",(0,r.jsx)(e.li,{children:"Otherwise, discard it"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Terminate"}),": When V-1 edges are added to MST"]}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"union-find-data-structure",children:"Union-Find Data Structure"}),"\n",(0,r.jsx)(e.p,{children:"Kruskal's algorithm uses the Union-Find (Disjoint Set Union) data structure to efficiently detect cycles."}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// Structure to represent an edge\nstruct Edge {\n    int src, dest, weight;\n    \n    // Comparator for sorting edges\n    bool operator<(const Edge& other) const {\n        return weight < other.weight;\n    }\n};\n\n// Union-Find (Disjoint Set) data structure\nclass UnionFind {\nprivate:\n    vector<int> parent, rank;\n    \npublic:\n    UnionFind(int n) {\n        parent.resize(n);\n        rank.resize(n, 0);\n        for (int i = 0; i < n; i++) {\n            parent[i] = i;\n        }\n    }\n    \n    int find(int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]); // Path compression\n        }\n        return parent[x];\n    }\n    \n    void unite(int x, int y) {\n        int rootX = find(x);\n        int rootY = find(y);\n        \n        if (rootX != rootY) {\n            // Union by rank\n            if (rank[rootX] < rank[rootY]) {\n                parent[rootX] = rootY;\n            } else if (rank[rootX] > rank[rootY]) {\n                parent[rootY] = rootX;\n            } else {\n                parent[rootY] = rootX;\n                rank[rootX]++;\n            }\n        }\n    }\n};\n\n// Kruskal\'s Algorithm Implementation\nvoid kruskalMST(vector<Edge>& edges, int V) {\n    // Sort edges by weight\n    sort(edges.begin(), edges.end());\n    \n    UnionFind uf(V);\n    vector<Edge> mst;\n    int totalWeight = 0;\n    \n    cout << "Kruskal\'s Algorithm Process:" << endl;\n    cout << "Sorted edges by weight:" << endl;\n    for (const auto& edge : edges) {\n        cout << edge.src << " - " << edge.dest << " : " << edge.weight << endl;\n    }\n    cout << endl;\n    \n    for (const auto& edge : edges) {\n        int srcRoot = uf.find(edge.src);\n        int destRoot = uf.find(edge.dest);\n        \n        // If including this edge doesn\'t cause cycle\n        if (srcRoot != destRoot) {\n            mst.push_back(edge);\n            totalWeight += edge.weight;\n            uf.unite(srcRoot, destRoot);\n            \n            cout << "Adding edge: " << edge.src << " - " << edge.dest \n                 << " (weight: " << edge.weight << ")" << endl;\n        } else {\n            cout << "Skipping edge: " << edge.src << " - " << edge.dest \n                 << " (would create cycle)" << endl;\n        }\n        \n        // Stop when we have V-1 edges\n        if (mst.size() == V - 1) {\n            break;\n        }\n    }\n    \n    // Print the MST\n    cout << "\\nMinimum Spanning Tree (Kruskal\'s Algorithm):" << endl;\n    cout << "Edge \\tWeight" << endl;\n    for (const auto& edge : mst) {\n        cout << edge.src << " - " << edge.dest << " \\t" << edge.weight << endl;\n    }\n    cout << "Total weight of MST: " << totalWeight << endl;\n}\n\nint main() {\n    // Example graph with 5 vertices and 7 edges\n    int V = 5;\n    vector<Edge> edges = {\n        {0, 1, 2},\n        {0, 3, 6},\n        {1, 2, 3},\n        {1, 3, 8},\n        {1, 4, 5},\n        {2, 4, 7},\n        {3, 4, 9}\n    };\n    \n    kruskalMST(edges, V);\n    \n    return 0;\n}\n'})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Output:"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:"Kruskal's Algorithm Process:\nSorted edges by weight:\n0 - 1 : 2\n1 - 2 : 3\n1 - 4 : 5\n0 - 3 : 6\n2 - 4 : 7\n1 - 3 : 8\n3 - 4 : 9\n\nAdding edge: 0 - 1 (weight: 2)\nAdding edge: 1 - 2 (weight: 3)\nAdding edge: 1 - 4 (weight: 5)\nSkipping edge: 0 - 3 (would create cycle)\nAdding edge: 0 - 3 (weight: 6)\n\nMinimum Spanning Tree (Kruskal's Algorithm):\nEdge    Weight\n0 - 1   2\n1 - 2   3\n1 - 4   5\n0 - 3   6\nTotal weight of MST: 16\n"})}),"\n",(0,r.jsx)(e.h3,{id:"kruskals-algorithm-complexity",children:"Kruskal's Algorithm Complexity"}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Time Complexity:"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Sorting Edges"}),": O(E log E)"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Union-Find Operations"}),": O(E \u03b1(V)) where \u03b1 is the inverse Ackermann function"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Overall"}),": O(E log E) or O(E log V) (since E \u2264 V\xb2)"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Space Complexity:"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"O(V + E) for storing edges and Union-Find structure"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Advantages:"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Efficient for sparse graphs"}),"\n",(0,r.jsx)(e.li,{children:"Simple to implement"}),"\n",(0,r.jsx)(e.li,{children:"Works well with edge lists"}),"\n",(0,r.jsx)(e.li,{children:"Doesn't require the graph to be connected initially"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Disadvantages:"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Requires sorting all edges"}),"\n",(0,r.jsx)(e.li,{children:"Less efficient for dense graphs"}),"\n",(0,r.jsx)(e.li,{children:"Needs extra memory for Union-Find structure"}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"comparison-prims-vs-kruskals",children:"Comparison: Prim's vs Kruskal's"}),"\n",(0,r.jsxs)(e.table,{children:[(0,r.jsx)(e.thead,{children:(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.th,{children:"Aspect"}),(0,r.jsx)(e.th,{children:"Prim's Algorithm"}),(0,r.jsx)(e.th,{children:"Kruskal's Algorithm"})]})}),(0,r.jsxs)(e.tbody,{children:[(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.strong,{children:"Approach"})}),(0,r.jsx)(e.td,{children:"Vertex-based (grows tree from starting vertex)"}),(0,r.jsx)(e.td,{children:"Edge-based (sorts all edges first)"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.strong,{children:"Best For"})}),(0,r.jsx)(e.td,{children:"Dense graphs"}),(0,r.jsx)(e.td,{children:"Sparse graphs"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.strong,{children:"Data Structure"})}),(0,r.jsx)(e.td,{children:"Priority Queue (Heap)"}),(0,r.jsx)(e.td,{children:"Union-Find (Disjoint Set)"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.strong,{children:"Time Complexity"})}),(0,r.jsx)(e.td,{children:"O(E log V) with binary heap"}),(0,r.jsx)(e.td,{children:"O(E log E)"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.strong,{children:"Space Complexity"})}),(0,r.jsx)(e.td,{children:"O(V + E)"}),(0,r.jsx)(e.td,{children:"O(V + E)"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.strong,{children:"Graph Requirement"})}),(0,r.jsx)(e.td,{children:"Must be connected"}),(0,r.jsx)(e.td,{children:"Can work with disconnected graphs"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.strong,{children:"Implementation"})}),(0,r.jsx)(e.td,{children:"Slightly more complex"}),(0,r.jsx)(e.td,{children:"Simpler with Union-Find"})]})]})]}),"\n",(0,r.jsx)(e.h2,{id:"applications-of-minimum-spanning-tree",children:"Applications of Minimum Spanning Tree"}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Network Design"}),": Designing computer, telecommunications, or transportation networks"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Circuit Design"}),": Connecting pins on a circuit board with minimum wire length"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Cluster Analysis"}),": In machine learning for hierarchical clustering"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Image Segmentation"}),": In computer vision for region-based segmentation"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Road/Plumbing Networks"}),": Planning infrastructure with minimum cost"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Approximation Algorithms"}),": For NP-hard problems like Traveling Salesman"]}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"example-real-world-mst-application",children:"Example: Real-World MST Application"}),"\n",(0,r.jsx)(e.p,{children:"Consider connecting 5 cities with roads. The costs (in millions) between cities are:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"City 0-1: $2M"}),"\n",(0,r.jsx)(e.li,{children:"City 0-3: $6M"}),"\n",(0,r.jsx)(e.li,{children:"City 1-2: $3M"}),"\n",(0,r.jsx)(e.li,{children:"City 1-3: $8M"}),"\n",(0,r.jsx)(e.li,{children:"City 1-4: $5M"}),"\n",(0,r.jsx)(e.li,{children:"City 2-4: $7M"}),"\n",(0,r.jsx)(e.li,{children:"City 3-4: $9M"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"Both Prim's and Kruskal's algorithms would find the optimal road network:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Roads: 0-1, 1-2, 1-4, 0-3"}),"\n",(0,r.jsx)(e.li,{children:"Total Cost: $16M"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"This ensures all cities are connected with minimum total construction cost, avoiding unnecessary expensive connections while preventing isolated cities."}),"\n",(0,r.jsx)(e.h2,{id:"visual-example-of-mst-construction",children:"Visual Example of MST Construction"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:"Initial Graph:\n    2\n (0)---(1)\n  |    /|\\\n 6|  8/ | \\5\n  |  /  |  \\\n (3)  3 |  (4)\n        |  /\n        | /7\n       (2)\n\nMST Construction (Prim's starting from vertex 0):\nStep 1: Start at 0\nStep 2: Add edge 0-1 (weight 2)\nStep 3: From {0,1}, add edge 1-2 (weight 3)\nStep 4: From {0,1,2}, add edge 1-4 (weight 5)\nStep 5: From {0,1,2,4}, add edge 0-3 (weight 6)\n\nFinal MST:\n    2\n (0)---(1)\n  |     |\\\n 6|     | \\5\n  |     |  \\\n (3)  3 |  (4)\n         (2)\nTotal Weight: 2 + 3 + 5 + 6 = 16\n"})}),"\n",(0,r.jsx)(e.h2,{id:"practice-problems",children:"Practice Problems"}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Find MST Weight"}),": Given a graph with V vertices and E edges, find the weight of MST"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"MST in Grid"}),": Connect all points in a 2D grid with minimum total Manhattan distance"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Second-best MST"}),": Find the spanning tree with the second minimum total weight"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Critical Edges"}),": Identify edges that must be included in every MST"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"MST with Constraints"}),": Find MST while avoiding certain edges or requiring others"]}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"common-mistakes-to-avoid",children:"Common Mistakes to Avoid"}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Not checking for connectivity"}),": Ensure the graph is connected before applying Prim's"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Forgetting to sort edges"}),": Crucial for Kruskal's algorithm"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Ignoring cycle detection"}),": Essential in Kruskal's algorithm"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Using wrong data structures"}),": Choose appropriate structures for the algorithm"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Not optimizing Union-Find"}),": Implement path compression and union by rank for efficiency"]}),"\n"]})]})}function h(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(c,{...n})}):c(n)}},8453(n,e,i){i.d(e,{R:()=>l,x:()=>o});var t=i(6540);const r={},s=t.createContext(r);function l(n){const e=t.useContext(s);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function o(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:l(n.components),t.createElement(s.Provider,{value:e},n.children)}}}]);