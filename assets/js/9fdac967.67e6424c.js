"use strict";(globalThis.webpackChunkmy_dsa_notes=globalThis.webpackChunkmy_dsa_notes||[]).push([[10],{4851(n,e,i){i.r(e),i.d(e,{assets:()=>l,contentTitle:()=>s,default:()=>u,frontMatter:()=>a,metadata:()=>o,toc:()=>c});var t=i(4848),r=i(8453);const a={},s="Arrays",o={id:"arrays",title:"Arrays",description:"Arrays in C++",source:"@site/docs/arrays.md",sourceDirName:".",slug:"/arrays",permalink:"/markdown-web-app/arrays",draft:!1,unlisted:!1,editUrl:"https://github.com/Kalyxon/markdown-web-app/tree/main/docs/arrays.md",tags:[],version:"current",frontMatter:{},sidebar:"dsa",previous:{title:"Welcome to DSA Notes",permalink:"/markdown-web-app/intro"},next:{title:"DSA Linked Lists",permalink:"/markdown-web-app/linked-list"}},l={},c=[{value:"Arrays in C++",id:"arrays-in-c",level:2},{value:"Declaration and Initialization",id:"declaration-and-initialization",level:3},{value:"Array Traversal and Basic Operations",id:"array-traversal-and-basic-operations",level:3},{value:"Multi-dimensional Arrays",id:"multi-dimensional-arrays",level:3},{value:"DSA Bubble Sort",id:"dsa-bubble-sort",level:2},{value:"How Bubble Sort Works",id:"how-bubble-sort-works",level:3},{value:"Basic Implementation",id:"basic-implementation",level:3},{value:"Optimized Bubble Sort",id:"optimized-bubble-sort",level:3},{value:"Bubble Sort Complexity Analysis",id:"bubble-sort-complexity-analysis",level:3},{value:"Visual Example of Bubble Sort",id:"visual-example-of-bubble-sort",level:3},{value:"DSA Selection Sort",id:"dsa-selection-sort",level:2},{value:"How Selection Sort Works",id:"how-selection-sort-works",level:3},{value:"Basic Implementation",id:"basic-implementation-1",level:3},{value:"Selection Sort with Visualization",id:"selection-sort-with-visualization",level:3},{value:"Selection Sort Complexity Analysis",id:"selection-sort-complexity-analysis",level:3},{value:"Stability in Selection Sort",id:"stability-in-selection-sort",level:3},{value:"When to Use Selection Sort",id:"when-to-use-selection-sort",level:3},{value:"Comparison with Other Sorting Algorithms",id:"comparison-with-other-sorting-algorithms",level:3},{value:"DSA Insertion Sort",id:"dsa-insertion-sort",level:2},{value:"How Insertion Sort Works",id:"how-insertion-sort-works",level:3},{value:"Basic Implementation",id:"basic-implementation-2",level:3},{value:"Visual Step-by-Step Process",id:"visual-step-by-step-process",level:3},{value:"Binary Insertion Sort (Optimized)",id:"binary-insertion-sort-optimized",level:3},{value:"Insertion Sort Complexity Analysis",id:"insertion-sort-complexity-analysis",level:3},{value:"Real-world Applications",id:"real-world-applications",level:3},{value:"When to Use Insertion Sort",id:"when-to-use-insertion-sort",level:3},{value:"Performance Comparison",id:"performance-comparison",level:3},{value:"Introduction to Quick Sort",id:"introduction-to-quick-sort",level:2},{value:"Key Characteristics:",id:"key-characteristics",level:3},{value:"How Quick Sort Works",id:"how-quick-sort-works",level:2},{value:"The Three-Step Process:",id:"the-three-step-process",level:3},{value:"Visual Example:",id:"visual-example",level:3},{value:"Basic Quick Sort Implementation",id:"basic-quick-sort-implementation",level:2},{value:"Detailed Step-by-Step Visualization",id:"detailed-step-by-step-visualization",level:2},{value:"Different Pivot Selection Strategies",id:"different-pivot-selection-strategies",level:2},{value:"Iterative Quick Sort Implementation",id:"iterative-quick-sort-implementation",level:2},{value:"Quick Sort Complexity Analysis",id:"quick-sort-complexity-analysis",level:2},{value:"Time Complexity:",id:"time-complexity",level:3},{value:"Space Complexity:",id:"space-complexity",level:3},{value:"Mathematical Analysis:",id:"mathematical-analysis",level:3},{value:"Optimizations and Improvements",id:"optimizations-and-improvements",level:2},{value:"1. Tail Call Optimization",id:"1-tail-call-optimization",level:3},{value:"2. Insertion Sort for Small Arrays",id:"2-insertion-sort-for-small-arrays",level:3},{value:"3. Three-Way Partitioning (for arrays with many duplicates)",id:"3-three-way-partitioning-for-arrays-with-many-duplicates",level:3},{value:"Performance Comparison",id:"performance-comparison-1",level:2},{value:"Applications of Quick Sort",id:"applications-of-quick-sort",level:2},{value:"1. Finding Kth Smallest/Largest Element",id:"1-finding-kth-smallestlargest-element",level:3},{value:"2. Sorting Custom Objects",id:"2-sorting-custom-objects",level:3},{value:"Advantages and Disadvantages",id:"advantages-and-disadvantages",level:2},{value:"Advantages:",id:"advantages",level:3},{value:"Disadvantages:",id:"disadvantages",level:3},{value:"Best Practices and Tips",id:"best-practices-and-tips",level:2},{value:"Comparison with Other Sorting Algorithms",id:"comparison-with-other-sorting-algorithms-1",level:2},{value:"Introduction to Counting Sort",id:"introduction-to-counting-sort",level:2},{value:"Key Characteristics:",id:"key-characteristics-1",level:3},{value:"How Counting Sort Works",id:"how-counting-sort-works",level:2},{value:"The Four-Step Process:",id:"the-four-step-process",level:3},{value:"Visual Example:",id:"visual-example-1",level:3},{value:"Basic Counting Sort Implementation",id:"basic-counting-sort-implementation",level:2},{value:"Detailed Step-by-Step Visualization",id:"detailed-step-by-step-visualization-1",level:2},{value:"Counting Sort with Negative Numbers",id:"counting-sort-with-negative-numbers",level:2},{value:"Counting Sort for Characters",id:"counting-sort-for-characters",level:2},{value:"Counting Sort Complexity Analysis",id:"counting-sort-complexity-analysis",level:2},{value:"Time Complexity:",id:"time-complexity-1",level:3},{value:"Space Complexity:",id:"space-complexity-1",level:3},{value:"When is Counting Sort Efficient?",id:"when-is-counting-sort-efficient",level:3},{value:"Optimized Counting Sort",id:"optimized-counting-sort",level:2},{value:"Applications of Counting Sort",id:"applications-of-counting-sort",level:2},{value:"1. Sorting Exam Scores (0-100 range)",id:"1-sorting-exam-scores-0-100-range",level:3},{value:"2. Histogram Generation",id:"2-histogram-generation",level:3},{value:"Comparison with Other Sorting Algorithms",id:"comparison-with-other-sorting-algorithms-2",level:2},{value:"Limitations and When Not to Use Counting Sort",id:"limitations-and-when-not-to-use-counting-sort",level:2},{value:"Limitations:",id:"limitations",level:3},{value:"When NOT to use Counting Sort:",id:"when-not-to-use-counting-sort",level:3},{value:"Hybrid Approach: Counting Sort + Other Algorithms",id:"hybrid-approach-counting-sort--other-algorithms",level:2},{value:"Summary",id:"summary",level:2},{value:"Introduction to Radix Sort",id:"introduction-to-radix-sort",level:2},{value:"Key Characteristics:",id:"key-characteristics-2",level:3},{value:"How Radix Sort Works",id:"how-radix-sort-works",level:2},{value:"The LSD (Least Significant Digit) Approach:",id:"the-lsd-least-significant-digit-approach",level:3},{value:"Visual Example:",id:"visual-example-2",level:3},{value:"Basic Radix Sort Implementation",id:"basic-radix-sort-implementation",level:2},{value:"Detailed Step-by-Step Visualization",id:"detailed-step-by-step-visualization-2",level:2},{value:"Radix Sort for Negative Numbers",id:"radix-sort-for-negative-numbers",level:2},{value:"Radix Sort for Strings",id:"radix-sort-for-strings",level:2},{value:"Different Radix Sort Variations",id:"different-radix-sort-variations",level:2},{value:"1. MSD (Most Significant Digit) Radix Sort",id:"1-msd-most-significant-digit-radix-sort",level:3},{value:"2. Radix Sort with Different Bases",id:"2-radix-sort-with-different-bases",level:3},{value:"Radix Sort Complexity Analysis",id:"radix-sort-complexity-analysis",level:2},{value:"Time Complexity:",id:"time-complexity-2",level:3},{value:"Space Complexity:",id:"space-complexity-2",level:3},{value:"Comparison with Other Algorithms:",id:"comparison-with-other-algorithms",level:3},{value:"Performance Comparison",id:"performance-comparison-2",level:2},{value:"Applications of Radix Sort",id:"applications-of-radix-sort",level:2},{value:"1. Sorting IP Addresses",id:"1-sorting-ip-addresses",level:3},{value:"2. Sorting Dates (YYYYMMDD format)",id:"2-sorting-dates-yyyymmdd-format",level:3},{value:"Optimizations and Best Practices",id:"optimizations-and-best-practices",level:2},{value:"1. Early Termination",id:"1-early-termination",level:3},{value:"2. Hybrid Approach with Insertion Sort",id:"2-hybrid-approach-with-insertion-sort",level:3},{value:"Common Interview Questions",id:"common-interview-questions",level:2},{value:"Summary",id:"summary-1",level:2},{value:"Introduction to Merge Sort",id:"introduction-to-merge-sort",level:2},{value:"Key Characteristics:",id:"key-characteristics-3",level:3},{value:"How Merge Sort Works",id:"how-merge-sort-works",level:2},{value:"The Three-Step Process:",id:"the-three-step-process-1",level:3},{value:"Visual Example:",id:"visual-example-3",level:3},{value:"Basic Merge Sort Implementation",id:"basic-merge-sort-implementation",level:2},{value:"Detailed Step-by-Step Visualization",id:"detailed-step-by-step-visualization-3",level:2},{value:"Iterative Merge Sort",id:"iterative-merge-sort",level:2},{value:"Merge Sort Complexity Analysis",id:"merge-sort-complexity-analysis",level:2},{value:"Time Complexity Analysis:",id:"time-complexity-analysis",level:3},{value:"Space Complexity:",id:"space-complexity-3",level:3},{value:"Optimization Techniques",id:"optimization-techniques",level:2},{value:"1. Use Insertion Sort for Small Subarrays",id:"1-use-insertion-sort-for-small-subarrays",level:3},{value:"2. Avoid Repeated Memory Allocation",id:"2-avoid-repeated-memory-allocation",level:3},{value:"3. Natural Merge Sort (Adaptive)",id:"3-natural-merge-sort-adaptive",level:3},{value:"Merge Sort for Linked Lists",id:"merge-sort-for-linked-lists",level:2},{value:"External Merge Sort (For Large Files)",id:"external-merge-sort-for-large-files",level:2},{value:"Applications of Merge Sort",id:"applications-of-merge-sort",level:2},{value:"1. Counting Inversions",id:"1-counting-inversions",level:3},{value:"2. External Sorting (Sort-Merge Join)",id:"2-external-sorting-sort-merge-join",level:3},{value:"Performance Comparison",id:"performance-comparison-3",level:2},{value:"Common Interview Questions",id:"common-interview-questions-1",level:2},{value:"1. Implement Merge Sort",id:"1-implement-merge-sort",level:3},{value:"2. Count Inversions in an Array",id:"2-count-inversions-in-an-array",level:3},{value:"3. Sort a Linked List using Merge Sort",id:"3-sort-a-linked-list-using-merge-sort",level:3},{value:"4. External Sort Implementation",id:"4-external-sort-implementation",level:3},{value:"5. Merge k Sorted Arrays",id:"5-merge-k-sorted-arrays",level:3},{value:"Advantages and Disadvantages",id:"advantages-and-disadvantages-1",level:2},{value:"Advantages:",id:"advantages-1",level:3},{value:"Disadvantages:",id:"disadvantages-1",level:3},{value:"When to Use Merge Sort",id:"when-to-use-merge-sort",level:2},{value:"Summary",id:"summary-2",level:2},{value:"Introduction to Linear Search",id:"introduction-to-linear-search",level:2},{value:"Key Characteristics:",id:"key-characteristics-4",level:3},{value:"How Linear Search Works",id:"how-linear-search-works",level:2},{value:"The Basic Algorithm:",id:"the-basic-algorithm",level:3},{value:"Visual Example:",id:"visual-example-4",level:3},{value:"Basic Linear Search Implementation",id:"basic-linear-search-implementation",level:2},{value:"Detailed Step-by-Step Visualization",id:"detailed-step-by-step-visualization-4",level:2},{value:"Variations of Linear Search",id:"variations-of-linear-search",level:2},{value:"1. Linear Search with Sentinel",id:"1-linear-search-with-sentinel",level:3},{value:"2. Linear Search for Multiple Occurrences",id:"2-linear-search-for-multiple-occurrences",level:3},{value:"3. Linear Search with Frequency Count",id:"3-linear-search-with-frequency-count",level:3},{value:"Linear Search on Different Data Structures",id:"linear-search-on-different-data-structures",level:2},{value:"1. Linear Search in Strings",id:"1-linear-search-in-strings",level:3},{value:"2. Linear Search in 2D Arrays",id:"2-linear-search-in-2d-arrays",level:3},{value:"3. Linear Search in Linked List",id:"3-linear-search-in-linked-list",level:3},{value:"Optimized Linear Search Techniques",id:"optimized-linear-search-techniques",level:2},{value:"1. Transposition (Move to Front) for Frequently Accessed Items",id:"1-transposition-move-to-front-for-frequently-accessed-items",level:3},{value:"2. Recursive Linear Search",id:"2-recursive-linear-search",level:3},{value:"Performance Analysis",id:"performance-analysis",level:2},{value:"Applications of Linear Search",id:"applications-of-linear-search",level:2},{value:"1. Finding Minimum/Maximum Element",id:"1-finding-minimummaximum-element",level:3},{value:"2. Data Validation and Filtering",id:"2-data-validation-and-filtering",level:3},{value:"3. Simple Database Search",id:"3-simple-database-search",level:3},{value:"Common Interview Questions",id:"common-interview-questions-2",level:2},{value:"1. Basic Linear Search Implementation",id:"1-basic-linear-search-implementation",level:3},{value:"2. Find Missing Number in Array",id:"2-find-missing-number-in-array",level:3},{value:"3. Find Pair with Given Sum",id:"3-find-pair-with-given-sum",level:3},{value:"Advantages and Disadvantages",id:"advantages-and-disadvantages-2",level:2},{value:"Advantages:",id:"advantages-2",level:3},{value:"Disadvantages:",id:"disadvantages-2",level:3},{value:"When to Use Linear Search",id:"when-to-use-linear-search",level:2},{value:"Summary",id:"summary-3",level:2},{value:"Introduction to Binary Search",id:"introduction-to-binary-search",level:2},{value:"Key Characteristics:",id:"key-characteristics-5",level:3},{value:"How Binary Search Works",id:"how-binary-search-works",level:2},{value:"The Algorithm:",id:"the-algorithm",level:3},{value:"Visual Example:",id:"visual-example-5",level:3},{value:"Basic Binary Search Implementation",id:"basic-binary-search-implementation",level:2},{value:"Detailed Step-by-Step Visualization",id:"detailed-step-by-step-visualization-5",level:2},{value:"Binary Search with STL Functions",id:"binary-search-with-stl-functions",level:2},{value:"Variations of Binary Search",id:"variations-of-binary-search",level:2},{value:"1. Finding First Occurrence",id:"1-finding-first-occurrence",level:3},{value:"2. Finding Last Occurrence",id:"2-finding-last-occurrence",level:3},{value:"3. Count Occurrences using Binary Search",id:"3-count-occurrences-using-binary-search",level:3},{value:"Advanced Binary Search Problems",id:"advanced-binary-search-problems",level:2},{value:"1. Find Floor and Ceil",id:"1-find-floor-and-ceil",level:3},{value:"2. Find Minimum in Rotated Sorted Array",id:"2-find-minimum-in-rotated-sorted-array",level:3},{value:"3. Search in Rotated Sorted Array",id:"3-search-in-rotated-sorted-array",level:3},{value:"Binary Search on Answer (Predicate-based)",id:"binary-search-on-answer-predicate-based",level:2},{value:"1. Find Square Root with Precision",id:"1-find-square-root-with-precision",level:3},{value:"2. Find Peak Element",id:"2-find-peak-element",level:3},{value:"Binary Search in 2D Arrays (Matrix)",id:"binary-search-in-2d-arrays-matrix",level:2},{value:"Performance Analysis",id:"performance-analysis-1",level:2},{value:"Common Interview Questions",id:"common-interview-questions-3",level:2},{value:"1. Implement Binary Search",id:"1-implement-binary-search",level:3},{value:"2. Find First and Last Position of Element",id:"2-find-first-and-last-position-of-element",level:3},{value:"3. Find Minimum in Rotated Sorted Array",id:"3-find-minimum-in-rotated-sorted-array",level:3},{value:"4. Find Peak Element",id:"4-find-peak-element",level:3},{value:"5. Search in Infinite Sorted Array",id:"5-search-in-infinite-sorted-array",level:3},{value:"Advantages and Disadvantages",id:"advantages-and-disadvantages-3",level:2},{value:"Advantages:",id:"advantages-3",level:3},{value:"Disadvantages:",id:"disadvantages-3",level:3},{value:"When to Use Binary Search",id:"when-to-use-binary-search",level:2},{value:"Summary",id:"summary-4",level:2}];function d(n){const e={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.header,{children:(0,t.jsx)(e.h1,{id:"arrays",children:"Arrays"})}),"\n",(0,t.jsx)(e.h2,{id:"arrays-in-c",children:"Arrays in C++"}),"\n",(0,t.jsx)(e.p,{children:"An array is a collection of elements of the same type stored in contiguous memory locations."}),"\n",(0,t.jsx)(e.h3,{id:"declaration-and-initialization",children:"Declaration and Initialization"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\nusing namespace std;\n\nint main() {\n    // Different ways to declare and initialize arrays\n    int arr1[5];                    // Declaration without initialization\n    int arr2[5] = {1, 2, 3, 4, 5};  // Declaration with initialization\n    int arr3[] = {1, 2, 3, 4, 5};   // Size determined by initializer\n    int arr4[5] = {1, 2};           // Remaining elements initialized to 0\n    \n    // Accessing array elements\n    cout << "Element at index 2: " << arr2[2] << endl;  // Output: 3\n    \n    // Modifying array elements\n    arr2[2] = 10;\n    cout << "Modified element: " << arr2[2] << endl;    // Output: 10\n    \n    return 0;\n}\n'})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Output:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"Element at index 2: 3\nModified element: 10\n"})}),"\n",(0,t.jsx)(e.h3,{id:"array-traversal-and-basic-operations",children:"Array Traversal and Basic Operations"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\nusing namespace std;\n\nint main() {\n    int numbers[] = {10, 20, 30, 40, 50};\n    int size = sizeof(numbers) / sizeof(numbers[0]);\n    \n    cout << "Array elements: ";\n    // Traversing array using for loop\n    for(int i = 0; i < size; i++) {\n        cout << numbers[i] << " ";\n    }\n    cout << endl;\n    \n    // Finding sum of all elements\n    int sum = 0;\n    for(int i = 0; i < size; i++) {\n        sum += numbers[i];\n    }\n    cout << "Sum of elements: " << sum << endl;\n    \n    // Finding maximum element\n    int maxElement = numbers[0];\n    for(int i = 1; i < size; i++) {\n        if(numbers[i] > maxElement) {\n            maxElement = numbers[i];\n        }\n    }\n    cout << "Maximum element: " << maxElement << endl;\n    \n    return 0;\n}\n'})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Output:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"Array elements: 10 20 30 40 50\nSum of elements: 150\nMaximum element: 50\n"})}),"\n",(0,t.jsx)(e.h3,{id:"multi-dimensional-arrays",children:"Multi-dimensional Arrays"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\nusing namespace std;\n\nint main() {\n    // 2D Array (Matrix)\n    int matrix[3][3] = {\n        {1, 2, 3},\n        {4, 5, 6},\n        {7, 8, 9}\n    };\n    \n    cout << "2D Array Elements:" << endl;\n    for(int i = 0; i < 3; i++) {\n        for(int j = 0; j < 3; j++) {\n            cout << matrix[i][j] << " ";\n        }\n        cout << endl;\n    }\n    \n    return 0;\n}\n'})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Output:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"2D Array Elements:\n1 2 3\n4 5 6\n7 8 9\n"})}),"\n",(0,t.jsx)(e.h2,{id:"dsa-bubble-sort",children:"DSA Bubble Sort"}),"\n",(0,t.jsx)(e.p,{children:"Bubble Sort is a simple comparison-based sorting algorithm that repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order."}),"\n",(0,t.jsx)(e.h3,{id:"how-bubble-sort-works",children:"How Bubble Sort Works"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"First Pass"}),": Compare adjacent elements from start to end"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Swap if needed"}),": If current element > next element, swap them"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Repeat"}),": Continue for n-1 passes"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Optimization"}),": If no swaps in a pass, array is sorted"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"basic-implementation",children:"Basic Implementation"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\nusing namespace std;\n\nvoid bubbleSort(int arr[], int n) {\n    // Outer loop for passes\n    for(int i = 0; i < n-1; i++) {\n        // Inner loop for comparisons\n        for(int j = 0; j < n-i-1; j++) {\n            // Compare adjacent elements\n            if(arr[j] > arr[j+1]) {\n                // Swap if wrong order\n                int temp = arr[j];\n                arr[j] = arr[j+1];\n                arr[j+1] = temp;\n            }\n        }\n    }\n}\n\nvoid printArray(int arr[], int n) {\n    for(int i = 0; i < n; i++) {\n        cout << arr[i] << " ";\n    }\n    cout << endl;\n}\n\nint main() {\n    int arr[] = {64, 34, 25, 12, 22, 11, 90};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    \n    cout << "Original array: ";\n    printArray(arr, n);\n    \n    bubbleSort(arr, n);\n    \n    cout << "Sorted array: ";\n    printArray(arr, n);\n    \n    return 0;\n}\n'})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Output:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"Original array: 64 34 25 12 22 11 90 \nSorted array: 11 12 22 25 34 64 90\n"})}),"\n",(0,t.jsx)(e.h3,{id:"optimized-bubble-sort",children:"Optimized Bubble Sort"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\nusing namespace std;\n\nvoid optimizedBubbleSort(int arr[], int n) {\n    bool swapped;\n    \n    for(int i = 0; i < n-1; i++) {\n        swapped = false;\n        \n        for(int j = 0; j < n-i-1; j++) {\n            if(arr[j] > arr[j+1]) {\n                // Swap elements\n                int temp = arr[j];\n                arr[j] = arr[j+1];\n                arr[j+1] = temp;\n                swapped = true;\n            }\n        }\n        \n        // If no swaps occurred, array is sorted\n        if(!swapped) {\n            cout << "Array sorted after " << i+1 << " passes" << endl;\n            break;\n        }\n    }\n}\n\nint main() {\n    int arr[] = {5, 1, 4, 2, 8};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    \n    cout << "Original array: ";\n    for(int i = 0; i < n; i++) {\n        cout << arr[i] << " ";\n    }\n    cout << endl;\n    \n    optimizedBubbleSort(arr, n);\n    \n    cout << "Sorted array: ";\n    for(int i = 0; i < n; i++) {\n        cout << arr[i] << " ";\n    }\n    cout << endl;\n    \n    return 0;\n}\n'})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Output:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"Original array: 5 1 4 2 8 \nArray sorted after 4 passes\nSorted array: 1 2 4 5 8\n"})}),"\n",(0,t.jsx)(e.h3,{id:"bubble-sort-complexity-analysis",children:"Bubble Sort Complexity Analysis"}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Time Complexity:"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Best Case"}),": O(n) - When array is already sorted"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Average Case"}),": O(n\xb2)"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Worst Case"}),": O(n\xb2) - When array is reverse sorted"]}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Space Complexity:"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"O(1) - In-place sorting algorithm"}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Advantages:"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Simple to understand and implement"}),"\n",(0,t.jsx)(e.li,{children:"Stable sorting algorithm"}),"\n",(0,t.jsx)(e.li,{children:"In-place algorithm (no extra memory needed)"}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Disadvantages:"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Too slow for large datasets"}),"\n",(0,t.jsx)(e.li,{children:"Not suitable for real-world applications"}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"visual-example-of-bubble-sort",children:"Visual Example of Bubble Sort"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"Pass 1:\n[5, 3, 8, 4, 2] \u2192 Compare 5 and 3, swap\n[3, 5, 8, 4, 2] \u2192 Compare 5 and 8, no swap\n[3, 5, 8, 4, 2] \u2192 Compare 8 and 4, swap\n[3, 5, 4, 8, 2] \u2192 Compare 8 and 2, swap\n[3, 5, 4, 2, 8] \u2192 Largest element (8) at end\n\nPass 2:\n[3, 5, 4, 2, 8] \u2192 Compare 3 and 5, no swap\n[3, 5, 4, 2, 8] \u2192 Compare 5 and 4, swap\n[3, 4, 5, 2, 8] \u2192 Compare 5 and 2, swap\n[3, 4, 2, 5, 8] \u2192 Second largest (5) in position\n\nContinue until sorted...\n"})}),"\n",(0,t.jsx)(e.h2,{id:"dsa-selection-sort",children:"DSA Selection Sort"}),"\n",(0,t.jsx)(e.p,{children:"Selection Sort is an in-place comparison sorting algorithm that divides the input list into two parts: sorted and unsorted. It repeatedly selects the smallest element from the unsorted part and moves it to the sorted part."}),"\n",(0,t.jsx)(e.h3,{id:"how-selection-sort-works",children:"How Selection Sort Works"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsx)(e.li,{children:"Find the minimum element in the unsorted array"}),"\n",(0,t.jsx)(e.li,{children:"Swap it with the first element of the unsorted part"}),"\n",(0,t.jsx)(e.li,{children:"Move the boundary between sorted and unsorted parts one element to the right"}),"\n",(0,t.jsx)(e.li,{children:"Repeat until the entire array is sorted"}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"basic-implementation-1",children:"Basic Implementation"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\nusing namespace std;\n\nvoid selectionSort(int arr[], int n) {\n    for(int i = 0; i < n-1; i++) {\n        // Assume minimum is at current position\n        int minIndex = i;\n        \n        // Find minimum element in unsorted part\n        for(int j = i+1; j < n; j++) {\n            if(arr[j] < arr[minIndex]) {\n                minIndex = j;\n            }\n        }\n        \n        // Swap minimum element with first element of unsorted part\n        if(minIndex != i) {\n            int temp = arr[i];\n            arr[i] = arr[minIndex];\n            arr[minIndex] = temp;\n        }\n        \n        // Display array after each pass\n        cout << "Pass " << i+1 << ": ";\n        for(int k = 0; k < n; k++) {\n            cout << arr[k] << " ";\n        }\n        cout << endl;\n    }\n}\n\nint main() {\n    int arr[] = {64, 25, 12, 22, 11};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    \n    cout << "Original array: ";\n    for(int i = 0; i < n; i++) {\n        cout << arr[i] << " ";\n    }\n    cout << endl << endl;\n    \n    selectionSort(arr, n);\n    \n    cout << "\\nSorted array: ";\n    for(int i = 0; i < n; i++) {\n        cout << arr[i] << " ";\n    }\n    cout << endl;\n    \n    return 0;\n}\n'})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Output:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"Original array: 64 25 12 22 11 \n\nPass 1: 11 25 12 22 64 \nPass 2: 11 12 25 22 64 \nPass 3: 11 12 22 25 64 \nPass 4: 11 12 22 25 64 \n\nSorted array: 11 12 22 25 64\n"})}),"\n",(0,t.jsx)(e.h3,{id:"selection-sort-with-visualization",children:"Selection Sort with Visualization"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\nusing namespace std;\n\nvoid selectionSortWithDetails(int arr[], int n) {\n    cout << "\\n=== Selection Sort Process ===" << endl;\n    \n    for(int i = 0; i < n-1; i++) {\n        cout << "\\nPass " << i+1 << ":" << endl;\n        cout << "Looking for minimum in unsorted part [" << i << " to " << n-1 << "]" << endl;\n        \n        int minIndex = i;\n        \n        // Find minimum\n        for(int j = i+1; j < n; j++) {\n            cout << "  Comparing arr[" << minIndex << "]=" << arr[minIndex] \n                 << " with arr[" << j << "]=" << arr[j];\n            \n            if(arr[j] < arr[minIndex]) {\n                minIndex = j;\n                cout << " -> New minimum found!" << endl;\n            } else {\n                cout << " -> No change" << endl;\n            }\n        }\n        \n        cout << "Minimum element: arr[" << minIndex << "]=" << arr[minIndex] << endl;\n        \n        // Swap if needed\n        if(minIndex != i) {\n            cout << "Swapping arr[" << i << "]=" << arr[i] \n                 << " with arr[" << minIndex << "]=" << arr[minIndex] << endl;\n            \n            int temp = arr[i];\n            arr[i] = arr[minIndex];\n            arr[minIndex] = temp;\n        }\n        \n        cout << "Array after pass " << i+1 << ": ";\n        for(int k = 0; k < n; k++) {\n            if(k < i+1) cout << "[" << arr[k] << "] ";  // Sorted part\n            else cout << arr[k] << " ";                 // Unsorted part\n        }\n        cout << endl;\n    }\n}\n\nint main() {\n    int arr[] = {29, 10, 14, 37, 13};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    \n    cout << "Original array: ";\n    for(int i = 0; i < n; i++) {\n        cout << arr[i] << " ";\n    }\n    \n    selectionSortWithDetails(arr, n);\n    \n    cout << "\\nFinal sorted array: ";\n    for(int i = 0; i < n; i++) {\n        cout << arr[i] << " ";\n    }\n    cout << endl;\n    \n    return 0;\n}\n'})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Output:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"Original array: 29 10 14 37 13 \n\n=== Selection Sort Process ===\n\nPass 1:\nLooking for minimum in unsorted part [0 to 4]\n  Comparing arr[0]=29 with arr[1]=10 -> New minimum found!\n  Comparing arr[1]=10 with arr[2]=14 -> No change\n  Comparing arr[1]=10 with arr[3]=37 -> No change\n  Comparing arr[1]=10 with arr[4]=13 -> No change\nMinimum element: arr[1]=10\nSwapping arr[0]=29 with arr[1]=10\nArray after pass 1: [10] 29 14 37 13 \n\nPass 2:\nLooking for minimum in unsorted part [1 to 4]\n  Comparing arr[1]=29 with arr[2]=14 -> New minimum found!\n  Comparing arr[2]=14 with arr[3]=37 -> No change\n  Comparing arr[2]=14 with arr[4]=13 -> New minimum found!\nMinimum element: arr[4]=13\nSwapping arr[1]=29 with arr[4]=13\nArray after pass 2: [10] [13] 14 37 29 \n\n... (continued)\n"})}),"\n",(0,t.jsx)(e.h3,{id:"selection-sort-complexity-analysis",children:"Selection Sort Complexity Analysis"}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Time Complexity:"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Best Case"}),": O(n\xb2) - Still needs to compare all elements"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Average Case"}),": O(n\xb2)"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Worst Case"}),": O(n\xb2)"]}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Space Complexity:"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"O(1) - In-place sorting algorithm"}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Number of Comparisons:"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Always makes n(n-1)/2 comparisons"}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Number of Swaps:"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Maximum n-1 swaps (minimum data movement)"}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Advantages:"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Simple to implement"}),"\n",(0,t.jsx)(e.li,{children:"Performs well on small lists"}),"\n",(0,t.jsx)(e.li,{children:"Memory efficient (in-place)"}),"\n",(0,t.jsx)(e.li,{children:"Makes minimum number of swaps"}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Disadvantages:"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"O(n\xb2) time complexity makes it inefficient for large lists"}),"\n",(0,t.jsx)(e.li,{children:"Not stable by default (can be made stable)"}),"\n",(0,t.jsx)(e.li,{children:"Not adaptive (doesn't take advantage of existing order)"}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"stability-in-selection-sort",children:"Stability in Selection Sort"}),"\n",(0,t.jsxs)(e.p,{children:["By default, Selection Sort is ",(0,t.jsx)(e.strong,{children:"not stable"})," because it swaps non-adjacent elements. However, we can implement a stable version:"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\nusing namespace std;\n\nvoid stableSelectionSort(int arr[], int n) {\n    for(int i = 0; i < n-1; i++) {\n        int minIndex = i;\n        \n        // Find minimum element\n        for(int j = i+1; j < n; j++) {\n            if(arr[j] < arr[minIndex]) {\n                minIndex = j;\n            }\n        }\n        \n        // Instead of swapping, shift elements\n        int minValue = arr[minIndex];\n        for(int k = minIndex; k > i; k--) {\n            arr[k] = arr[k-1];\n        }\n        arr[i] = minValue;\n    }\n}\n\nint main() {\n    // Array with duplicate values to test stability\n    int arr[] = {4, 2, 3, 4, 1};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    \n    cout << "Original array: ";\n    for(int i = 0; i < n; i++) {\n        cout << "(" << arr[i] << ") ";\n    }\n    cout << endl;\n    \n    stableSelectionSort(arr, n);\n    \n    cout << "Sorted array (stable): ";\n    for(int i = 0; i < n; i++) {\n        cout << "(" << arr[i] << ") ";\n    }\n    cout << endl;\n    \n    return 0;\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"when-to-use-selection-sort",children:"When to Use Selection Sort"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Small datasets"})," where simplicity is more important than efficiency"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Memory-constrained environments"})," due to O(1) space complexity"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"When swapping is expensive"})," compared to comparisons"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Educational purposes"})," to understand sorting concepts"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"comparison-with-other-sorting-algorithms",children:"Comparison with Other Sorting Algorithms"}),"\n",(0,t.jsxs)(e.table,{children:[(0,t.jsx)(e.thead,{children:(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.th,{children:"Algorithm"}),(0,t.jsx)(e.th,{children:"Time Complexity"}),(0,t.jsx)(e.th,{children:"Space Complexity"}),(0,t.jsx)(e.th,{children:"Stable"}),(0,t.jsx)(e.th,{children:"In-place"})]})}),(0,t.jsxs)(e.tbody,{children:[(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:"Bubble Sort"}),(0,t.jsx)(e.td,{children:"O(n\xb2)"}),(0,t.jsx)(e.td,{children:"O(1)"}),(0,t.jsx)(e.td,{children:"Yes"}),(0,t.jsx)(e.td,{children:"Yes"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:(0,t.jsx)(e.strong,{children:"Selection Sort"})}),(0,t.jsx)(e.td,{children:"O(n\xb2)"}),(0,t.jsx)(e.td,{children:"O(1)"}),(0,t.jsx)(e.td,{children:"No*"}),(0,t.jsx)(e.td,{children:"Yes"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:"Insertion Sort"}),(0,t.jsx)(e.td,{children:"O(n\xb2)"}),(0,t.jsx)(e.td,{children:"O(1)"}),(0,t.jsx)(e.td,{children:"Yes"}),(0,t.jsx)(e.td,{children:"Yes"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:"Merge Sort"}),(0,t.jsx)(e.td,{children:"O(n log n)"}),(0,t.jsx)(e.td,{children:"O(n)"}),(0,t.jsx)(e.td,{children:"Yes"}),(0,t.jsx)(e.td,{children:"No"})]})]})]}),"\n",(0,t.jsx)(e.p,{children:"*Can be made stable with modifications"}),"\n",(0,t.jsx)(e.h2,{id:"dsa-insertion-sort",children:"DSA Insertion Sort"}),"\n",(0,t.jsx)(e.p,{children:"Insertion Sort is a simple, efficient sorting algorithm that builds the final sorted array one item at a time. It's much like sorting playing cards in your hands."}),"\n",(0,t.jsx)(e.h3,{id:"how-insertion-sort-works",children:"How Insertion Sort Works"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsx)(e.li,{children:"Start with the second element (consider first element as sorted)"}),"\n",(0,t.jsx)(e.li,{children:"Compare current element with elements in the sorted portion"}),"\n",(0,t.jsx)(e.li,{children:"Shift all larger elements one position to the right"}),"\n",(0,t.jsx)(e.li,{children:"Insert current element at the correct position"}),"\n",(0,t.jsx)(e.li,{children:"Repeat for all elements"}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"basic-implementation-2",children:"Basic Implementation"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\nusing namespace std;\n\nvoid insertionSort(int arr[], int n) {\n    for(int i = 1; i < n; i++) {\n        int key = arr[i];  // Current element to be inserted\n        int j = i - 1;\n        \n        // Move elements greater than key one position ahead\n        while(j >= 0 && arr[j] > key) {\n            arr[j + 1] = arr[j];\n            j--;\n        }\n        \n        // Insert key at correct position\n        arr[j + 1] = key;\n        \n        // Display array after each iteration\n        cout << "After iteration " << i << ": ";\n        for(int k = 0; k < n; k++) {\n            cout << arr[k] << " ";\n        }\n        cout << endl;\n    }\n}\n\nint main() {\n    int arr[] = {12, 11, 13, 5, 6};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    \n    cout << "Original array: ";\n    for(int i = 0; i < n; i++) {\n        cout << arr[i] << " ";\n    }\n    cout << endl << endl;\n    \n    insertionSort(arr, n);\n    \n    cout << "\\nSorted array: ";\n    for(int i = 0; i < n; i++) {\n        cout << arr[i] << " ";\n    }\n    cout << endl;\n    \n    return 0;\n}\n'})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Output:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"Original array: 12 11 13 5 6 \n\nAfter iteration 1: 11 12 13 5 6 \nAfter iteration 2: 11 12 13 5 6 \nAfter iteration 3: 5 11 12 13 6 \nAfter iteration 4: 5 6 11 12 13 \n\nSorted array: 5 6 11 12 13\n"})}),"\n",(0,t.jsx)(e.h3,{id:"visual-step-by-step-process",children:"Visual Step-by-Step Process"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\nusing namespace std;\n\nvoid insertionSortVisual(int arr[], int n) {\n    cout << "\\n=== Insertion Sort Process ===" << endl;\n    \n    for(int i = 1; i < n; i++) {\n        int key = arr[i];\n        int j = i - 1;\n        \n        cout << "\\nIteration " << i << ": Key = " << key << endl;\n        cout << "Sorted portion: ";\n        for(int k = 0; k < i; k++) {\n            cout << "[" << arr[k] << "] ";\n        }\n        cout << endl;\n        \n        cout << "Comparing key with sorted elements (right to left):" << endl;\n        \n        // Shift elements greater than key\n        while(j >= 0 && arr[j] > key) {\n            cout << "  " << arr[j] << " > " << key \n                 << " -> Shift " << arr[j] << " to position " << j+1 << endl;\n            arr[j + 1] = arr[j];\n            j--;\n        }\n        \n        // Insert key\n        arr[j + 1] = key;\n        cout << "Insert " << key << " at position " << j+1 << endl;\n        \n        cout << "Array after iteration: ";\n        for(int k = 0; k < n; k++) {\n            if(k <= i) cout << "[" << arr[k] << "] ";\n            else cout << arr[k] << " ";\n        }\n        cout << endl;\n    }\n}\n\nint main() {\n    int arr[] = {8, 3, 5, 1, 4};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    \n    cout << "Original array: ";\n    for(int i = 0; i < n; i++) {\n        cout << arr[i] << " ";\n    }\n    \n    insertionSortVisual(arr, n);\n    \n    cout << "\\nFinal sorted array: ";\n    for(int i = 0; i < n; i++) {\n        cout << arr[i] << " ";\n    }\n    cout << endl;\n    \n    return 0;\n}\n'})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Output:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"Original array: 8 3 5 1 4 \n\n=== Insertion Sort Process ===\n\nIteration 1: Key = 3\nSorted portion: [8] \nComparing key with sorted elements (right to left):\n  8 > 3 -> Shift 8 to position 1\nInsert 3 at position 0\nArray after iteration: [3] [8] 5 1 4 \n\nIteration 2: Key = 5\nSorted portion: [3] [8] \nComparing key with sorted elements (right to left):\n  8 > 5 -> Shift 8 to position 2\nInsert 5 at position 1\nArray after iteration: [3] [5] [8] 1 4 \n\n... (continued)\n"})}),"\n",(0,t.jsx)(e.h3,{id:"binary-insertion-sort-optimized",children:"Binary Insertion Sort (Optimized)"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\nusing namespace std;\n\n// Binary search to find insertion position\nint binarySearch(int arr[], int key, int low, int high) {\n    while(low <= high) {\n        int mid = low + (high - low) / 2;\n        \n        if(key == arr[mid])\n            return mid + 1;\n        else if(key > arr[mid])\n            low = mid + 1;\n        else\n            high = mid - 1;\n    }\n    return low;\n}\n\nvoid binaryInsertionSort(int arr[], int n) {\n    for(int i = 1; i < n; i++) {\n        int key = arr[i];\n        int j = i - 1;\n        \n        // Find position to insert using binary search\n        int pos = binarySearch(arr, key, 0, j);\n        \n        cout << "Element " << key << " should be inserted at position " << pos << endl;\n        \n        // Shift all elements after pos to the right\n        while(j >= pos) {\n            arr[j + 1] = arr[j];\n            j--;\n        }\n        \n        // Insert key at correct position\n        arr[pos] = key;\n        \n        cout << "Array after inserting " << key << ": ";\n        for(int k = 0; k < n; k++) {\n            cout << arr[k] << " ";\n        }\n        cout << endl;\n    }\n}\n\nint main() {\n    int arr[] = {37, 23, 0, 17, 12, 72, 31};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    \n    cout << "Original array: ";\n    for(int i = 0; i < n; i++) {\n        cout << arr[i] << " ";\n    }\n    cout << endl << endl;\n    \n    binaryInsertionSort(arr, n);\n    \n    cout << "\\nSorted array: ";\n    for(int i = 0; i < n; i++) {\n        cout << arr[i] << " ";\n    }\n    cout << endl;\n    \n    return 0;\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"insertion-sort-complexity-analysis",children:"Insertion Sort Complexity Analysis"}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Time Complexity:"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Best Case"}),": O(n) - When array is already sorted"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Average Case"}),": O(n\xb2)"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Worst Case"}),": O(n\xb2) - When array is reverse sorted"]}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Space Complexity:"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"O(1) - In-place sorting algorithm"}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Comparisons:"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Best case: n-1 comparisons"}),"\n",(0,t.jsx)(e.li,{children:"Worst case: n(n-1)/2 comparisons"}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Shifts:"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Same as number of comparisons"}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Advantages:"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Simple implementation"}),"\n",(0,t.jsx)(e.li,{children:"Efficient for small data sets"}),"\n",(0,t.jsx)(e.li,{children:"Adaptive: Efficient for data sets that are already substantially sorted"}),"\n",(0,t.jsx)(e.li,{children:"Stable: Maintains relative order of equal elements"}),"\n",(0,t.jsx)(e.li,{children:"In-place: Requires O(1) additional memory"}),"\n",(0,t.jsx)(e.li,{children:"Online: Can sort a list as it receives it"}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Disadvantages:"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"O(n\xb2) time complexity for average and worst cases"}),"\n",(0,t.jsx)(e.li,{children:"Less efficient on large lists than more advanced algorithms"}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"real-world-applications",children:"Real-world Applications"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstruct Student {\n    string name;\n    int rollNumber;\n    float marks;\n    \n    void display() {\n        cout << name << " (Roll: " << rollNumber << ", Marks: " << marks << ")" << endl;\n    }\n};\n\n// Insertion sort for array of structures\nvoid sortStudentsByMarks(Student students[], int n) {\n    for(int i = 1; i < n; i++) {\n        Student key = students[i];\n        int j = i - 1;\n        \n        // Sort by marks in descending order\n        while(j >= 0 && students[j].marks < key.marks) {\n            students[j + 1] = students[j];\n            j--;\n        }\n        students[j + 1] = key;\n    }\n}\n\nint main() {\n    Student students[] = {\n        {"Alice", 101, 85.5},\n        {"Bob", 102, 92.0},\n        {"Charlie", 103, 78.5},\n        {"David", 104, 88.0},\n        {"Eve", 105, 91.5}\n    };\n    \n    int n = sizeof(students) / sizeof(students[0]);\n    \n    cout << "Students before sorting:" << endl;\n    for(int i = 0; i < n; i++) {\n        students[i].display();\n    }\n    \n    sortStudentsByMarks(students, n);\n    \n    cout << "\\nStudents after sorting by marks (descending):" << endl;\n    for(int i = 0; i < n; i++) {\n        students[i].display();\n    }\n    \n    return 0;\n}\n'})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Output:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"Students before sorting:\nAlice (Roll: 101, Marks: 85.5)\nBob (Roll: 102, Marks: 92)\nCharlie (Roll: 103, Marks: 78.5)\nDavid (Roll: 104, Marks: 88)\nEve (Roll: 105, Marks: 91.5)\n\nStudents after sorting by marks (descending):\nBob (Roll: 102, Marks: 92)\nEve (Roll: 105, Marks: 91.5)\nDavid (Roll: 104, Marks: 88)\nAlice (Roll: 101, Marks: 85.5)\nCharlie (Roll: 103, Marks: 78.5)\n"})}),"\n",(0,t.jsx)(e.h3,{id:"when-to-use-insertion-sort",children:"When to Use Insertion Sort"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Small datasets"})," (typically n < 50)"]}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.strong,{children:"Nearly sorted data"})}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Online algorithms"})," where data comes in stream"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"As the base case for recursive algorithms"})," like QuickSort"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"When memory write is expensive"})," (minimal writes compared to Selection Sort)"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"performance-comparison",children:"Performance Comparison"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <ctime>\n#include <cstdlib>\nusing namespace std;\n\nvoid fillArray(int arr[], int n, int type) {\n    switch(type) {\n        case 0: // Random\n            for(int i = 0; i < n; i++) {\n                arr[i] = rand() % 1000;\n            }\n            break;\n        case 1: // Sorted\n            for(int i = 0; i < n; i++) {\n                arr[i] = i * 10;\n            }\n            break;\n        case 2: // Reverse sorted\n            for(int i = 0; i < n; i++) {\n                arr[i] = (n - i) * 10;\n            }\n            break;\n    }\n}\n\nvoid insertionSort(int arr[], int n) {\n    for(int i = 1; i < n; i++) {\n        int key = arr[i];\n        int j = i - 1;\n        while(j >= 0 && arr[j] > key) {\n            arr[j + 1] = arr[j];\n            j--;\n        }\n        arr[j + 1] = key;\n    }\n}\n\nint main() {\n    srand(time(0));\n    \n    int sizes[] = {100, 1000, 5000};\n    string types[] = {"Random", "Sorted", "Reverse Sorted"};\n    \n    cout << "Insertion Sort Performance Analysis\\n" << endl;\n    cout << "Size\\tType\\t\\tTime (ms)" << endl;\n    cout << "--------------------------------" << endl;\n    \n    for(int size : sizes) {\n        for(int type = 0; type < 3; type++) {\n            int* arr = new int[size];\n            fillArray(arr, size, type);\n            \n            clock_t start = clock();\n            insertionSort(arr, size);\n            clock_t end = clock();\n            \n            double time_taken = double(end - start) / CLOCKS_PER_SEC * 1000;\n            \n            cout << size << "\\t" << types[type] << "\\t\\t" << time_taken << " ms" << endl;\n            \n            delete[] arr;\n        }\n        cout << endl;\n    }\n    \n    return 0;\n}\n'})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Sample Output:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"Insertion Sort Performance Analysis\n\nSize    Type            Time (ms)\n--------------------------------\n100     Random          0.023 ms\n100     Sorted          0.001 ms\n100     Reverse Sorted  0.045 ms\n\n1000    Random          2.341 ms\n1000    Sorted          0.012 ms\n1000    Reverse Sorted  4.892 ms\n\n5000    Random          58.732 ms\n5000    Sorted          0.056 ms\n5000    Reverse Sorted  117.451 ms\n"})}),"\n",(0,t.jsx)(e.p,{children:"This demonstrates Insertion Sort's adaptiveness - it performs much better on already sorted data compared to random or reverse sorted data."}),"\n",(0,t.jsx)(e.h1,{id:"dsa-quick-sort---complete-c-guide",children:"DSA Quick Sort - Complete C++ Guide"}),"\n",(0,t.jsx)(e.h2,{id:"introduction-to-quick-sort",children:"Introduction to Quick Sort"}),"\n",(0,t.jsxs)(e.p,{children:["Quick Sort is a ",(0,t.jsx)(e.strong,{children:"divide-and-conquer"})," algorithm that works by selecting a 'pivot' element and partitioning the array around it. It's one of the most efficient sorting algorithms for average cases."]}),"\n",(0,t.jsx)(e.h3,{id:"key-characteristics",children:"Key Characteristics:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Average case time complexity: O(n log n)"}),"\n",(0,t.jsx)(e.li,{children:"Worst case: O(n\xb2) (rare with good pivot selection)"}),"\n",(0,t.jsx)(e.li,{children:"In-place sorting algorithm"}),"\n",(0,t.jsx)(e.li,{children:"Not stable by default"}),"\n",(0,t.jsx)(e.li,{children:"Recursive algorithm"}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"how-quick-sort-works",children:"How Quick Sort Works"}),"\n",(0,t.jsx)(e.h3,{id:"the-three-step-process",children:"The Three-Step Process:"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Pivot Selection"}),": Choose an element as pivot"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Partitioning"}),": Rearrange array so elements < pivot are on left, elements > pivot are on right"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Recursion"}),": Apply Quick Sort recursively to left and right sub-arrays"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"visual-example",children:"Visual Example:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"Original: [10, 80, 30, 90, 40, 50, 70]\nPivot = 70 (last element)\n\nAfter Partition: [10, 30, 40, 50, 70, 90, 80]\n                \u2191 pivot at correct position\n\nRecursively sort left [10, 30, 40, 50] and right [90, 80]\n"})}),"\n",(0,t.jsx)(e.h2,{id:"basic-quick-sort-implementation",children:"Basic Quick Sort Implementation"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\nusing namespace std;\n\n// Function to swap two elements\nvoid swap(int* a, int* b) {\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\n// Partition function using last element as pivot\nint partition(int arr[], int low, int high) {\n    int pivot = arr[high];  // Choosing last element as pivot\n    int i = low - 1;        // Index of smaller element\n    \n    for(int j = low; j <= high - 1; j++) {\n        // If current element is smaller than or equal to pivot\n        if(arr[j] <= pivot) {\n            i++;  // Increment index of smaller element\n            swap(&arr[i], &arr[j]);\n        }\n    }\n    swap(&arr[i + 1], &arr[high]);\n    return (i + 1);\n}\n\n// Quick Sort function\nvoid quickSort(int arr[], int low, int high) {\n    if(low < high) {\n        // pi is partitioning index, arr[pi] is now at right place\n        int pi = partition(arr, low, high);\n        \n        // Separately sort elements before and after partition\n        quickSort(arr, low, pi - 1);\n        quickSort(arr, pi + 1, high);\n    }\n}\n\n// Function to print array\nvoid printArray(int arr[], int size) {\n    for(int i = 0; i < size; i++) {\n        cout << arr[i] << " ";\n    }\n    cout << endl;\n}\n\nint main() {\n    int arr[] = {10, 7, 8, 9, 1, 5};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    \n    cout << "Original array: ";\n    printArray(arr, n);\n    \n    quickSort(arr, 0, n - 1);\n    \n    cout << "Sorted array: ";\n    printArray(arr, n);\n    \n    return 0;\n}\n'})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Output:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"Original array: 10 7 8 9 1 5 \nSorted array: 1 5 7 8 9 10\n"})}),"\n",(0,t.jsx)(e.h2,{id:"detailed-step-by-step-visualization",children:"Detailed Step-by-Step Visualization"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\nusing namespace std;\n\nint partitionVisual(int arr[], int low, int high, int& step) {\n    int pivot = arr[high];\n    int i = low - 1;\n    \n    cout << "\\nStep " << step++ << ": Partitioning from index " \n         << low << " to " << high << endl;\n    cout << "Pivot element: " << pivot << endl;\n    cout << "Initial array: ";\n    for(int k = low; k <= high; k++) {\n        cout << arr[k] << " ";\n    }\n    cout << endl;\n    \n    for(int j = low; j <= high - 1; j++) {\n        cout << "  Comparing arr[" << j << "]=" << arr[j] \n             << " with pivot=" << pivot;\n        \n        if(arr[j] <= pivot) {\n            i++;\n            cout << " -> Swapping arr[" << i << "]=" << arr[i] \n                 << " with arr[" << j << "]=" << arr[j] << endl;\n            \n            // Swap arr[i] and arr[j]\n            int temp = arr[i];\n            arr[i] = arr[j];\n            arr[j] = temp;\n        } else {\n            cout << " -> No swap needed" << endl;\n        }\n    }\n    \n    // Swap arr[i+1] and arr[high] (pivot)\n    cout << "  Final swap: Moving pivot to position " << i+1 << endl;\n    int temp = arr[i + 1];\n    arr[i + 1] = arr[high];\n    arr[high] = temp;\n    \n    cout << "After partition: ";\n    for(int k = low; k <= high; k++) {\n        if(k == i + 1) cout << "[" << arr[k] << "] ";\n        else cout << arr[k] << " ";\n    }\n    cout << endl;\n    \n    return (i + 1);\n}\n\nvoid quickSortVisual(int arr[], int low, int high, int& step) {\n    if(low < high) {\n        int pi = partitionVisual(arr, low, high, step);\n        \n        cout << "\\nRecursively sorting left subarray [" \n             << low << " to " << pi-1 << "] and right subarray [" \n             << pi+1 << " to " << high << "]" << endl;\n        \n        quickSortVisual(arr, low, pi - 1, step);\n        quickSortVisual(arr, pi + 1, high, step);\n    }\n}\n\nint main() {\n    int arr[] = {64, 25, 12, 22, 11};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    int step = 1;\n    \n    cout << "=== Quick Sort Step-by-Step Demonstration ===" << endl;\n    cout << "Original array: ";\n    for(int i = 0; i < n; i++) {\n        cout << arr[i] << " ";\n    }\n    cout << endl;\n    \n    quickSortVisual(arr, 0, n-1, step);\n    \n    cout << "\\nFinal sorted array: ";\n    for(int i = 0; i < n; i++) {\n        cout << arr[i] << " ";\n    }\n    cout << endl;\n    \n    return 0;\n}\n'})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Output:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"=== Quick Sort Step-by-Step Demonstration ===\nOriginal array: 64 25 12 22 11 \n\nStep 1: Partitioning from index 0 to 4\nPivot element: 11\nInitial array: 64 25 12 22 11 \n  Comparing arr[0]=64 with pivot=11 -> No swap needed\n  Comparing arr[1]=25 with pivot=11 -> No swap needed\n  Comparing arr[2]=12 with pivot=11 -> No swap needed\n  Comparing arr[3]=22 with pivot=11 -> No swap needed\n  Final swap: Moving pivot to position 0\nAfter partition: [11] 25 12 22 64 \n\nRecursively sorting left subarray [0 to -1] and right subarray [1 to 4]\n\nStep 2: Partitioning from index 1 to 4\nPivot element: 64\nInitial array: 25 12 22 64 \n  Comparing arr[1]=25 with pivot=64 -> Swapping arr[1]=25 with arr[1]=25\n  Comparing arr[2]=12 with pivot=64 -> Swapping arr[2]=12 with arr[2]=12\n  Comparing arr[3]=22 with pivot=64 -> Swapping arr[3]=22 with arr[3]=22\n  Final swap: Moving pivot to position 4\nAfter partition: 25 12 22 [64] \n\n... (continued)\n"})}),"\n",(0,t.jsx)(e.h2,{id:"different-pivot-selection-strategies",children:"Different Pivot Selection Strategies"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n// 1. First element as pivot\nint partitionFirst(int arr[], int low, int high) {\n    int pivot = arr[low];\n    int i = low + 1;\n    \n    for(int j = low + 1; j <= high; j++) {\n        if(arr[j] < pivot) {\n            swap(arr[i], arr[j]);\n            i++;\n        }\n    }\n    swap(arr[low], arr[i-1]);\n    return i-1;\n}\n\n// 2. Last element as pivot (Standard)\nint partitionLast(int arr[], int low, int high) {\n    int pivot = arr[high];\n    int i = low - 1;\n    \n    for(int j = low; j <= high - 1; j++) {\n        if(arr[j] <= pivot) {\n            i++;\n            swap(arr[i], arr[j]);\n        }\n    }\n    swap(arr[i + 1], arr[high]);\n    return (i + 1);\n}\n\n// 3. Middle element as pivot\nint partitionMiddle(int arr[], int low, int high) {\n    int mid = low + (high - low) / 2;\n    int pivot = arr[mid];\n    \n    // Move pivot to end\n    swap(arr[mid], arr[high]);\n    \n    int i = low - 1;\n    for(int j = low; j <= high - 1; j++) {\n        if(arr[j] <= pivot) {\n            i++;\n            swap(arr[i], arr[j]);\n        }\n    }\n    swap(arr[i + 1], arr[high]);\n    return (i + 1);\n}\n\n// 4. Random pivot (Better for avoiding worst case)\nint partitionRandom(int arr[], int low, int high) {\n    // Generate random index between low and high\n    int random = low + rand() % (high - low + 1);\n    \n    // Move random pivot to end\n    swap(arr[random], arr[high]);\n    \n    return partitionLast(arr, low, high);\n}\n\n// 5. Median of Three (Best for real-world data)\nint medianOfThree(int arr[], int low, int high) {\n    int mid = low + (high - low) / 2;\n    \n    // Sort low, mid, high\n    if(arr[high] < arr[low])\n        swap(arr[high], arr[low]);\n    if(arr[mid] < arr[low])\n        swap(arr[mid], arr[low]);\n    if(arr[high] < arr[mid])\n        swap(arr[high], arr[mid]);\n    \n    // Move median to high position\n    swap(arr[mid], arr[high]);\n    \n    return partitionLast(arr, low, high);\n}\n\nvoid testPivotStrategies(int arr[], int n, string strategy) {\n    cout << "\\nTesting " << strategy << " pivot:" << endl;\n    cout << "Original: ";\n    for(int i = 0; i < n; i++) cout << arr[i] << " ";\n    cout << endl;\n    \n    // Create copy for testing\n    int* testArr = new int[n];\n    copy(arr, arr + n, testArr);\n    \n    // Apply quick sort with specific pivot\n    if(strategy == "First") partitionFirst(testArr, 0, n-1);\n    else if(strategy == "Last") partitionLast(testArr, 0, n-1);\n    else if(strategy == "Middle") partitionMiddle(testArr, 0, n-1);\n    else if(strategy == "Random") partitionRandom(testArr, 0, n-1);\n    else if(strategy == "Median") medianOfThree(testArr, 0, n-1);\n    \n    cout << "After partition: ";\n    for(int i = 0; i < n; i++) cout << testArr[i] << " ";\n    cout << endl;\n    \n    delete[] testArr;\n}\n\nint main() {\n    srand(time(0));\n    \n    int arr[] = {9, 7, 5, 11, 12, 2, 14, 3, 10, 6};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    \n    cout << "=== Pivot Selection Strategies Comparison ===" << endl;\n    \n    testPivotStrategies(arr, n, "First");\n    testPivotStrategies(arr, n, "Last");\n    testPivotStrategies(arr, n, "Middle");\n    testPivotStrategies(arr, n, "Random");\n    testPivotStrategies(arr, n, "Median");\n    \n    return 0;\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"iterative-quick-sort-implementation",children:"Iterative Quick Sort Implementation"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <stack>\nusing namespace std;\n\n// Iterative Quick Sort using stack\nvoid iterativeQuickSort(int arr[], int low, int high) {\n    // Create a stack\n    stack<int> s;\n    \n    // Push initial values\n    s.push(low);\n    s.push(high);\n    \n    while(!s.empty()) {\n        // Pop high and low\n        high = s.top();\n        s.pop();\n        low = s.top();\n        s.pop();\n        \n        // Partition the array\n        int pivot = arr[high];\n        int i = low - 1;\n        \n        for(int j = low; j <= high - 1; j++) {\n            if(arr[j] <= pivot) {\n                i++;\n                swap(arr[i], arr[j]);\n            }\n        }\n        swap(arr[i + 1], arr[high]);\n        int pi = i + 1;\n        \n        // Push left side to stack if there are elements\n        if(pi - 1 > low) {\n            s.push(low);\n            s.push(pi - 1);\n        }\n        \n        // Push right side to stack if there are elements\n        if(pi + 1 < high) {\n            s.push(pi + 1);\n            s.push(high);\n        }\n    }\n}\n\nint main() {\n    int arr[] = {4, 3, 5, 2, 1, 3, 2, 3};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    \n    cout << "Original array: ";\n    for(int i = 0; i < n; i++) {\n        cout << arr[i] << " ";\n    }\n    cout << endl;\n    \n    iterativeQuickSort(arr, 0, n-1);\n    \n    cout << "Sorted array (iterative): ";\n    for(int i = 0; i < n; i++) {\n        cout << arr[i] << " ";\n    }\n    cout << endl;\n    \n    return 0;\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"quick-sort-complexity-analysis",children:"Quick Sort Complexity Analysis"}),"\n",(0,t.jsx)(e.h3,{id:"time-complexity",children:"Time Complexity:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Best Case"}),": O(n log n) - When pivot divides array into equal halves"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Average Case"}),": O(n log n)"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Worst Case"}),": O(n\xb2) - When pivot is smallest or largest element (sorted/reverse sorted arrays)"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"space-complexity",children:"Space Complexity:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Best Case"}),": O(log n) - Recursion stack depth"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Worst Case"}),": O(n) - In case of skewed recursion"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"mathematical-analysis",children:"Mathematical Analysis:"}),"\n",(0,t.jsx)(e.p,{children:"For average case:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"T(n) = 2T(n/2) + O(n)\nUsing Master Theorem: T(n) = O(n log n)\n"})}),"\n",(0,t.jsx)(e.h2,{id:"optimizations-and-improvements",children:"Optimizations and Improvements"}),"\n",(0,t.jsx)(e.h3,{id:"1-tail-call-optimization",children:"1. Tail Call Optimization"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:"// Optimized Quick Sort with tail recursion elimination\nvoid optimizedQuickSort(int arr[], int low, int high) {\n    while(low < high) {\n        int pi = partition(arr, low, high);\n        \n        // Always sort the smaller part first\n        if(pi - low < high - pi) {\n            optimizedQuickSort(arr, low, pi - 1);\n            low = pi + 1;\n        } else {\n            optimizedQuickSort(arr, pi + 1, high);\n            high = pi - 1;\n        }\n    }\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"2-insertion-sort-for-small-arrays",children:"2. Insertion Sort for Small Arrays"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:"void hybridQuickSort(int arr[], int low, int high) {\n    const int THRESHOLD = 10;\n    \n    while(low < high) {\n        // Use insertion sort for small subarrays\n        if(high - low < THRESHOLD) {\n            insertionSort(arr, low, high);\n            break;\n        }\n        \n        int pi = partition(arr, low, high);\n        \n        // Tail call optimization\n        if(pi - low < high - pi) {\n            hybridQuickSort(arr, low, pi - 1);\n            low = pi + 1;\n        } else {\n            hybridQuickSort(arr, pi + 1, high);\n            high = pi - 1;\n        }\n    }\n}\n\nvoid insertionSort(int arr[], int low, int high) {\n    for(int i = low + 1; i <= high; i++) {\n        int key = arr[i];\n        int j = i - 1;\n        \n        while(j >= low && arr[j] > key) {\n            arr[j + 1] = arr[j];\n            j--;\n        }\n        arr[j + 1] = key;\n    }\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"3-three-way-partitioning-for-arrays-with-many-duplicates",children:"3. Three-Way Partitioning (for arrays with many duplicates)"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:"void threeWayPartition(int arr[], int low, int high, int& i, int& j) {\n    int pivot = arr[high];\n    int mid = low;\n    \n    while(mid <= high) {\n        if(arr[mid] < pivot) {\n            swap(arr[low], arr[mid]);\n            low++;\n            mid++;\n        } else if(arr[mid] == pivot) {\n            mid++;\n        } else { // arr[mid] > pivot\n            swap(arr[mid], arr[high]);\n            high--;\n        }\n    }\n    \n    i = low - 1;\n    j = mid;\n}\n\nvoid threeWayQuickSort(int arr[], int low, int high) {\n    if(low < high) {\n        int i, j;\n        \n        // Partition array into three parts\n        threeWayPartition(arr, low, high, i, j);\n        \n        // Recursively sort left and right parts\n        threeWayQuickSort(arr, low, i);\n        threeWayQuickSort(arr, j, high);\n    }\n}\n"})}),"\n",(0,t.jsx)(e.h2,{id:"performance-comparison-1",children:"Performance Comparison"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <ctime>\n#include <cstdlib>\n#include <algorithm>\nusing namespace std;\n\nvoid generateArray(int arr[], int n, int type) {\n    switch(type) {\n        case 0: // Random\n            for(int i = 0; i < n; i++) arr[i] = rand() % 10000;\n            break;\n        case 1: // Sorted\n            for(int i = 0; i < n; i++) arr[i] = i;\n            break;\n        case 2: // Reverse sorted\n            for(int i = 0; i < n; i++) arr[i] = n - i;\n            break;\n        case 3: // Many duplicates\n            for(int i = 0; i < n; i++) arr[i] = rand() % 100;\n            break;\n    }\n}\n\nvoid testPerformance() {\n    srand(time(0));\n    \n    int sizes[] = {1000, 10000, 50000, 100000};\n    string types[] = {"Random", "Sorted", "Reverse", "Duplicates"};\n    \n    cout << "\\n=== Quick Sort Performance Analysis ===" << endl;\n    cout << "Size\\tType\\t\\tTime (ms)" << endl;\n    cout << "----------------------------------------" << endl;\n    \n    for(int size : sizes) {\n        for(int type = 0; type < 4; type++) {\n            int* arr = new int[size];\n            int* arrCopy = new int[size];\n            \n            generateArray(arr, size, type);\n            copy(arr, arr + size, arrCopy);\n            \n            clock_t start = clock();\n            \n            // Standard Quick Sort\n            quickSort(arrCopy, 0, size-1);\n            \n            clock_t end = clock();\n            double time_taken = double(end - start) / CLOCKS_PER_SEC * 1000;\n            \n            cout << size << "\\t" << types[type];\n            if(types[type].length() < 8) cout << "\\t";\n            cout << "\\t" << time_taken << " ms" << endl;\n            \n            delete[] arr;\n            delete[] arrCopy;\n        }\n        cout << endl;\n    }\n}\n\nint main() {\n    testPerformance();\n    return 0;\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"applications-of-quick-sort",children:"Applications of Quick Sort"}),"\n",(0,t.jsx)(e.h3,{id:"1-finding-kth-smallestlargest-element",children:"1. Finding Kth Smallest/Largest Element"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\nusing namespace std;\n\n// QuickSelect algorithm to find kth smallest element\nint quickSelect(int arr[], int low, int high, int k) {\n    if(low == high) return arr[low];\n    \n    int pi = partition(arr, low, high);\n    int length = pi - low + 1;\n    \n    if(k == length) {\n        return arr[pi];\n    } else if(k < length) {\n        return quickSelect(arr, low, pi - 1, k);\n    } else {\n        return quickSelect(arr, pi + 1, high, k - length);\n    }\n}\n\nint main() {\n    int arr[] = {7, 10, 4, 3, 20, 15};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    int k = 3;\n    \n    cout << "Array: ";\n    for(int i = 0; i < n; i++) {\n        cout << arr[i] << " ";\n    }\n    cout << endl;\n    \n    int kthSmallest = quickSelect(arr, 0, n-1, k);\n    cout << k << "th smallest element is: " << kthSmallest << endl;\n    \n    return 0;\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"2-sorting-custom-objects",children:"2. Sorting Custom Objects"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nclass Product {\npublic:\n    string name;\n    double price;\n    int quantity;\n    \n    Product(string n, double p, int q) : name(n), price(p), quantity(q) {}\n    \n    void display() {\n        cout << name << " - $" << price << " (Qty: " << quantity << ")" << endl;\n    }\n};\n\n// Partition function for products\nint partitionProducts(vector<Product>& products, int low, int high, bool byPrice = true) {\n    double pivot = byPrice ? products[high].price : products[high].quantity;\n    int i = low - 1;\n    \n    for(int j = low; j <= high - 1; j++) {\n        double current = byPrice ? products[j].price : products[j].quantity;\n        \n        if(current <= pivot) {\n            i++;\n            swap(products[i], products[j]);\n        }\n    }\n    swap(products[i + 1], products[high]);\n    return (i + 1);\n}\n\nvoid quickSortProducts(vector<Product>& products, int low, int high, bool byPrice = true) {\n    if(low < high) {\n        int pi = partitionProducts(products, low, high, byPrice);\n        quickSortProducts(products, low, pi - 1, byPrice);\n        quickSortProducts(products, pi + 1, high, byPrice);\n    }\n}\n\nint main() {\n    vector<Product> products = {\n        Product("Laptop", 999.99, 15),\n        Product("Phone", 699.99, 30),\n        Product("Tablet", 399.99, 25),\n        Product("Monitor", 249.99, 20),\n        Product("Keyboard", 49.99, 50)\n    };\n    \n    cout << "Products sorted by price:" << endl;\n    quickSortProducts(products, 0, products.size()-1, true);\n    for(auto& p : products) p.display();\n    \n    cout << "\\nProducts sorted by quantity:" << endl;\n    quickSortProducts(products, 0, products.size()-1, false);\n    for(auto& p : products) p.display();\n    \n    return 0;\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"advantages-and-disadvantages",children:"Advantages and Disadvantages"}),"\n",(0,t.jsx)(e.h3,{id:"advantages",children:"Advantages:"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Fast"}),": Average case O(n log n) performance"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"In-place"}),": Requires O(log n) extra space for recursion"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Cache-friendly"}),": Good locality of reference"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Parallelizable"}),": Can be easily parallelized"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Adaptive"}),": Performs well on various data distributions"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"disadvantages",children:"Disadvantages:"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Worst-case O(n\xb2)"}),": Can degrade on already sorted data"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Not stable"}),": Doesn't preserve relative order of equal elements"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Recursive"}),": Deep recursion can cause stack overflow"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Pivot selection"}),": Performance depends heavily on pivot choice"]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"best-practices-and-tips",children:"Best Practices and Tips"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Use median-of-three"})," for pivot selection in practice"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Switch to insertion sort"})," for small subarrays (n < 10-20)"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Implement iterative version"})," for large arrays to avoid stack overflow"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Use three-way partitioning"})," for arrays with many duplicates"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Randomize input"})," or use random pivot to avoid worst-case scenarios"]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"comparison-with-other-sorting-algorithms-1",children:"Comparison with Other Sorting Algorithms"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <ctime>\nusing namespace std;\n\nvoid compareSortingAlgorithms() {\n    const int SIZE = 10000;\n    vector<int> data(SIZE);\n    \n    // Generate random data\n    generate(data.begin(), data.end(), []() { return rand() % 10000; });\n    \n    cout << "Sorting " << SIZE << " elements:" << endl;\n    cout << "Algorithm\\tTime (ms)" << endl;\n    cout << "------------------------" << endl;\n    \n    // Test std::sort (usually Quick Sort variant)\n    vector<int> copy1 = data;\n    clock_t start = clock();\n    sort(copy1.begin(), copy1.end());\n    clock_t end = clock();\n    cout << "std::sort\\t" << double(end - start) / CLOCKS_PER_SEC * 1000 << endl;\n    \n    // Test Quick Sort\n    vector<int> copy2 = data;\n    start = clock();\n    quickSort(copy2.data(), 0, SIZE-1);\n    end = clock();\n    cout << "Quick Sort\\t" << double(end - start) / CLOCKS_PER_SEC * 1000 << endl;\n    \n    // Test Merge Sort\n    vector<int> copy3 = data;\n    start = clock();\n    sort(copy3.begin(), copy3.end());  // std::sort is often faster\n    end = clock();\n    cout << "Merge Sort\\t" << double(end - start) / CLOCKS_PER_SEC * 1000 << endl;\n}\n\nint main() {\n    srand(time(0));\n    compareSortingAlgorithms();\n    return 0;\n}\n'})}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.em,{children:"Noted"}),"\nQuick Sort is one of the most efficient and widely used sorting algorithms. Its average-case O(n log n) performance, in-place nature, and cache efficiency make it suitable for most practical applications. However, careful implementation with proper pivot selection and optimizations is crucial to avoid worst-case scenarios."]}),"\n",(0,t.jsx)(e.h1,{id:"dsa-counting-sort---complete-c-guide",children:"DSA Counting Sort - Complete C++ Guide"}),"\n",(0,t.jsx)(e.h2,{id:"introduction-to-counting-sort",children:"Introduction to Counting Sort"}),"\n",(0,t.jsxs)(e.p,{children:["Counting Sort is a ",(0,t.jsx)(e.strong,{children:"non-comparison-based"})," sorting algorithm that works by counting the occurrences of each distinct element in the input array. It's extremely efficient when the range of input values is limited."]}),"\n",(0,t.jsx)(e.h3,{id:"key-characteristics-1",children:"Key Characteristics:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Time Complexity"}),": O(n + k) where k is the range of input"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Space Complexity"}),": O(k) additional space"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Stable"}),": Yes, maintains relative order of equal elements"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Not In-place"}),": Requires additional memory"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Integer Sorting"}),": Only works with integer keys"]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"how-counting-sort-works",children:"How Counting Sort Works"}),"\n",(0,t.jsx)(e.h3,{id:"the-four-step-process",children:"The Four-Step Process:"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Find Range"}),": Determine the minimum and maximum values in the array"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Count Frequencies"}),": Create a count array to store frequency of each value"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Cumulative Count"}),": Transform count array to cumulative counts"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Build Output"}),": Place elements in output array using count array"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"visual-example-1",children:"Visual Example:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"Input: [4, 2, 2, 8, 3, 3, 1]\n\nStep 1: Find range (min=1, max=8)\nStep 2: Count frequencies: [0,1,2,2,1,0,0,0,1]\nStep 3: Cumulative: [0,1,3,5,6,6,6,6,7]\nStep 4: Build output: [1,2,2,3,3,4,8]\n"})}),"\n",(0,t.jsx)(e.h2,{id:"basic-counting-sort-implementation",children:"Basic Counting Sort Implementation"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvoid countingSort(int arr[], int n) {\n    // Step 1: Find the maximum element\n    int maxVal = *max_element(arr, arr + n);\n    \n    // Step 2: Create count array and initialize with 0\n    vector<int> count(maxVal + 1, 0);\n    \n    // Step 3: Store count of each element\n    cout << "Step 3: Counting frequencies" << endl;\n    for(int i = 0; i < n; i++) {\n        count[arr[i]]++;\n        cout << "  Element " << arr[i] << ": count[" << arr[i] \n             << "] = " << count[arr[i]] << endl;\n    }\n    \n    // Display count array\n    cout << "\\nCount array: ";\n    for(int i = 0; i <= maxVal; i++) {\n        cout << count[i] << " ";\n    }\n    cout << endl;\n    \n    // Step 4: Modify count array to store cumulative sum\n    cout << "\\nStep 4: Creating cumulative count" << endl;\n    for(int i = 1; i <= maxVal; i++) {\n        count[i] += count[i-1];\n        cout << "  count[" << i << "] = count[" << i << "] + count[" \n             << i-1 << "] = " << count[i] << endl;\n    }\n    \n    // Display cumulative count array\n    cout << "\\nCumulative count array: ";\n    for(int i = 0; i <= maxVal; i++) {\n        cout << count[i] << " ";\n    }\n    cout << endl;\n    \n    // Step 5: Build output array\n    vector<int> output(n);\n    cout << "\\nStep 5: Building output array" << endl;\n    for(int i = n-1; i >= 0; i--) {\n        output[count[arr[i]] - 1] = arr[i];\n        cout << "  Place " << arr[i] << " at position " \n             << count[arr[i]] - 1 << endl;\n        count[arr[i]]--;\n    }\n    \n    // Step 6: Copy output array to original array\n    for(int i = 0; i < n; i++) {\n        arr[i] = output[i];\n    }\n}\n\nvoid printArray(int arr[], int n) {\n    for(int i = 0; i < n; i++) {\n        cout << arr[i] << " ";\n    }\n    cout << endl;\n}\n\nint main() {\n    int arr[] = {4, 2, 2, 8, 3, 3, 1};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    \n    cout << "Original array: ";\n    printArray(arr, n);\n    cout << endl;\n    \n    countingSort(arr, n);\n    \n    cout << "\\nSorted array: ";\n    printArray(arr, n);\n    \n    return 0;\n}\n'})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Output:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"Original array: 4 2 2 8 3 3 1 \n\nStep 3: Counting frequencies\n  Element 4: count[4] = 1\n  Element 2: count[2] = 1\n  Element 2: count[2] = 2\n  Element 8: count[8] = 1\n  Element 3: count[3] = 1\n  Element 3: count[3] = 2\n  Element 1: count[1] = 1\n\nCount array: 0 1 2 2 1 0 0 0 1 \n\nStep 4: Creating cumulative count\n  count[1] = count[1] + count[0] = 1\n  count[2] = count[2] + count[1] = 3\n  count[3] = count[3] + count[2] = 5\n  count[4] = count[4] + count[3] = 6\n  count[5] = count[5] + count[4] = 6\n  count[6] = count[6] + count[5] = 6\n  count[7] = count[7] + count[6] = 6\n  count[8] = count[8] + count[7] = 7\n\nCumulative count array: 0 1 3 5 6 6 6 6 7 \n\nStep 5: Building output array\n  Place 1 at position 0\n  Place 3 at position 4\n  Place 3 at position 3\n  Place 8 at position 6\n  Place 2 at position 2\n  Place 2 at position 1\n  Place 4 at position 5\n\nSorted array: 1 2 2 3 3 4 8\n"})}),"\n",(0,t.jsx)(e.h2,{id:"detailed-step-by-step-visualization-1",children:"Detailed Step-by-Step Visualization"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvoid countingSortVisual(int arr[], int n) {\n    cout << "=== Counting Sort Step-by-Step ===\\n" << endl;\n    \n    // Display original array\n    cout << "Input array: ";\n    for(int i = 0; i < n; i++) {\n        cout << "[" << arr[i] << "] ";\n    }\n    cout << endl;\n    \n    // Step 1: Find range\n    int maxVal = *max_element(arr, arr + n);\n    int minVal = *min_element(arr, arr + n);\n    int range = maxVal - minVal + 1;\n    \n    cout << "\\nStep 1: Find range" << endl;\n    cout << "  Minimum value: " << minVal << endl;\n    cout << "  Maximum value: " << maxVal << endl;\n    cout << "  Range: " << maxVal << " - " << minVal << " + 1 = " << range << endl;\n    \n    // Step 2: Create and initialize count array\n    vector<int> count(range, 0);\n    \n    cout << "\\nStep 2: Initialize count array of size " << range << endl;\n    cout << "  count array indices: ";\n    for(int i = 0; i < range; i++) {\n        cout << i + minVal << " ";\n    }\n    cout << endl;\n    \n    // Step 3: Store count of each element\n    cout << "\\nStep 3: Count frequencies" << endl;\n    for(int i = 0; i < n; i++) {\n        count[arr[i] - minVal]++;\n        cout << "  Element " << arr[i] << " -> index " \n             << arr[i] - minVal << " : count = " << count[arr[i] - minVal] << endl;\n    }\n    \n    cout << "\\nCount array: ";\n    for(int i = 0; i < range; i++) {\n        cout << count[i] << " ";\n    }\n    cout << endl;\n    \n    // Step 4: Cumulative count\n    cout << "\\nStep 4: Cumulative count (positions)" << endl;\n    for(int i = 1; i < range; i++) {\n        count[i] += count[i-1];\n        cout << "  count[" << i + minVal << "] = " << count[i] \n             << " (position for next " << i + minVal << ")" << endl;\n    }\n    \n    // Step 5: Build output array\n    vector<int> output(n);\n    cout << "\\nStep 5: Build output array (processing input from right to left)" << endl;\n    \n    for(int i = n-1; i >= 0; i--) {\n        // Find position in output array\n        int position = count[arr[i] - minVal] - 1;\n        output[position] = arr[i];\n        \n        cout << "\\n  Processing element arr[" << i << "] = " << arr[i] << endl;\n        cout << "    Position in output: count[" << arr[i] << "] - 1 = " \n             << position << endl;\n        cout << "    Output array now: ";\n        for(int j = 0; j < n; j++) {\n            if(j == position) cout << "[" << output[j] << "] ";\n            else if(output[j] != 0) cout << output[j] << " ";\n            else cout << "_ ";\n        }\n        cout << endl;\n        \n        // Decrease count for this element\n        count[arr[i] - minVal]--;\n    }\n    \n    // Step 6: Copy back\n    cout << "\\nStep 6: Copy output to original array" << endl;\n    for(int i = 0; i < n; i++) {\n        arr[i] = output[i];\n    }\n}\n\nint main() {\n    int arr[] = {9, 1, 6, 7, 6, 2, 1};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    \n    cout << "Original array: ";\n    for(int i = 0; i < n; i++) {\n        cout << arr[i] << " ";\n    }\n    cout << endl;\n    \n    countingSortVisual(arr, n);\n    \n    cout << "\\nFinal sorted array: ";\n    for(int i = 0; i < n; i++) {\n        cout << arr[i] << " ";\n    }\n    cout << endl;\n    \n    return 0;\n}\n'})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Output:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"=== Counting Sort Step-by-Step ===\n\nInput array: [9] [1] [6] [7] [6] [2] [1] \n\nStep 1: Find range\n  Minimum value: 1\n  Maximum value: 9\n  Range: 9 - 1 + 1 = 9\n\nStep 2: Initialize count array of size 9\n  count array indices: 1 2 3 4 5 6 7 8 9 \n\nStep 3: Count frequencies\n  Element 9 -> index 8 : count = 1\n  Element 1 -> index 0 : count = 1\n  Element 6 -> index 5 : count = 1\n  Element 7 -> index 6 : count = 1\n  Element 6 -> index 5 : count = 2\n  Element 2 -> index 1 : count = 1\n  Element 1 -> index 0 : count = 2\n\nCount array: 2 1 0 0 0 2 1 0 1 \n\nStep 4: Cumulative count (positions)\n  count[2] = 3 (position for next 2)\n  count[3] = 3 (position for next 3)\n  count[4] = 3 (position for next 4)\n  count[5] = 5 (position for next 5)\n  count[6] = 6 (position for next 6)\n  count[7] = 7 (position for next 7)\n  count[8] = 7 (position for next 8)\n  count[9] = 8 (position for next 9)\n\nStep 5: Build output array (processing input from right to left)\n\n  Processing element arr[6] = 1\n    Position in output: count[1] - 1 = 1\n    Output array now: _ [1] _ _ _ _ _ \n\n  Processing element arr[5] = 2\n    Position in output: count[2] - 1 = 2\n    Output array now: _ 1 [2] _ _ _ _ \n\n  ... (continued)\n"})}),"\n",(0,t.jsx)(e.h2,{id:"counting-sort-with-negative-numbers",children:"Counting Sort with Negative Numbers"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvoid countingSortWithNegative(int arr[], int n) {\n    // Find both min and max values\n    int maxVal = *max_element(arr, arr + n);\n    int minVal = *min_element(arr, arr + n);\n    int range = maxVal - minVal + 1;\n    \n    cout << "Array with negative numbers: ";\n    for(int i = 0; i < n; i++) {\n        cout << arr[i] << " ";\n    }\n    cout << endl;\n    \n    cout << "Min: " << minVal << ", Max: " << maxVal \n         << ", Range: " << range << endl;\n    \n    // Create count array\n    vector<int> count(range, 0);\n    \n    // Count frequencies\n    for(int i = 0; i < n; i++) {\n        count[arr[i] - minVal]++;\n    }\n    \n    cout << "Count array (index 0 represents value " << minVal << "):" << endl;\n    for(int i = 0; i < range; i++) {\n        cout << "Value " << i + minVal << ": " << count[i] << " times" << endl;\n    }\n    \n    // Cumulative count\n    for(int i = 1; i < range; i++) {\n        count[i] += count[i-1];\n    }\n    \n    // Build output array\n    vector<int> output(n);\n    for(int i = n-1; i >= 0; i--) {\n        output[count[arr[i] - minVal] - 1] = arr[i];\n        count[arr[i] - minVal]--;\n    }\n    \n    // Copy back\n    for(int i = 0; i < n; i++) {\n        arr[i] = output[i];\n    }\n}\n\nint main() {\n    int arr[] = {-5, -10, 0, -3, 8, 5, -1, 10};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    \n    countingSortWithNegative(arr, n);\n    \n    cout << "\\nSorted array: ";\n    for(int i = 0; i < n; i++) {\n        cout << arr[i] << " ";\n    }\n    cout << endl;\n    \n    return 0;\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"counting-sort-for-characters",children:"Counting Sort for Characters"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvoid countingSortCharacters(string& str) {\n    int n = str.length();\n    \n    cout << "Original string: " << str << endl;\n    \n    // Since characters are from 0 to 255 (ASCII)\n    const int RANGE = 256;\n    vector<int> count(RANGE, 0);\n    \n    // Count frequency of each character\n    for(int i = 0; i < n; i++) {\n        count[str[i]]++;\n    }\n    \n    // Display character frequencies\n    cout << "\\nCharacter frequencies:" << endl;\n    for(int i = 0; i < RANGE; i++) {\n        if(count[i] > 0) {\n            if(i >= 32 && i <= 126) { // Printable characters\n                cout << "  \'" << char(i) << "\' (ASCII " << i << "): " \n                     << count[i] << " times" << endl;\n            }\n        }\n    }\n    \n    // Cumulative count\n    for(int i = 1; i < RANGE; i++) {\n        count[i] += count[i-1];\n    }\n    \n    // Build output\n    vector<char> output(n);\n    for(int i = n-1; i >= 0; i--) {\n        output[count[str[i]] - 1] = str[i];\n        count[str[i]]--;\n    }\n    \n    // Copy back to string\n    for(int i = 0; i < n; i++) {\n        str[i] = output[i];\n    }\n}\n\nint main() {\n    string text = "counting sort example";\n    \n    cout << "=== Counting Sort for Characters ===" << endl;\n    countingSortCharacters(text);\n    \n    cout << "\\nSorted string: " << text << endl;\n    \n    return 0;\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"counting-sort-complexity-analysis",children:"Counting Sort Complexity Analysis"}),"\n",(0,t.jsx)(e.h3,{id:"time-complexity-1",children:"Time Complexity:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Best Case"}),": O(n + k)"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Average Case"}),": O(n + k)"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Worst Case"}),": O(n + k)"]}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:"Where:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"n"})," = number of elements in input array"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"k"})," = range of input (max - min + 1)"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"space-complexity-1",children:"Space Complexity:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"O(k)"})," for count array"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"O(n)"})," for output array"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Total"}),": O(n + k)"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"when-is-counting-sort-efficient",children:"When is Counting Sort Efficient?"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"k is small"})," compared to n"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"n is large"})," but values are limited"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Integer sorting"})," is required"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Stability"})," is important"]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"optimized-counting-sort",children:"Optimized Counting Sort"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// Optimized version that minimizes memory usage\nvoid optimizedCountingSort(int arr[], int n) {\n    if(n == 0) return;\n    \n    // Find min and max in single pass\n    int minVal = arr[0];\n    int maxVal = arr[0];\n    \n    for(int i = 1; i < n; i++) {\n        if(arr[i] < minVal) minVal = arr[i];\n        if(arr[i] > maxVal) maxVal = arr[i];\n    }\n    \n    int range = maxVal - minVal + 1;\n    \n    // Early return if range is too large\n    if(range > 1000000) { // Arbitrary threshold\n        cout << "Range too large for Counting Sort. Use another algorithm." << endl;\n        return;\n    }\n    \n    // Use vector for dynamic allocation\n    vector<int> count(range, 0);\n    \n    // Count frequencies\n    for(int i = 0; i < n; i++) {\n        count[arr[i] - minVal]++;\n    }\n    \n    // Reconstruct sorted array directly\n    int index = 0;\n    for(int i = 0; i < range; i++) {\n        while(count[i] > 0) {\n            arr[index++] = i + minVal;\n            count[i]--;\n        }\n    }\n}\n\n// For arrays with small range, we can avoid output array\nvoid countingSortInPlace(int arr[], int n) {\n    if(n <= 1) return;\n    \n    int minVal = arr[0];\n    int maxVal = arr[0];\n    \n    for(int i = 1; i < n; i++) {\n        if(arr[i] < minVal) minVal = arr[i];\n        if(arr[i] > maxVal) maxVal = arr[i];\n    }\n    \n    int range = maxVal - minVal + 1;\n    vector<int> count(range, 0);\n    \n    // Count frequencies\n    for(int i = 0; i < n; i++) {\n        count[arr[i] - minVal]++;\n    }\n    \n    // Overwrite original array\n    int currentIndex = 0;\n    for(int value = 0; value < range; value++) {\n        int actualValue = value + minVal;\n        for(int j = 0; j < count[value]; j++) {\n            arr[currentIndex++] = actualValue;\n        }\n    }\n}\n\nint main() {\n    int arr1[] = {1, 4, 1, 2, 7, 5, 2};\n    int n1 = sizeof(arr1) / sizeof(arr1[0]);\n    \n    cout << "Optimized Counting Sort:" << endl;\n    cout << "Original: ";\n    for(int i = 0; i < n1; i++) cout << arr1[i] << " ";\n    cout << endl;\n    \n    optimizedCountingSort(arr1, n1);\n    \n    cout << "Sorted: ";\n    for(int i = 0; i < n1; i++) cout << arr1[i] << " ";\n    cout << endl;\n    \n    return 0;\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"applications-of-counting-sort",children:"Applications of Counting Sort"}),"\n",(0,t.jsx)(e.h3,{id:"1-sorting-exam-scores-0-100-range",children:"1. Sorting Exam Scores (0-100 range)"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <vector>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n\nvoid sortExamScores() {\n    const int NUM_STUDENTS = 50;\n    const int MAX_SCORE = 100;\n    \n    vector<int> scores(NUM_STUDENTS);\n    \n    // Generate random scores\n    srand(time(0));\n    for(int i = 0; i < NUM_STUDENTS; i++) {\n        scores[i] = rand() % (MAX_SCORE + 1); // 0 to 100\n    }\n    \n    cout << "Exam Scores (Unsorted):" << endl;\n    for(int i = 0; i < NUM_STUDENTS; i++) {\n        cout << scores[i] << " ";\n        if((i + 1) % 10 == 0) cout << endl;\n    }\n    \n    // Counting sort is perfect for this!\n    vector<int> count(MAX_SCORE + 1, 0);\n    \n    for(int score : scores) {\n        count[score]++;\n    }\n    \n    // Reconstruct sorted scores\n    int index = 0;\n    for(int score = 0; score <= MAX_SCORE; score++) {\n        while(count[score] > 0) {\n            scores[index++] = score;\n            count[score]--;\n        }\n    }\n    \n    cout << "\\n\\nExam Scores (Sorted):" << endl;\n    for(int i = 0; i < NUM_STUDENTS; i++) {\n        cout << scores[i] << " ";\n        if((i + 1) % 10 == 0) cout << endl;\n    }\n    \n    // Calculate statistics\n    cout << "\\nStatistics:" << endl;\n    cout << "Highest score: " << scores[NUM_STUDENTS - 1] << endl;\n    cout << "Lowest score: " << scores[0] << endl;\n    cout << "Median score: " << scores[NUM_STUDENTS / 2] << endl;\n}\n\nint main() {\n    sortExamScores();\n    return 0;\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"2-histogram-generation",children:"2. Histogram Generation"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <vector>\n#include <iomanip>\nusing namespace std;\n\nvoid generateHistogram(const vector<int>& data) {\n    if(data.empty()) return;\n    \n    // Find range\n    int minVal = data[0];\n    int maxVal = data[0];\n    for(int val : data) {\n        if(val < minVal) minVal = val;\n        if(val > maxVal) maxVal = val;\n    }\n    \n    int range = maxVal - minVal + 1;\n    vector<int> histogram(range, 0);\n    \n    // Build histogram\n    for(int val : data) {\n        histogram[val - minVal]++;\n    }\n    \n    // Display histogram\n    cout << "\\nValue Range Histogram:" << endl;\n    cout << "----------------------" << endl;\n    \n    int maxCount = *max_element(histogram.begin(), histogram.end());\n    \n    for(int i = 0; i < range; i++) {\n        int value = i + minVal;\n        int count = histogram[i];\n        \n        if(count > 0) {\n            cout << setw(3) << value << ": " \n                 << string(count * 50 / maxCount, \'#\') \n                 << " (" << count << ")" << endl;\n        }\n    }\n}\n\nint main() {\n    vector<int> data = {1, 3, 2, 1, 4, 2, 3, 5, 1, 2, \n                        3, 4, 5, 2, 1, 3, 4, 2, 1, 5};\n    \n    cout << "Original data: ";\n    for(int val : data) cout << val << " ";\n    cout << endl;\n    \n    generateHistogram(data);\n    \n    return 0;\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"comparison-with-other-sorting-algorithms-2",children:"Comparison with Other Sorting Algorithms"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <ctime>\n#include <cstdlib>\nusing namespace std;\n\nvoid performanceComparison() {\n    srand(time(0));\n    \n    // Test cases\n    vector<pair<string, vector<int>>> testCases = {\n        {"Small Range (0-100)", {}},\n        {"Medium Range (0-1000)", {}},\n        {"Large Range (0-10000)", {}},\n        {"Very Large Range (0-100000)", {}}\n    };\n    \n    const int SIZE = 10000;\n    \n    // Generate test data\n    for(auto& testCase : testCases) {\n        testCase.second.resize(SIZE);\n        int maxVal;\n        \n        if(testCase.first.find("Small") != string::npos) maxVal = 100;\n        else if(testCase.first.find("Medium") != string::npos) maxVal = 1000;\n        else if(testCase.first.find("Large") != string::npos) maxVal = 10000;\n        else maxVal = 100000;\n        \n        for(int i = 0; i < SIZE; i++) {\n            testCase.second[i] = rand() % (maxVal + 1);\n        }\n    }\n    \n    cout << "Performance Comparison (Sorting " << SIZE << " elements)" << endl;\n    cout << "================================================" << endl;\n    \n    for(auto& testCase : testCases) {\n        cout << "\\nTest: " << testCase.first << endl;\n        \n        // Test Counting Sort\n        vector<int> data1 = testCase.second;\n        clock_t start = clock();\n        \n        // Implement counting sort here\n        int maxVal = *max_element(data1.begin(), data1.end());\n        int minVal = *min_element(data1.begin(), data1.end());\n        int range = maxVal - minVal + 1;\n        vector<int> count(range, 0);\n        \n        for(int val : data1) count[val - minVal]++;\n        \n        int index = 0;\n        for(int i = 0; i < range; i++) {\n            while(count[i] > 0) {\n                data1[index++] = i + minVal;\n                count[i]--;\n            }\n        }\n        \n        clock_t end = clock();\n        double countingTime = double(end - start) / CLOCKS_PER_SEC * 1000;\n        \n        // Test std::sort (Quick Sort variant)\n        vector<int> data2 = testCase.second;\n        start = clock();\n        sort(data2.begin(), data2.end());\n        end = clock();\n        double quickTime = double(end - start) / CLOCKS_PER_SEC * 1000;\n        \n        cout << "  Counting Sort: " << countingTime << " ms" << endl;\n        cout << "  Quick Sort (std::sort): " << quickTime << " ms" << endl;\n        cout << "  Ratio (Counting/Quick): " << countingTime/quickTime << endl;\n    }\n}\n\nint main() {\n    performanceComparison();\n    return 0;\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"limitations-and-when-not-to-use-counting-sort",children:"Limitations and When Not to Use Counting Sort"}),"\n",(0,t.jsx)(e.h3,{id:"limitations",children:"Limitations:"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Integer Only"}),": Only works with integer keys"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Range Dependency"}),": Performance depends on range k, not just n"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Memory Usage"}),": Requires O(k) additional memory"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Not Comparison-based"}),": Cannot be used with custom comparators"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"when-not-to-use-counting-sort",children:"When NOT to use Counting Sort:"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"When k is very large"})," compared to n (e.g., k = n\xb2)"]}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.strong,{children:"When sorting floating-point numbers"})}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"When sorting complex objects"})," with integer keys but large payloads"]}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.strong,{children:"When memory is severely constrained"})}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"hybrid-approach-counting-sort--other-algorithms",children:"Hybrid Approach: Counting Sort + Other Algorithms"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// Hybrid approach: Use Counting Sort for small range, Quick Sort otherwise\nvoid hybridSort(vector<int>& arr) {\n    if(arr.size() <= 1) return;\n    \n    // Find range\n    int minVal = *min_element(arr.begin(), arr.end());\n    int maxVal = *max_element(arr.begin(), arr.end());\n    int range = maxVal - minVal + 1;\n    \n    // Threshold: if range is small compared to size, use Counting Sort\n    if(range < arr.size() * 2) {\n        cout << "Using Counting Sort (range=" << range \n             << ", size=" << arr.size() << ")" << endl;\n        \n        vector<int> count(range, 0);\n        for(int val : arr) {\n            count[val - minVal]++;\n        }\n        \n        int index = 0;\n        for(int i = 0; i < range; i++) {\n            while(count[i] > 0) {\n                arr[index++] = i + minVal;\n                count[i]--;\n            }\n        }\n    } else {\n        cout << "Using Quick Sort (range=" << range \n             << ", size=" << arr.size() << ")" << endl;\n        sort(arr.begin(), arr.end());\n    }\n}\n\nint main() {\n    // Test case 1: Small range - Counting Sort\n    vector<int> data1 = {1, 4, 1, 2, 7, 5, 2, 3, 6, 2, 1};\n    cout << "Test 1 - Small range:" << endl;\n    hybridSort(data1);\n    cout << "Sorted: ";\n    for(int val : data1) cout << val << " ";\n    cout << endl;\n    \n    // Test case 2: Large range - Quick Sort\n    vector<int> data2 = {1000, 5000, 200, 8000, 1500, 9000, 300};\n    cout << "\\nTest 2 - Large range:" << endl;\n    hybridSort(data2);\n    cout << "Sorted: ";\n    for(int val : data2) cout << val << " ";\n    cout << endl;\n    \n    return 0;\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,t.jsx)(e.p,{children:"Counting Sort is a highly efficient algorithm when the range of input values is small. Its O(n + k) time complexity makes it faster than comparison-based sorts in specific scenarios. However, its limitations mean it's not a general-purpose sorting algorithm."}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Key Takeaways:"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Best when k (range) is small compared to n"}),"\n",(0,t.jsx)(e.li,{children:"Stable sorting algorithm"}),"\n",(0,t.jsx)(e.li,{children:"Not in-place (requires additional memory)"}),"\n",(0,t.jsx)(e.li,{children:"Only works with integer keys"}),"\n",(0,t.jsx)(e.li,{children:"Excellent for specific applications like sorting grades, ages, or exam scores"}),"\n"]}),"\n",(0,t.jsx)(e.h1,{id:"dsa-radix-sort---complete-c-guide",children:"DSA Radix Sort - Complete C++ Guide"}),"\n",(0,t.jsx)(e.h2,{id:"introduction-to-radix-sort",children:"Introduction to Radix Sort"}),"\n",(0,t.jsxs)(e.p,{children:["Radix Sort is a ",(0,t.jsx)(e.strong,{children:"non-comparative integer sorting algorithm"})," that sorts numbers by processing individual digits. It groups numbers by each digit, from least significant digit (LSD) to most significant digit (MSD)."]}),"\n",(0,t.jsx)(e.h3,{id:"key-characteristics-2",children:"Key Characteristics:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Time Complexity"}),": O(d*(n + k)) where d is number of digits, k is base (usually 10)"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Space Complexity"}),": O(n + k) additional space"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Stable"}),": Yes, maintains relative order"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Not In-place"}),": Requires additional memory"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Integer Sorting"}),": Works only with integers (or objects with integer keys)"]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"how-radix-sort-works",children:"How Radix Sort Works"}),"\n",(0,t.jsx)(e.h3,{id:"the-lsd-least-significant-digit-approach",children:"The LSD (Least Significant Digit) Approach:"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Start from LSD"}),": Begin with the rightmost digit"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Group by digit"}),": Place numbers in buckets based on current digit"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Collect buckets"}),": Gather numbers back in order"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Repeat"}),": Move to next digit to the left"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Continue"}),": Until all digits are processed"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"visual-example-2",children:"Visual Example:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"Input: [170, 45, 75, 90, 802, 24, 2, 66]\n\nStep 1 (Sort by units digit):\nBuckets: 0:[170,90], 2:[802,2], 4:[24], 5:[45,75], 6:[66]\nResult: [170, 90, 802, 2, 24, 45, 75, 66]\n\nStep 2 (Sort by tens digit):\nBuckets: 0:[802,2], 2:[24], 4:[45], 6:[66], 7:[170,75], 9:[90]\nResult: [802, 2, 24, 45, 66, 170, 75, 90]\n\nStep 3 (Sort by hundreds digit):\nBuckets: 0:[2,24,45,66,75,90], 1:[170], 8:[802]\nResult: [2, 24, 45, 66, 75, 90, 170, 802] \u2190 Sorted!\n"})}),"\n",(0,t.jsx)(e.h2,{id:"basic-radix-sort-implementation",children:"Basic Radix Sort Implementation"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// A utility function to get the maximum value in arr[]\nint getMax(int arr[], int n) {\n    int maxVal = arr[0];\n    for(int i = 1; i < n; i++) {\n        if(arr[i] > maxVal) {\n            maxVal = arr[i];\n        }\n    }\n    return maxVal;\n}\n\n// Using counting sort as a subroutine for radix sort\nvoid countingSortForRadix(int arr[], int n, int exp) {\n    vector<int> output(n);  // Output array\n    int count[10] = {0};    // Count array for digits 0-9\n    \n    cout << "\\nSorting by digit at position 10^" << exp << ":" << endl;\n    \n    // Store count of occurrences\n    for(int i = 0; i < n; i++) {\n        int digit = (arr[i] / exp) % 10;\n        count[digit]++;\n        cout << "  Element " << arr[i] << " -> digit " << digit \n             << " (count[" << digit << "] = " << count[digit] << ")" << endl;\n    }\n    \n    cout << "\\nCount array: ";\n    for(int i = 0; i < 10; i++) {\n        cout << count[i] << " ";\n    }\n    cout << endl;\n    \n    // Change count[i] to contain actual position\n    for(int i = 1; i < 10; i++) {\n        count[i] += count[i-1];\n    }\n    \n    cout << "Cumulative count: ";\n    for(int i = 0; i < 10; i++) {\n        cout << count[i] << " ";\n    }\n    cout << endl;\n    \n    // Build output array\n    for(int i = n-1; i >= 0; i--) {\n        int digit = (arr[i] / exp) % 10;\n        output[count[digit] - 1] = arr[i];\n        cout << "  Placing " << arr[i] << " at position " \n             << count[digit] - 1 << endl;\n        count[digit]--;\n    }\n    \n    cout << "Output array: ";\n    for(int i = 0; i < n; i++) {\n        cout << output[i] << " ";\n    }\n    cout << endl;\n    \n    // Copy output to arr[]\n    for(int i = 0; i < n; i++) {\n        arr[i] = output[i];\n    }\n}\n\n// Main Radix Sort function\nvoid radixSort(int arr[], int n) {\n    // Find maximum number to know number of digits\n    int maxVal = getMax(arr, n);\n    \n    cout << "Maximum value: " << maxVal << endl;\n    cout << "Number of digits: " << to_string(maxVal).length() << endl;\n    \n    // Do counting sort for every digit\n    for(int exp = 1; maxVal / exp > 0; exp *= 10) {\n        countingSortForRadix(arr, n, exp);\n    }\n}\n\nvoid printArray(int arr[], int n) {\n    for(int i = 0; i < n; i++) {\n        cout << arr[i] << " ";\n    }\n    cout << endl;\n}\n\nint main() {\n    int arr[] = {170, 45, 75, 90, 802, 24, 2, 66};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    \n    cout << "Original array: ";\n    printArray(arr, n);\n    \n    radixSort(arr, n);\n    \n    cout << "\\nSorted array: ";\n    printArray(arr, n);\n    \n    return 0;\n}\n'})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Output:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"Original array: 170 45 75 90 802 24 2 66 \nMaximum value: 802\nNumber of digits: 3\n\nSorting by digit at position 10^1:\n  Element 170 -> digit 0 (count[0] = 1)\n  Element 45 -> digit 5 (count[5] = 1)\n  Element 75 -> digit 5 (count[5] = 2)\n  Element 90 -> digit 0 (count[0] = 2)\n  Element 802 -> digit 2 (count[2] = 1)\n  Element 24 -> digit 4 (count[4] = 1)\n  Element 2 -> digit 2 (count[2] = 2)\n  Element 66 -> digit 6 (count[6] = 1)\n\nCount array: 2 0 2 0 1 2 1 0 0 0 \nCumulative count: 2 2 4 4 5 7 8 8 8 8 \n  Placing 66 at position 7\n  Placing 2 at position 3\n  Placing 24 at position 4\n  Placing 802 at position 2\n  Placing 90 at position 1\n  Placing 75 at position 6\n  Placing 45 at position 5\n  Placing 170 at position 0\nOutput array: 170 90 802 2 24 45 75 66 \n\n... (continues for tens and hundreds digits)\n"})}),"\n",(0,t.jsx)(e.h2,{id:"detailed-step-by-step-visualization-2",children:"Detailed Step-by-Step Visualization"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <iomanip>\nusing namespace std;\n\nvoid radixSortVisual(int arr[], int n) {\n    cout << "=== Radix Sort Step-by-Step ===\\n" << endl;\n    cout << "Original array: ";\n    for(int i = 0; i < n; i++) {\n        cout << setw(3) << arr[i] << " ";\n    }\n    cout << endl;\n    \n    // Find maximum value\n    int maxVal = *max_element(arr, arr + n);\n    int numDigits = to_string(maxVal).length();\n    \n    cout << "\\nMaximum value: " << maxVal << endl;\n    cout << "Number of digits to process: " << numDigits << endl;\n    \n    // Process each digit\n    for(int digitPos = 0; digitPos < numDigits; digitPos++) {\n        int exp = pow(10, digitPos);\n        \n        cout << "\\n" << string(60, \'=\') << endl;\n        cout << "Processing " << (digitPos == 0 ? "units" : \n               digitPos == 1 ? "tens" : \n               digitPos == 2 ? "hundreds" : to_string(digitPos) + "th") \n             << " digit (position 10^" << digitPos << ")" << endl;\n        cout << string(60, \'=\') << endl;\n        \n        // Create 10 buckets (0-9)\n        vector<vector<int>> buckets(10);\n        \n        // Distribute numbers into buckets based on current digit\n        cout << "\\nDistributing numbers into buckets:" << endl;\n        for(int i = 0; i < n; i++) {\n            int digit = (arr[i] / exp) % 10;\n            buckets[digit].push_back(arr[i]);\n            \n            cout << "  " << setw(3) << arr[i] << " -> bucket[" << digit << "] ";\n            cout << "(digit: " << setw(2) << digit << ")" << endl;\n        }\n        \n        // Display buckets\n        cout << "\\nBuckets after distribution:" << endl;\n        for(int i = 0; i < 10; i++) {\n            if(!buckets[i].empty()) {\n                cout << "  Bucket[" << i << "]: ";\n                for(int num : buckets[i]) {\n                    cout << setw(3) << num << " ";\n                }\n                cout << endl;\n            }\n        }\n        \n        // Collect numbers from buckets\n        cout << "\\nCollecting numbers from buckets:" << endl;\n        int index = 0;\n        for(int i = 0; i < 10; i++) {\n            cout << "  From bucket[" << i << "]: ";\n            for(int num : buckets[i]) {\n                arr[index++] = num;\n                cout << setw(3) << num << " ";\n            }\n            if(!buckets[i].empty()) cout << endl;\n        }\n        \n        cout << "\\nArray after processing this digit: ";\n        for(int i = 0; i < n; i++) {\n            cout << setw(3) << arr[i] << " ";\n        }\n        cout << endl;\n        \n        // Show digit extraction for each number\n        cout << "\\nDigit extraction details:" << endl;\n        cout << "Number\\t\\tDigit at 10^" << digitPos << "\\t\\tCalculation" << endl;\n        cout << string(50, \'-\') << endl;\n        for(int i = 0; i < n; i++) {\n            int digit = (arr[i] / exp) % 10;\n            cout << setw(3) << arr[i] << "\\t\\t" << setw(2) << digit \n                 << "\\t\\t\\t(" << arr[i] << " / " << exp << ") % 10 = " << digit << endl;\n        }\n    }\n    \n    cout << "\\n" << string(60, \'=\') << endl;\n    cout << "FINAL SORTED ARRAY:" << endl;\n    cout << string(60, \'=\') << endl;\n    for(int i = 0; i < n; i++) {\n        cout << setw(3) << arr[i] << " ";\n    }\n    cout << endl;\n}\n\nint main() {\n    int arr[] = {329, 457, 657, 839, 436, 720, 355};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    \n    radixSortVisual(arr, n);\n    \n    return 0;\n}\n'})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Output:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"=== Radix Sort Step-by-Step ===\n\nOriginal array: 329 457 657 839 436 720 355 \n\nMaximum value: 839\nNumber of digits to process: 3\n\n============================================================\nProcessing units digit (position 10^0)\n============================================================\n\nDistributing numbers into buckets:\n  329 -> bucket[9] (digit:  9)\n  457 -> bucket[7] (digit:  7)\n  657 -> bucket[7] (digit:  7)\n  839 -> bucket[9] (digit:  9)\n  436 -> bucket[6] (digit:  6)\n  720 -> bucket[0] (digit:  0)\n  355 -> bucket[5] (digit:  5)\n\nBuckets after distribution:\n  Bucket[0]: 720 \n  Bucket[5]: 355 \n  Bucket[6]: 436 \n  Bucket[7]: 457 657 \n  Bucket[9]: 329 839 \n\nCollecting numbers from buckets:\n  From bucket[0]: 720 \n  From bucket[5]: 355 \n  From bucket[6]: 436 \n  From bucket[7]: 457 657 \n  From bucket[9]: 329 839 \n\nArray after processing this digit: 720 355 436 457 657 329 839 \n\n... (continues for tens and hundreds digits)\n"})}),"\n",(0,t.jsx)(e.h2,{id:"radix-sort-for-negative-numbers",children:"Radix Sort for Negative Numbers"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nvoid radixSortWithNegatives(vector<int>& arr) {\n    if(arr.empty()) return;\n    \n    cout << "Original array (with negatives): ";\n    for(int num : arr) cout << num << " ";\n    cout << endl;\n    \n    // Separate positive and negative numbers\n    vector<int> positives, negatives;\n    for(int num : arr) {\n        if(num >= 0) positives.push_back(num);\n        else negatives.push_back(abs(num));  // Store absolute value\n    }\n    \n    cout << "\\nPositive numbers: ";\n    for(int num : positives) cout << num << " ";\n    cout << endl;\n    \n    cout << "Negative numbers (absolute values): ";\n    for(int num : negatives) cout << num << " ";\n    cout << endl;\n    \n    // Sort positive numbers normally\n    if(!positives.empty()) {\n        int maxPos = *max_element(positives.begin(), positives.end());\n        for(int exp = 1; maxPos / exp > 0; exp *= 10) {\n            vector<int> output(positives.size());\n            int count[10] = {0};\n            \n            for(int num : positives) count[(num / exp) % 10]++;\n            for(int i = 1; i < 10; i++) count[i] += count[i-1];\n            for(int i = positives.size() - 1; i >= 0; i--) {\n                int digit = (positives[i] / exp) % 10;\n                output[count[digit] - 1] = positives[i];\n                count[digit]--;\n            }\n            positives = output;\n        }\n    }\n    \n    // Sort negative numbers (as absolute values)\n    if(!negatives.empty()) {\n        int maxNeg = *max_element(negatives.begin(), negatives.end());\n        for(int exp = 1; maxNeg / exp > 0; exp *= 10) {\n            vector<int> output(negatives.size());\n            int count[10] = {0};\n            \n            for(int num : negatives) count[(num / exp) % 10]++;\n            for(int i = 1; i < 10; i++) count[i] += count[i-1];\n            for(int i = negatives.size() - 1; i >= 0; i--) {\n                int digit = (negatives[i] / exp) % 10;\n                output[count[digit] - 1] = negatives[i];\n                count[digit]--;\n            }\n            negatives = output;\n        }\n        \n        // Convert back to negative and reverse order\n        reverse(negatives.begin(), negatives.end());\n        for(int& num : negatives) num = -num;\n    }\n    \n    // Combine results: negatives (sorted descending by absolute value) then positives\n    arr.clear();\n    arr.insert(arr.end(), negatives.begin(), negatives.end());\n    arr.insert(arr.end(), positives.begin(), positives.end());\n    \n    cout << "\\nSorted array: ";\n    for(int num : arr) cout << num << " ";\n    cout << endl;\n}\n\nint main() {\n    vector<int> arr = {-170, 45, -75, 90, -802, 24, -2, 66, 0, -1};\n    \n    cout << "=== Radix Sort with Negative Numbers ===" << endl;\n    radixSortWithNegatives(arr);\n    \n    return 0;\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"radix-sort-for-strings",children:"Radix Sort for Strings"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nvoid radixSortStrings(vector<string>& arr, int maxLen) {\n    cout << "Sorting strings using Radix Sort (LSD)" << endl;\n    cout << "Maximum length: " << maxLen << endl;\n    \n    // Process from rightmost character to leftmost\n    for(int pos = maxLen - 1; pos >= 0; pos--) {\n        cout << "\\nProcessing character at position " << pos << ":" << endl;\n        \n        // Create buckets for ASCII characters (256 possible)\n        vector<vector<string>> buckets(256);\n        \n        // Distribute strings into buckets\n        for(const string& str : arr) {\n            int charIndex;\n            if(pos < str.length()) {\n                charIndex = str[pos];\n                cout << "  \\"" << str << "\\" -> bucket[" << charIndex \n                     << "] (char: \'" << str[pos] << "\')" << endl;\n            } else {\n                charIndex = 0;  // Null character for shorter strings\n                cout << "  \\"" << str << "\\" -> bucket[0] (shorter string)" << endl;\n            }\n            buckets[charIndex].push_back(str);\n        }\n        \n        // Collect strings from buckets\n        int index = 0;\n        for(int i = 0; i < 256; i++) {\n            for(const string& str : buckets[i]) {\n                arr[index++] = str;\n            }\n        }\n        \n        // Display intermediate result\n        cout << "After position " << pos << ": ";\n        for(const string& str : arr) {\n            cout << "\\"" << str << "\\" ";\n        }\n        cout << endl;\n    }\n}\n\nint main() {\n    vector<string> words = {"word", "category", "cat", "new", "news", \n                           "world", "bear", "at", "work", "time"};\n    \n    // Find maximum length\n    int maxLen = 0;\n    for(const string& word : words) {\n        maxLen = max(maxLen, (int)word.length());\n    }\n    \n    cout << "Original strings: ";\n    for(const string& word : words) {\n        cout << "\\"" << word << "\\" ";\n    }\n    cout << endl;\n    \n    radixSortStrings(words, maxLen);\n    \n    cout << "\\nSorted strings: ";\n    for(const string& word : words) {\n        cout << "\\"" << word << "\\" ";\n    }\n    cout << endl;\n    \n    return 0;\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"different-radix-sort-variations",children:"Different Radix Sort Variations"}),"\n",(0,t.jsx)(e.h3,{id:"1-msd-most-significant-digit-radix-sort",children:"1. MSD (Most Significant Digit) Radix Sort"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// MSD Radix Sort (recursive)\nvoid msdRadixSort(vector<int>& arr, int left, int right, int exp) {\n    if(left >= right || exp == 0) return;\n    \n    cout << "\\nMSD Processing: range [" << left << "," << right \n         << "], exp=" << exp << endl;\n    \n    // Create buckets\n    vector<vector<int>> buckets(10);\n    vector<int> output(right - left + 1);\n    \n    // Distribute into buckets\n    for(int i = left; i <= right; i++) {\n        int digit = (arr[i] / exp) % 10;\n        buckets[digit].push_back(arr[i]);\n    }\n    \n    // Collect from buckets and recursively sort each bucket\n    int index = left;\n    for(int digit = 0; digit < 10; digit++) {\n        if(!buckets[digit].empty()) {\n            // Copy bucket to array segment\n            for(int num : buckets[digit]) {\n                arr[index++] = num;\n            }\n            \n            // Recursively sort this bucket with next digit\n            int bucketStart = index - buckets[digit].size();\n            int bucketEnd = index - 1;\n            \n            if(buckets[digit].size() > 1 && exp/10 > 0) {\n                msdRadixSort(arr, bucketStart, bucketEnd, exp/10);\n            }\n        }\n    }\n}\n\nint main() {\n    vector<int> arr = {329, 457, 657, 839, 436, 720, 355};\n    \n    cout << "MSD Radix Sort" << endl;\n    cout << "Original: ";\n    for(int num : arr) cout << num << " ";\n    cout << endl;\n    \n    int maxVal = *max_element(arr.begin(), arr.end());\n    int maxExp = 1;\n    while(maxExp <= maxVal) maxExp *= 10;\n    maxExp /= 10;  // Get highest power of 10\n    \n    msdRadixSort(arr, 0, arr.size()-1, maxExp);\n    \n    cout << "\\nSorted: ";\n    for(int num : arr) cout << num << " ";\n    cout << endl;\n    \n    return 0;\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"2-radix-sort-with-different-bases",children:"2. Radix Sort with Different Bases"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\n// Radix Sort with configurable base\nvoid radixSortWithBase(vector<int>& arr, int base = 10) {\n    if(arr.empty()) return;\n    \n    cout << "Radix Sort with base " << base << endl;\n    \n    int maxVal = *max_element(arr.begin(), arr.end());\n    int maxDigit = 0;\n    \n    // Calculate maximum number of digits in given base\n    while(maxVal > 0) {\n        maxVal /= base;\n        maxDigit++;\n    }\n    \n    cout << "Maximum digits in base " << base << ": " << maxDigit << endl;\n    \n    // Process each digit\n    for(int digitPos = 0; digitPos < maxDigit; digitPos++) {\n        int exp = pow(base, digitPos);\n        vector<vector<int>> buckets(base);\n        \n        // Distribute\n        for(int num : arr) {\n            int digit = (num / exp) % base;\n            buckets[digit].push_back(num);\n        }\n        \n        // Collect\n        int index = 0;\n        for(int i = 0; i < base; i++) {\n            for(int num : buckets[i]) {\n                arr[index++] = num;\n            }\n        }\n        \n        cout << "After digit position " << digitPos << ": ";\n        for(int num : arr) cout << num << " ";\n        cout << endl;\n    }\n}\n\nint main() {\n    vector<int> arr = {170, 45, 75, 90, 802, 24, 2, 66};\n    \n    cout << "Testing different bases for Radix Sort" << endl;\n    cout << "Original: ";\n    for(int num : arr) cout << num << " ";\n    cout << endl << endl;\n    \n    // Test with different bases\n    vector<int> arr1 = arr;\n    radixSortWithBase(arr1, 2);  // Binary\n    \n    cout << "\\n";\n    vector<int> arr2 = arr;\n    radixSortWithBase(arr2, 8);  // Octal\n    \n    cout << "\\n";\n    vector<int> arr3 = arr;\n    radixSortWithBase(arr3, 10); // Decimal\n    \n    cout << "\\n";\n    vector<int> arr4 = arr;\n    radixSortWithBase(arr4, 16); // Hexadecimal\n    \n    return 0;\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"radix-sort-complexity-analysis",children:"Radix Sort Complexity Analysis"}),"\n",(0,t.jsx)(e.h3,{id:"time-complexity-2",children:"Time Complexity:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Best Case"}),": O(d*(n + k)) where:","\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"d = number of digits"}),"\n",(0,t.jsx)(e.li,{children:"n = number of elements"}),"\n",(0,t.jsx)(e.li,{children:"k = base (radix) - usually 10"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Average Case"}),": O(d*(n + k))"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Worst Case"}),": O(d*(n + k))"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"space-complexity-2",children:"Space Complexity:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"O(n + k)"})," for buckets/count array"]}),"\n",(0,t.jsx)(e.li,{children:"Additional O(1) for variables"}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"comparison-with-other-algorithms",children:"Comparison with Other Algorithms:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"For n numbers with maximum d digits:\n- Radix Sort: O(d*(n + k))\n- Quick Sort: O(n log n) average\n- Counting Sort: O(n + k) but k can be very large\n"})}),"\n",(0,t.jsx)(e.h2,{id:"performance-comparison-2",children:"Performance Comparison"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <ctime>\n#include <random>\n#include <iomanip>\nusing namespace std;\n\nvoid performanceTest() {\n    random_device rd;\n    mt19937 gen(rd());\n    uniform_int_distribution<> dis(0, 10000);\n    \n    vector<int> sizes = {1000, 10000, 50000, 100000};\n    \n    cout << "Radix Sort vs Quick Sort Performance Comparison\\n" << endl;\n    cout << setw(10) << "Size" << setw(15) << "Radix Sort" \n         << setw(15) << "Quick Sort" << setw(15) << "Ratio" << endl;\n    cout << string(55, \'-\') << endl;\n    \n    for(int size : sizes) {\n        // Generate random data\n        vector<int> data(size);\n        for(int i = 0; i < size; i++) {\n            data[i] = dis(gen);\n        }\n        \n        // Test Radix Sort\n        vector<int> radixData = data;\n        clock_t start = clock();\n        \n        // Radix Sort implementation\n        int maxVal = *max_element(radixData.begin(), radixData.end());\n        for(int exp = 1; maxVal / exp > 0; exp *= 10) {\n            vector<int> output(radixData.size());\n            int count[10] = {0};\n            \n            for(int num : radixData) count[(num / exp) % 10]++;\n            for(int i = 1; i < 10; i++) count[i] += count[i-1];\n            for(int i = radixData.size() - 1; i >= 0; i--) {\n                int digit = (radixData[i] / exp) % 10;\n                output[count[digit] - 1] = radixData[i];\n                count[digit]--;\n            }\n            radixData = output;\n        }\n        \n        clock_t end = clock();\n        double radixTime = double(end - start) / CLOCKS_PER_SEC * 1000;\n        \n        // Test Quick Sort (std::sort)\n        vector<int> quickData = data;\n        start = clock();\n        sort(quickData.begin(), quickData.end());\n        end = clock();\n        double quickTime = double(end - start) / CLOCKS_PER_SEC * 1000;\n        \n        cout << setw(10) << size \n             << setw(15) << fixed << setprecision(2) << radixTime << " ms"\n             << setw(15) << quickTime << " ms"\n             << setw(15) << radixTime/quickTime << endl;\n    }\n}\n\nint main() {\n    performanceTest();\n    return 0;\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"applications-of-radix-sort",children:"Applications of Radix Sort"}),"\n",(0,t.jsx)(e.h3,{id:"1-sorting-ip-addresses",children:"1. Sorting IP Addresses"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\nusing namespace std;\n\nstruct IPAddress {\n    int octet1, octet2, octet3, octet4;\n    \n    IPAddress(const string& ip) {\n        stringstream ss(ip);\n        char dot;\n        ss >> octet1 >> dot >> octet2 >> dot >> octet3 >> dot >> octet4;\n    }\n    \n    int toInt() const {\n        return (octet1 << 24) | (octet2 << 16) | (octet3 << 8) | octet4;\n    }\n    \n    string toString() const {\n        return to_string(octet1) + "." + to_string(octet2) + "." + \n               to_string(octet3) + "." + to_string(octet4);\n    }\n};\n\nvoid sortIPAddresses(vector<IPAddress>& ips) {\n    cout << "Sorting IP addresses using Radix Sort\\n" << endl;\n    \n    // Convert IPs to integers\n    vector<int> ipInts;\n    for(const auto& ip : ips) {\n        ipInts.push_back(ip.toInt());\n    }\n    \n    // Radix sort on the integers\n    int maxVal = *max_element(ipInts.begin(), ipInts.end());\n    for(int exp = 1; maxVal / exp > 0; exp *= 10) {\n        vector<int> output(ipInts.size());\n        int count[10] = {0};\n        \n        for(int num : ipInts) count[(num / exp) % 10]++;\n        for(int i = 1; i < 10; i++) count[i] += count[i-1];\n        for(int i = ipInts.size() - 1; i >= 0; i--) {\n            int digit = (ipInts[i] / exp) % 10;\n            output[count[digit] - 1] = ipInts[i];\n            count[digit]--;\n        }\n        ipInts = output;\n    }\n    \n    // Convert back to IPAddress objects\n    vector<IPAddress> sortedIPs;\n    for(int ipInt : ipInts) {\n        sortedIPs.push_back(IPAddress(\n            to_string((ipInt >> 24) & 0xFF) + "." +\n            to_string((ipInt >> 16) & 0xFF) + "." +\n            to_string((ipInt >> 8) & 0xFF) + "." +\n            to_string(ipInt & 0xFF)\n        ));\n    }\n    \n    ips = sortedIPs;\n}\n\nint main() {\n    vector<IPAddress> ips = {\n        IPAddress("192.168.1.1"),\n        IPAddress("10.0.0.1"),\n        IPAddress("172.16.0.1"),\n        IPAddress("192.168.0.1"),\n        IPAddress("10.0.0.2"),\n        IPAddress("172.16.0.10")\n    };\n    \n    cout << "Original IPs:" << endl;\n    for(const auto& ip : ips) {\n        cout << "  " << ip.toString() << endl;\n    }\n    \n    sortIPAddresses(ips);\n    \n    cout << "\\nSorted IPs:" << endl;\n    for(const auto& ip : ips) {\n        cout << "  " << ip.toString() << endl;\n    }\n    \n    return 0;\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"2-sorting-dates-yyyymmdd-format",children:"2. Sorting Dates (YYYYMMDD format)"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nvoid sortDates(vector<int>& dates) {\n    cout << "Sorting dates (YYYYMMDD format) using Radix Sort\\n" << endl;\n    \n    // Sort by day (last 2 digits)\n    for(int exp = 1; exp <= 100; exp *= 10) {\n        vector<int> output(dates.size());\n        int count[10] = {0};\n        \n        for(int date : dates) count[(date / exp) % 10]++;\n        for(int i = 1; i < 10; i++) count[i] += count[i-1];\n        for(int i = dates.size() - 1; i >= 0; i--) {\n            int digit = (dates[i] / exp) % 10;\n            output[count[digit] - 1] = dates[i];\n            count[digit]--;\n        }\n        dates = output;\n    }\n    \n    // Sort by month (digits 3-4 from right)\n    for(int exp = 100; exp <= 10000; exp *= 10) {\n        vector<int> output(dates.size());\n        int count[10] = {0};\n        \n        for(int date : dates) count[(date / exp) % 10]++;\n        for(int i = 1; i < 10; i++) count[i] += count[i-1];\n        for(int i = dates.size() - 1; i >= 0; i--) {\n            int digit = (dates[i] / exp) % 10;\n            output[count[digit] - 1] = dates[i];\n            count[digit]--;\n        }\n        dates = output;\n    }\n    \n    // Sort by year (remaining digits)\n    for(int exp = 10000; exp <= 1000000; exp *= 10) {\n        vector<int> output(dates.size());\n        int count[10] = {0};\n        \n        for(int date : dates) count[(date / exp) % 10]++;\n        for(int i = 1; i < 10; i++) count[i] += count[i-1];\n        for(int i = dates.size() - 1; i >= 0; i--) {\n            int digit = (dates[i] / exp) % 10;\n            output[count[digit] - 1] = dates[i];\n            count[digit]--;\n        }\n        dates = output;\n    }\n}\n\nint main() {\n    vector<int> dates = {\n        20231225,  // Christmas 2023\n        20240101,  // New Year 2024\n        20231031,  // Halloween 2023\n        20231201,  // December 1, 2023\n        20231115,  // November 15, 2023\n        20240214   // Valentine\'s Day 2024\n    };\n    \n    cout << "Original dates:" << endl;\n    for(int date : dates) {\n        string dateStr = to_string(date);\n        cout << "  " << dateStr.substr(0,4) << "-" \n             << dateStr.substr(4,2) << "-" \n             << dateStr.substr(6,2) << endl;\n    }\n    \n    sortDates(dates);\n    \n    cout << "\\nSorted dates:" << endl;\n    for(int date : dates) {\n        string dateStr = to_string(date);\n        cout << "  " << dateStr.substr(0,4) << "-" \n             << dateStr.substr(4,2) << "-" \n             << dateStr.substr(6,2) << endl;\n    }\n    \n    return 0;\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"optimizations-and-best-practices",children:"Optimizations and Best Practices"}),"\n",(0,t.jsx)(e.h3,{id:"1-early-termination",children:"1. Early Termination"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:"void optimizedRadixSort(vector<int>& arr) {\n    if(arr.size() <= 1) return;\n    \n    // Find min and max\n    int minVal = arr[0], maxVal = arr[0];\n    for(int num : arr) {\n        if(num < minVal) minVal = num;\n        if(num > maxVal) maxVal = num;\n    }\n    \n    // If range is small, use Counting Sort instead\n    if(maxVal - minVal < 1000) {\n        vector<int> count(maxVal - minVal + 1, 0);\n        for(int num : arr) count[num - minVal]++;\n        \n        int index = 0;\n        for(int i = 0; i < count.size(); i++) {\n            while(count[i] > 0) {\n                arr[index++] = i + minVal;\n                count[i]--;\n            }\n        }\n        return;\n    }\n    \n    // Otherwise use Radix Sort\n    for(int exp = 1; maxVal / exp > 0; exp *= 10) {\n        vector<int> output(arr.size());\n        int count[10] = {0};\n        \n        for(int num : arr) count[(num / exp) % 10]++;\n        for(int i = 1; i < 10; i++) count[i] += count[i-1];\n        for(int i = arr.size() - 1; i >= 0; i--) {\n            int digit = (arr[i] / exp) % 10;\n            output[count[digit] - 1] = arr[i];\n            count[digit]--;\n        }\n        arr = output;\n    }\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"2-hybrid-approach-with-insertion-sort",children:"2. Hybrid Approach with Insertion Sort"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:"void hybridRadixSort(vector<int>& arr, int threshold = 100) {\n    if(arr.size() <= threshold) {\n        // Use insertion sort for small arrays\n        for(int i = 1; i < arr.size(); i++) {\n            int key = arr[i];\n            int j = i - 1;\n            while(j >= 0 && arr[j] > key) {\n                arr[j + 1] = arr[j];\n                j--;\n            }\n            arr[j + 1] = key;\n        }\n        return;\n    }\n    \n    // Use Radix Sort for larger arrays\n    int maxVal = *max_element(arr.begin(), arr.end());\n    for(int exp = 1; maxVal / exp > 0; exp *= 10) {\n        vector<int> output(arr.size());\n        int count[10] = {0};\n        \n        for(int num : arr) count[(num / exp) % 10]++;\n        for(int i = 1; i < 10; i++) count[i] += count[i-1];\n        for(int i = arr.size() - 1; i >= 0; i--) {\n            int digit = (arr[i] / exp) % 10;\n            output[count[digit] - 1] = arr[i];\n            count[digit]--;\n        }\n        arr = output;\n    }\n}\n"})}),"\n",(0,t.jsx)(e.h2,{id:"common-interview-questions",children:"Common Interview Questions"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Implement Radix Sort"})," for integers"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Sort an array of strings"})," using Radix Sort"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Compare Radix Sort with Quick Sort"})," for large datasets"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Handle negative numbers"})," in Radix Sort"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"What's the time complexity"})," of Radix Sort and when is it optimal?"]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"summary-1",children:"Summary"}),"\n",(0,t.jsx)(e.p,{children:"Radix Sort is a powerful non-comparative sorting algorithm that excels when:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Sorting integers or fixed-length keys"}),"\n",(0,t.jsx)(e.li,{children:"The number of digits is small compared to the number of elements"}),"\n",(0,t.jsx)(e.li,{children:"Stability is required"}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Key Advantages:"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"O(d*(n + k)) time complexity, which can be better than O(n log n) for certain data"}),"\n",(0,t.jsx)(e.li,{children:"Stable sorting algorithm"}),"\n",(0,t.jsx)(e.li,{children:"Works well with fixed-length keys like integers, strings, dates"}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Key Limitations:"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Only works with integer keys or fixed-length keys"}),"\n",(0,t.jsx)(e.li,{children:"Requires additional memory O(n + k)"}),"\n",(0,t.jsx)(e.li,{children:"Not as cache-friendly as comparison sorts"}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Best Use Cases:"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Sorting large sets of integers with limited range"}),"\n",(0,t.jsx)(e.li,{children:"Sorting IP addresses, dates, or other fixed-format data"}),"\n",(0,t.jsx)(e.li,{children:"When stability is crucial and keys are integers"}),"\n"]}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.em,{children:"[Next: DSA Merge Sort, Linear Search, Binary Search...]"})}),"\n",(0,t.jsx)(e.h1,{id:"dsa-merge-sort---complete-c-guide",children:"DSA Merge Sort - Complete C++ Guide"}),"\n",(0,t.jsx)(e.h2,{id:"introduction-to-merge-sort",children:"Introduction to Merge Sort"}),"\n",(0,t.jsxs)(e.p,{children:["Merge Sort is a ",(0,t.jsx)(e.strong,{children:"divide-and-conquer"})," algorithm that divides the input array into two halves, recursively sorts them, and then merges the sorted halves. It's one of the most efficient and reliable sorting algorithms."]}),"\n",(0,t.jsx)(e.h3,{id:"key-characteristics-3",children:"Key Characteristics:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Time Complexity"}),": O(n log n) in all cases"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Space Complexity"}),": O(n) additional space"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Stable"}),": Yes, maintains relative order of equal elements"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Not In-place"}),": Requires additional memory"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Recursive"}),": Naturally implemented using recursion"]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"how-merge-sort-works",children:"How Merge Sort Works"}),"\n",(0,t.jsx)(e.h3,{id:"the-three-step-process-1",children:"The Three-Step Process:"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Divide"}),": Split the array into two equal halves"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Conquer"}),": Recursively sort both halves"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Combine"}),": Merge the two sorted halves into one sorted array"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"visual-example-3",children:"Visual Example:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"Original: [38, 27, 43, 3, 9, 82, 10]\n\nDivide:\n[38, 27, 43, 3] | [9, 82, 10]\n\nDivide further:\n[38, 27] | [43, 3] | [9, 82] | [10]\n\nDivide until single elements:\n[38] | [27] | [43] | [3] | [9] | [82] | [10]\n\nMerge sorted pairs:\n[27, 38] | [3, 43] | [9, 82] | [10]\n\nContinue merging:\n[3, 27, 38, 43] | [9, 10, 82]\n\nFinal merge:\n[3, 9, 10, 27, 38, 43, 82]\n"})}),"\n",(0,t.jsx)(e.h2,{id:"basic-merge-sort-implementation",children:"Basic Merge Sort Implementation"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Merge two sorted subarrays\nvoid merge(int arr[], int left, int mid, int right) {\n    int n1 = mid - left + 1;    // Size of left subarray\n    int n2 = right - mid;       // Size of right subarray\n    \n    // Create temporary arrays\n    vector<int> L(n1), R(n2);\n    \n    // Copy data to temp arrays\n    for(int i = 0; i < n1; i++) {\n        L[i] = arr[left + i];\n    }\n    for(int j = 0; j < n2; j++) {\n        R[j] = arr[mid + 1 + j];\n    }\n    \n    // Merge temp arrays back into arr[left..right]\n    int i = 0, j = 0, k = left;\n    \n    while(i < n1 && j < n2) {\n        if(L[i] <= R[j]) {\n            arr[k] = L[i];\n            i++;\n        } else {\n            arr[k] = R[j];\n            j++;\n        }\n        k++;\n    }\n    \n    // Copy remaining elements of L[]\n    while(i < n1) {\n        arr[k] = L[i];\n        i++;\n        k++;\n    }\n    \n    // Copy remaining elements of R[]\n    while(j < n2) {\n        arr[k] = R[j];\n        j++;\n        k++;\n    }\n}\n\n// Main merge sort function\nvoid mergeSort(int arr[], int left, int right) {\n    if(left < right) {\n        int mid = left + (right - left) / 2;\n        \n        // Sort first and second halves\n        mergeSort(arr, left, mid);\n        mergeSort(arr, mid + 1, right);\n        \n        // Merge sorted halves\n        merge(arr, left, mid, right);\n    }\n}\n\nvoid printArray(int arr[], int n) {\n    for(int i = 0; i < n; i++) {\n        cout << arr[i] << " ";\n    }\n    cout << endl;\n}\n\nint main() {\n    int arr[] = {12, 11, 13, 5, 6, 7};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    \n    cout << "Original array: ";\n    printArray(arr, n);\n    \n    mergeSort(arr, 0, n - 1);\n    \n    cout << "Sorted array: ";\n    printArray(arr, n);\n    \n    return 0;\n}\n'})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Output:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"Original array: 12 11 13 5 6 7 \nSorted array: 5 6 7 11 12 13\n"})}),"\n",(0,t.jsx)(e.h2,{id:"detailed-step-by-step-visualization-3",children:"Detailed Step-by-Step Visualization"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <vector>\n#include <iomanip>\nusing namespace std;\n\nvoid printArrayWithMarkers(int arr[], int left, int right, int mid = -1) {\n    for(int i = left; i <= right; i++) {\n        if(i == mid) cout << "[" << arr[i] << "] ";\n        else if(i == left && left == right) cout << "{" << arr[i] << "} ";\n        else cout << arr[i] << " ";\n    }\n}\n\nvoid mergeVisual(int arr[], int left, int mid, int right, int depth) {\n    string indent(depth * 4, \' \');\n    \n    cout << indent << "Merging: L[";\n    printArrayWithMarkers(arr, left, mid);\n    cout << "] and R[";\n    printArrayWithMarkers(arr, mid + 1, right);\n    cout << "]" << endl;\n    \n    int n1 = mid - left + 1;\n    int n2 = right - mid;\n    \n    vector<int> L(n1), R(n2);\n    \n    for(int i = 0; i < n1; i++) L[i] = arr[left + i];\n    for(int j = 0; j < n2; j++) R[j] = arr[mid + 1 + j];\n    \n    int i = 0, j = 0, k = left;\n    \n    cout << indent << "  Left array: ";\n    for(int val : L) cout << val << " ";\n    cout << endl;\n    \n    cout << indent << "  Right array: ";\n    for(int val : R) cout << val << " ";\n    cout << endl;\n    \n    cout << indent << "  Merge process: ";\n    \n    while(i < n1 && j < n2) {\n        if(L[i] <= R[j]) {\n            arr[k] = L[i];\n            cout << L[i] << " ";\n            i++;\n        } else {\n            arr[k] = R[j];\n            cout << R[j] << " ";\n            j++;\n        }\n        k++;\n    }\n    \n    while(i < n1) {\n        arr[k] = L[i];\n        cout << L[i] << " ";\n        i++;\n        k++;\n    }\n    \n    while(j < n2) {\n        arr[k] = R[j];\n        cout << R[j] << " ";\n        j++;\n        k++;\n    }\n    \n    cout << endl;\n    \n    cout << indent << "  Result: [";\n    for(int idx = left; idx <= right; idx++) {\n        cout << arr[idx] << " ";\n    }\n    cout << "]" << endl;\n}\n\nvoid mergeSortVisual(int arr[], int left, int right, int depth = 0) {\n    string indent(depth * 4, \' \');\n    \n    cout << indent << "mergeSort(arr, " << left << ", " << right << ")" << endl;\n    cout << indent << "Current segment: [";\n    printArrayWithMarkers(arr, left, right);\n    cout << "]" << endl;\n    \n    if(left < right) {\n        int mid = left + (right - left) / 2;\n        \n        cout << indent << "Divide at mid = " << mid << endl;\n        cout << indent << string(40, \'-\') << endl;\n        \n        // Recursively sort first half\n        mergeSortVisual(arr, left, mid, depth + 1);\n        \n        // Recursively sort second half\n        mergeSortVisual(arr, mid + 1, right, depth + 1);\n        \n        // Merge sorted halves\n        cout << indent << string(40, \'-\') << endl;\n        cout << indent << "Now merging..." << endl;\n        mergeVisual(arr, left, mid, right, depth);\n    } else {\n        cout << indent << "Base case (single element)" << endl;\n    }\n    \n    cout << indent << string(40, \'=\') << endl;\n}\n\nint main() {\n    int arr[] = {38, 27, 43, 3, 9, 82, 10};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    \n    cout << "=== Merge Sort Step-by-Step Visualization ===" << endl;\n    cout << "Original array: ";\n    for(int i = 0; i < n; i++) cout << arr[i] << " ";\n    cout << endl << endl;\n    \n    mergeSortVisual(arr, 0, n - 1);\n    \n    cout << "\\nFinal sorted array: ";\n    for(int i = 0; i < n; i++) cout << arr[i] << " ";\n    cout << endl;\n    \n    return 0;\n}\n'})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Output:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"=== Merge Sort Step-by-Step Visualization ===\nOriginal array: 38 27 43 3 9 82 10 \n\nmergeSort(arr, 0, 6)\nCurrent segment: [38 27 43 3 9 82 10 ]\nDivide at mid = 3\n----------------------------------------\n    mergeSort(arr, 0, 3)\n    Current segment: [38 27 43 3 ]\n    Divide at mid = 1\n    ----------------------------------------\n        mergeSort(arr, 0, 1)\n        Current segment: [38 27 ]\n        Divide at mid = 0\n        ----------------------------------------\n            mergeSort(arr, 0, 0)\n            Current segment: [{38} ]\n            Base case (single element)\n            ========================================\n            mergeSort(arr, 1, 1)\n            Current segment: [{27} ]\n            Base case (single element)\n            ========================================\n        Now merging...\n        Merging: L[38 ] and R[27 ]\n          Left array: 38 \n          Right array: 27 \n          Merge process: 27 38 \n          Result: [27 38 ]\n        ========================================\n    ... (continues with detailed merging steps)\n"})}),"\n",(0,t.jsx)(e.h2,{id:"iterative-merge-sort",children:"Iterative Merge Sort"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvoid iterativeMergeSort(int arr[], int n) {\n    cout << "Iterative Merge Sort" << endl;\n    \n    // Create a temporary array\n    vector<int> temp(n);\n    \n    // Start with subarrays of size 1, then 2, 4, 8...\n    for(int currSize = 1; currSize < n; currSize *= 2) {\n        cout << "\\nCurrent subarray size: " << currSize << endl;\n        \n        for(int leftStart = 0; leftStart < n; leftStart += 2 * currSize) {\n            int mid = min(leftStart + currSize - 1, n - 1);\n            int rightEnd = min(leftStart + 2 * currSize - 1, n - 1);\n            \n            cout << "  Merging [" << leftStart << "-" << mid \n                 << "] and [" << mid+1 << "-" << rightEnd << "]" << endl;\n            \n            int i = leftStart;\n            int j = mid + 1;\n            int k = leftStart;\n            \n            // Merge two subarrays into temp\n            while(i <= mid && j <= rightEnd) {\n                if(arr[i] <= arr[j]) {\n                    temp[k++] = arr[i++];\n                } else {\n                    temp[k++] = arr[j++];\n                }\n            }\n            \n            // Copy remaining elements\n            while(i <= mid) {\n                temp[k++] = arr[i++];\n            }\n            while(j <= rightEnd) {\n                temp[k++] = arr[j++];\n            }\n            \n            // Copy merged subarray back to original\n            for(int idx = leftStart; idx <= rightEnd; idx++) {\n                arr[idx] = temp[idx];\n            }\n            \n            cout << "    Result: ";\n            for(int idx = leftStart; idx <= rightEnd; idx++) {\n                cout << arr[idx] << " ";\n            }\n            cout << endl;\n        }\n        \n        cout << "Array after size " << currSize << " passes: ";\n        for(int i = 0; i < n; i++) {\n            cout << arr[i] << " ";\n        }\n        cout << endl;\n    }\n}\n\nint main() {\n    int arr[] = {64, 34, 25, 12, 22, 11, 90};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    \n    cout << "Original array: ";\n    for(int i = 0; i < n; i++) {\n        cout << arr[i] << " ";\n    }\n    cout << endl;\n    \n    iterativeMergeSort(arr, n);\n    \n    cout << "\\nSorted array: ";\n    for(int i = 0; i < n; i++) {\n        cout << arr[i] << " ";\n    }\n    cout << endl;\n    \n    return 0;\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"merge-sort-complexity-analysis",children:"Merge Sort Complexity Analysis"}),"\n",(0,t.jsx)(e.h3,{id:"time-complexity-analysis",children:"Time Complexity Analysis:"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Divide Step"}),":"]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Finding mid takes O(1)"}),"\n",(0,t.jsx)(e.li,{children:"Dividing array into halves: O(1)"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Conquer Step"}),":"]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Two recursive calls on half the size: 2T(n/2)"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Combine Step"}),":"]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Merging two sorted arrays: O(n)"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Recurrence Relation:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"T(n) = 2T(n/2) + O(n)\n"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Solving using Master Theorem:"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"a = 2 (number of subproblems)"}),"\n",(0,t.jsx)(e.li,{children:"b = 2 (factor of size reduction)"}),"\n",(0,t.jsx)(e.li,{children:"f(n) = O(n) = n\xb9"}),"\n",(0,t.jsx)(e.li,{children:"Since f(n) = \u0398(n\xb9) and log_b(a) = log\u2082(2) = 1"}),"\n",(0,t.jsx)(e.li,{children:"Case 2: T(n) = \u0398(n log n)"}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"space-complexity-3",children:"Space Complexity:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Recursive version"}),": O(n) for temp arrays + O(log n) recursion stack"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Iterative version"}),": O(n) for temp arrays"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Total"}),": O(n)"]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"optimization-techniques",children:"Optimization Techniques"}),"\n",(0,t.jsx)(e.h3,{id:"1-use-insertion-sort-for-small-subarrays",children:"1. Use Insertion Sort for Small Subarrays"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:"const int INSERTION_THRESHOLD = 16;\n\nvoid insertionSort(int arr[], int left, int right) {\n    for(int i = left + 1; i <= right; i++) {\n        int key = arr[i];\n        int j = i - 1;\n        \n        while(j >= left && arr[j] > key) {\n            arr[j + 1] = arr[j];\n            j--;\n        }\n        arr[j + 1] = key;\n    }\n}\n\nvoid optimizedMergeSort(int arr[], int left, int right) {\n    // Use insertion sort for small arrays\n    if(right - left + 1 <= INSERTION_THRESHOLD) {\n        insertionSort(arr, left, right);\n        return;\n    }\n    \n    if(left < right) {\n        int mid = left + (right - left) / 2;\n        \n        optimizedMergeSort(arr, left, mid);\n        optimizedMergeSort(arr, mid + 1, right);\n        \n        // Merge only if necessary\n        if(arr[mid] > arr[mid + 1]) {\n            merge(arr, left, mid, right);\n        }\n    }\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"2-avoid-repeated-memory-allocation",children:"2. Avoid Repeated Memory Allocation"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:"void mergeSortOptimized(int arr[], int left, int right, vector<int>& temp) {\n    if(left >= right) return;\n    \n    int mid = left + (right - left) / 2;\n    \n    mergeSortOptimized(arr, left, mid, temp);\n    mergeSortOptimized(arr, mid + 1, right, temp);\n    \n    // Merge using pre-allocated temp array\n    int i = left, j = mid + 1, k = left;\n    \n    while(i <= mid && j <= right) {\n        if(arr[i] <= arr[j]) {\n            temp[k++] = arr[i++];\n        } else {\n            temp[k++] = arr[j++];\n        }\n    }\n    \n    while(i <= mid) temp[k++] = arr[i++];\n    while(j <= right) temp[k++] = arr[j++];\n    \n    // Copy back\n    for(int idx = left; idx <= right; idx++) {\n        arr[idx] = temp[idx];\n    }\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"3-natural-merge-sort-adaptive",children:"3. Natural Merge Sort (Adaptive)"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:"int findNextRun(int arr[], int n, int start) {\n    if(start >= n - 1) return n;\n    \n    int i = start;\n    while(i < n - 1 && arr[i] <= arr[i + 1]) {\n        i++;\n    }\n    return i + 1;\n}\n\nvoid naturalMergeSort(int arr[], int n) {\n    vector<int> temp(n);\n    \n    while(true) {\n        int start = 0;\n        bool sorted = true;\n        \n        while(start < n) {\n            int mid = findNextRun(arr, n, start);\n            int end = findNextRun(arr, n, mid);\n            \n            if(end <= n) {\n                // Merge arr[start..mid-1] and arr[mid..end-1]\n                int i = start, j = mid, k = start;\n                \n                while(i < mid && j < end) {\n                    if(arr[i] <= arr[j]) {\n                        temp[k++] = arr[i++];\n                    } else {\n                        temp[k++] = arr[j++];\n                    }\n                }\n                \n                while(i < mid) temp[k++] = arr[i++];\n                while(j < end) temp[k++] = arr[j++];\n                \n                sorted = false;\n                start = end;\n            } else {\n                break;\n            }\n        }\n        \n        // Copy back\n        for(int i = 0; i < n; i++) {\n            arr[i] = temp[i];\n        }\n        \n        if(sorted) break;\n    }\n}\n"})}),"\n",(0,t.jsx)(e.h2,{id:"merge-sort-for-linked-lists",children:"Merge Sort for Linked Lists"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\nusing namespace std;\n\nstruct Node {\n    int data;\n    Node* next;\n    Node(int val) : data(val), next(nullptr) {}\n};\n\nclass LinkedListMergeSort {\nprivate:\n    Node* head;\n    \n    // Find middle using slow-fast pointer technique\n    Node* findMiddle(Node* head) {\n        if(!head) return head;\n        \n        Node* slow = head;\n        Node* fast = head->next;\n        \n        while(fast && fast->next) {\n            slow = slow->next;\n            fast = fast->next->next;\n        }\n        \n        return slow;\n    }\n    \n    // Merge two sorted linked lists\n    Node* merge(Node* left, Node* right) {\n        if(!left) return right;\n        if(!right) return left;\n        \n        Node* result = nullptr;\n        \n        if(left->data <= right->data) {\n            result = left;\n            result->next = merge(left->next, right);\n        } else {\n            result = right;\n            result->next = merge(left, right->next);\n        }\n        \n        return result;\n    }\n    \npublic:\n    LinkedListMergeSort() : head(nullptr) {}\n    \n    void push(int data) {\n        Node* newNode = new Node(data);\n        newNode->next = head;\n        head = newNode;\n    }\n    \n    Node* mergeSort(Node* node) {\n        if(!node || !node->next) return node;\n        \n        // Find middle\n        Node* middle = findMiddle(node);\n        Node* nextToMiddle = middle->next;\n        \n        // Split into two halves\n        middle->next = nullptr;\n        \n        // Recursively sort both halves\n        Node* left = mergeSort(node);\n        Node* right = mergeSort(nextToMiddle);\n        \n        // Merge sorted halves\n        return merge(left, right);\n    }\n    \n    void sort() {\n        head = mergeSort(head);\n    }\n    \n    void printList() {\n        Node* current = head;\n        while(current) {\n            cout << current->data << " ";\n            current = current->next;\n        }\n        cout << endl;\n    }\n};\n\nint main() {\n    LinkedListMergeSort list;\n    \n    // Add elements in reverse order\n    list.push(15);\n    list.push(10);\n    list.push(5);\n    list.push(20);\n    list.push(3);\n    list.push(2);\n    \n    cout << "Original linked list: ";\n    list.printList();\n    \n    list.sort();\n    \n    cout << "Sorted linked list: ";\n    list.printList();\n    \n    return 0;\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"external-merge-sort-for-large-files",children:"External Merge Sort (For Large Files)"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <fstream>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\nclass ExternalMergeSort {\nprivate:\n    int chunkSize;\n    string inputFile;\n    string outputFile;\n    \n    void createSortedChunks() {\n        ifstream inFile(inputFile, ios::binary);\n        vector<int> buffer(chunkSize);\n        int chunkNum = 0;\n        \n        cout << "Creating sorted chunks..." << endl;\n        \n        while(true) {\n            // Read chunk\n            inFile.read((char*)buffer.data(), chunkSize * sizeof(int));\n            int count = inFile.gcount() / sizeof(int);\n            \n            if(count == 0) break;\n            \n            // Sort chunk\n            sort(buffer.begin(), buffer.begin() + count);\n            \n            // Write sorted chunk to temp file\n            string chunkFile = "chunk_" + to_string(chunkNum++) + ".dat";\n            ofstream outFile(chunkFile, ios::binary);\n            outFile.write((char*)buffer.data(), count * sizeof(int));\n            outFile.close();\n            \n            cout << "Created chunk " << chunkFile << " with " \n                 << count << " elements" << endl;\n        }\n        \n        inFile.close();\n    }\n    \n    struct HeapNode {\n        int value;\n        int chunkIndex;\n        \n        bool operator>(const HeapNode& other) const {\n            return value > other.value;\n        }\n    };\n    \n    void kWayMerge(int numChunks) {\n        cout << "\\nPerforming " << numChunks << "-way merge..." << endl;\n        \n        vector<ifstream> chunkFiles(numChunks);\n        priority_queue<HeapNode, vector<HeapNode>, greater<HeapNode>> minHeap;\n        \n        // Open all chunk files\n        for(int i = 0; i < numChunks; i++) {\n            string chunkFile = "chunk_" + to_string(i) + ".dat";\n            chunkFiles[i].open(chunkFile, ios::binary);\n            \n            // Read first element from each chunk\n            int value;\n            if(chunkFiles[i].read((char*)&value, sizeof(int))) {\n                minHeap.push({value, i});\n            }\n        }\n        \n        ofstream outFile(outputFile, ios::binary);\n        \n        // Perform k-way merge\n        while(!minHeap.empty()) {\n            HeapNode smallest = minHeap.top();\n            minHeap.pop();\n            \n            // Write smallest element to output\n            outFile.write((char*)&smallest.value, sizeof(int));\n            \n            // Read next element from the same chunk\n            int nextValue;\n            if(chunkFiles[smallest.chunkIndex].read((char*)&nextValue, sizeof(int))) {\n                minHeap.push({nextValue, smallest.chunkIndex});\n            }\n        }\n        \n        // Close files\n        for(auto& file : chunkFiles) {\n            file.close();\n        }\n        outFile.close();\n        \n        cout << "Merge complete. Output written to " << outputFile << endl;\n    }\n    \npublic:\n    ExternalMergeSort(string input, string output, int chunk) \n        : inputFile(input), outputFile(output), chunkSize(chunk) {}\n    \n    void sort() {\n        createSortedChunks();\n        \n        // Count chunks (simplified - in real implementation, count them)\n        int numChunks = 3; // This should be calculated\n        \n        kWayMerge(numChunks);\n        \n        // Cleanup temp files\n        for(int i = 0; i < numChunks; i++) {\n            remove(("chunk_" + to_string(i) + ".dat").c_str());\n        }\n    }\n};\n\nint main() {\n    // Note: This is a simplified example. In practice, you would:\n    // 1. Generate a large binary file with random integers\n    // 2. Use appropriate chunk size based on available memory\n    // 3. Handle variable chunk sizes\n    \n    cout << "External Merge Sort Concept Demonstration" << endl;\n    cout << "This demonstrates the algorithm structure." << endl;\n    cout << "In practice, you would work with actual file I/O." << endl;\n    \n    return 0;\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"applications-of-merge-sort",children:"Applications of Merge Sort"}),"\n",(0,t.jsx)(e.h3,{id:"1-counting-inversions",children:"1. Counting Inversions"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <vector>\nusing namespace std;\n\nlong long mergeAndCount(int arr[], int temp[], int left, int mid, int right) {\n    int i = left, j = mid + 1, k = left;\n    long long inversions = 0;\n    \n    while(i <= mid && j <= right) {\n        if(arr[i] <= arr[j]) {\n            temp[k++] = arr[i++];\n        } else {\n            // arr[i] > arr[j], so all remaining in left are inversions\n            temp[k++] = arr[j++];\n            inversions += (mid - i + 1);\n        }\n    }\n    \n    while(i <= mid) temp[k++] = arr[i++];\n    while(j <= right) temp[k++] = arr[j++];\n    \n    for(int idx = left; idx <= right; idx++) {\n        arr[idx] = temp[idx];\n    }\n    \n    return inversions;\n}\n\nlong long countInversions(int arr[], int temp[], int left, int right) {\n    long long inversions = 0;\n    \n    if(left < right) {\n        int mid = left + (right - left) / 2;\n        \n        inversions += countInversions(arr, temp, left, mid);\n        inversions += countInversions(arr, temp, mid + 1, right);\n        inversions += mergeAndCount(arr, temp, left, mid, right);\n    }\n    \n    return inversions;\n}\n\nint main() {\n    int arr[] = {1, 20, 6, 4, 5};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    vector<int> temp(n);\n    \n    cout << "Array: ";\n    for(int i = 0; i < n; i++) cout << arr[i] << " ";\n    cout << endl;\n    \n    long long inversions = countInversions(arr, temp.data(), 0, n - 1);\n    \n    cout << "Number of inversions: " << inversions << endl;\n    cout << "Sorted array: ";\n    for(int i = 0; i < n; i++) cout << arr[i] << " ";\n    cout << endl;\n    \n    return 0;\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"2-external-sorting-sort-merge-join",children:"2. External Sorting (Sort-Merge Join)"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<pair<int, string>> sortMergeJoin(\n    vector<pair<int, string>>& table1,\n    vector<pair<int, string>>& table2\n) {\n    // Sort both tables by key using merge sort\n    sort(table1.begin(), table1.end());\n    sort(table2.begin(), table2.end());\n    \n    vector<pair<int, string>> result;\n    int i = 0, j = 0;\n    \n    cout << "Performing Sort-Merge Join..." << endl;\n    \n    while(i < table1.size() && j < table2.size()) {\n        if(table1[i].first < table2[j].first) {\n            i++;\n        } else if(table1[i].first > table2[j].first) {\n            j++;\n        } else {\n            // Keys match - join\n            cout << "Match found: Key=" << table1[i].first \n                 << ", Value1=" << table1[i].second\n                 << ", Value2=" << table2[j].second << endl;\n            \n            result.push_back({table1[i].first, \n                            table1[i].second + ":" + table2[j].second});\n            \n            // Handle duplicates\n            int tempI = i, tempJ = j;\n            while(tempI + 1 < table1.size() && \n                  table1[tempI + 1].first == table1[i].first) {\n                tempI++;\n                result.push_back({table1[tempI].first, \n                                table1[tempI].second + ":" + table2[j].second});\n            }\n            \n            while(tempJ + 1 < table2.size() && \n                  table2[tempJ + 1].first == table2[j].first) {\n                tempJ++;\n                result.push_back({table1[i].first, \n                                table1[i].second + ":" + table2[tempJ].second});\n            }\n            \n            i++;\n            j++;\n        }\n    }\n    \n    return result;\n}\n\nint main() {\n    vector<pair<int, string>> employees = {\n        {101, "Alice"},\n        {102, "Bob"},\n        {103, "Charlie"},\n        {101, "Anna"}  // Duplicate key\n    };\n    \n    vector<pair<int, string>> departments = {\n        {101, "Engineering"},\n        {102, "Sales"},\n        {104, "Marketing"},\n        {101, "R&D"}  // Duplicate key\n    };\n    \n    auto joined = sortMergeJoin(employees, departments);\n    \n    cout << "\\nJoin Result:" << endl;\n    for(auto& row : joined) {\n        cout << "ID: " << row.first << ", Combined: " << row.second << endl;\n    }\n    \n    return 0;\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"performance-comparison-3",children:"Performance Comparison"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <chrono>\n#include <random>\nusing namespace std;\nusing namespace chrono;\n\nvoid testSortingAlgorithms() {\n    random_device rd;\n    mt19937 gen(rd());\n    uniform_int_distribution<> dis(1, 1000000);\n    \n    vector<int> sizes = {1000, 10000, 50000, 100000, 500000};\n    \n    cout << "Sorting Algorithm Performance Comparison\\n" << endl;\n    cout << "Size\\t\\tMerge Sort\\tQuick Sort\\tstd::sort" << endl;\n    cout << string(60, \'-\') << endl;\n    \n    for(int size : sizes) {\n        // Generate random data\n        vector<int> data(size);\n        for(int i = 0; i < size; i++) {\n            data[i] = dis(gen);\n        }\n        \n        // Test Merge Sort\n        vector<int> mergeData = data;\n        auto start = high_resolution_clock::now();\n        \n        // Merge Sort implementation\n        vector<int> temp(size);\n        auto mergeSortFunc = [&](auto&& self, int left, int right) -> void {\n            if(left >= right) return;\n            \n            int mid = left + (right - left) / 2;\n            self(self, left, mid);\n            self(self, mid + 1, right);\n            \n            int i = left, j = mid + 1, k = left;\n            while(i <= mid && j <= right) {\n                if(mergeData[i] <= mergeData[j]) {\n                    temp[k++] = mergeData[i++];\n                } else {\n                    temp[k++] = mergeData[j++];\n                }\n            }\n            while(i <= mid) temp[k++] = mergeData[i++];\n            while(j <= right) temp[k++] = mergeData[j++];\n            \n            for(int idx = left; idx <= right; idx++) {\n                mergeData[idx] = temp[idx];\n            }\n        };\n        \n        mergeSortFunc(mergeSortFunc, 0, size - 1);\n        auto end = high_resolution_clock::now();\n        auto mergeTime = duration_cast<microseconds>(end - start).count() / 1000.0;\n        \n        // Test Quick Sort (naive implementation for comparison)\n        vector<int> quickData = data;\n        start = high_resolution_clock::now();\n        sort(quickData.begin(), quickData.end());  // Using std::sort\n        end = high_resolution_clock::now();\n        auto quickTime = duration_cast<microseconds>(end - start).count() / 1000.0;\n        \n        // Test std::sort (usually introsort)\n        vector<int> stdData = data;\n        start = high_resolution_clock::now();\n        sort(stdData.begin(), stdData.end());\n        end = high_resolution_clock::now();\n        auto stdTime = duration_cast<microseconds>(end - start).count() / 1000.0;\n        \n        cout << size << "\\t\\t" \n             << fixed << setprecision(2) \n             << mergeTime << " ms\\t\\t"\n             << quickTime << " ms\\t\\t"\n             << stdTime << " ms" << endl;\n    }\n}\n\nint main() {\n    testSortingAlgorithms();\n    return 0;\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"common-interview-questions-1",children:"Common Interview Questions"}),"\n",(0,t.jsx)(e.h3,{id:"1-implement-merge-sort",children:"1. Implement Merge Sort"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:"// Basic implementation as shown above\n"})}),"\n",(0,t.jsx)(e.h3,{id:"2-count-inversions-in-an-array",children:"2. Count Inversions in an Array"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:"// Shown in applications section\n"})}),"\n",(0,t.jsx)(e.h3,{id:"3-sort-a-linked-list-using-merge-sort",children:"3. Sort a Linked List using Merge Sort"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:"// Shown in linked list section\n"})}),"\n",(0,t.jsx)(e.h3,{id:"4-external-sort-implementation",children:"4. External Sort Implementation"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:"// Concept shown in external merge sort section\n"})}),"\n",(0,t.jsx)(e.h3,{id:"5-merge-k-sorted-arrays",children:"5. Merge k Sorted Arrays"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:"#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nvector<int> mergeKSortedArrays(vector<vector<int>>& arrays) {\n    // Min-heap with pairs (value, array index, element index)\n    priority_queue<pair<int, pair<int, int>>, \n                   vector<pair<int, pair<int, int>>>,\n                   greater<pair<int, pair<int, int>>>> minHeap;\n    \n    // Push first element of each array\n    for(int i = 0; i < arrays.size(); i++) {\n        if(!arrays[i].empty()) {\n            minHeap.push({arrays[i][0], {i, 0}});\n        }\n    }\n    \n    vector<int> result;\n    \n    while(!minHeap.empty()) {\n        auto current = minHeap.top();\n        minHeap.pop();\n        \n        int value = current.first;\n        int arrayIdx = current.second.first;\n        int elementIdx = current.second.second;\n        \n        result.push_back(value);\n        \n        // Push next element from the same array\n        if(elementIdx + 1 < arrays[arrayIdx].size()) {\n            minHeap.push({arrays[arrayIdx][elementIdx + 1], \n                         {arrayIdx, elementIdx + 1}});\n        }\n    }\n    \n    return result;\n}\n"})}),"\n",(0,t.jsx)(e.h2,{id:"advantages-and-disadvantages-1",children:"Advantages and Disadvantages"}),"\n",(0,t.jsx)(e.h3,{id:"advantages-1",children:"Advantages:"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Guaranteed O(n log n) performance"})," in all cases"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Stable sort"})," - maintains relative order"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Well-suited for linked lists"})," with O(1) extra space"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Excellent for external sorting"})," (disk-based data)"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Predictable performance"})," - no worst-case O(n\xb2) scenarios"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"disadvantages-1",children:"Disadvantages:"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"O(n) additional space"})," required"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Not in-place"})," - needs temporary arrays"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Slower than Quick Sort"})," in practice for arrays"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Recursive overhead"})," for function calls"]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"when-to-use-merge-sort",children:"When to Use Merge Sort"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.strong,{children:"When stability is required"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.strong,{children:"When working with linked lists"})}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"For external sorting"})," (large files that don't fit in memory)"]}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.strong,{children:"When predictable O(n log n) performance is critical"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.strong,{children:"When sorting data that's mostly in sequential access media"})}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"summary-2",children:"Summary"}),"\n",(0,t.jsx)(e.p,{children:"Merge Sort is a reliable, efficient sorting algorithm that guarantees O(n log n) performance. Its divide-and-conquer approach makes it particularly useful for:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Linked lists"})," (in-place merging with O(1) space)"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"External sorting"})," (handling data larger than memory)"]}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.strong,{children:"Stable sorting requirements"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.strong,{children:"Situations where worst-case performance matters"})}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:"While it may not be as fast as Quick Sort for in-memory array sorting in practice, its predictable performance and stability make it an essential algorithm in many applications."}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Key Takeaways:"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Divide-and-conquer algorithm"}),"\n",(0,t.jsx)(e.li,{children:"Stable sorting with O(n log n) guaranteed performance"}),"\n",(0,t.jsx)(e.li,{children:"Requires O(n) additional space"}),"\n",(0,t.jsx)(e.li,{children:"Excellent for linked lists and external sorting"}),"\n",(0,t.jsx)(e.li,{children:"Foundation for more complex algorithms (merge join, inversion counting, etc.)"}),"\n"]}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.em,{children:"[Next: DSA Linear Search, Binary Search...]"})}),"\n",(0,t.jsx)(e.h1,{id:"dsa-linear-search---complete-c-guide",children:"DSA Linear Search - Complete C++ Guide"}),"\n",(0,t.jsx)(e.h2,{id:"introduction-to-linear-search",children:"Introduction to Linear Search"}),"\n",(0,t.jsx)(e.p,{children:"Linear Search, also known as Sequential Search, is the simplest searching algorithm that checks each element in a collection sequentially until the target element is found or the entire collection has been searched."}),"\n",(0,t.jsx)(e.h3,{id:"key-characteristics-4",children:"Key Characteristics:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Time Complexity"}),": O(n) in worst case"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Space Complexity"}),": O(1)"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"No prerequisites"}),": Doesn't require sorted data"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Simple implementation"}),": Easy to understand and implement"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Universal"}),": Works on any data structure with sequential access"]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"how-linear-search-works",children:"How Linear Search Works"}),"\n",(0,t.jsx)(e.h3,{id:"the-basic-algorithm",children:"The Basic Algorithm:"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsx)(e.li,{children:"Start from the first element"}),"\n",(0,t.jsx)(e.li,{children:"Compare each element with the target value"}),"\n",(0,t.jsx)(e.li,{children:"If match found, return the index"}),"\n",(0,t.jsx)(e.li,{children:"If end reached without finding, return -1"}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"visual-example-4",children:"Visual Example:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"Array: [10, 23, 45, 70, 11, 15]\nSearch for: 70\n\nStep 1: Check 10 \u2260 70\nStep 2: Check 23 \u2260 70\nStep 3: Check 45 \u2260 70\nStep 4: Check 70 = 70 \u2192 Found at index 3\n"})}),"\n",(0,t.jsx)(e.h2,{id:"basic-linear-search-implementation",children:"Basic Linear Search Implementation"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Linear search function\nint linearSearch(int arr[], int n, int target) {\n    for(int i = 0; i < n; i++) {\n        if(arr[i] == target) {\n            return i;  // Return index if found\n        }\n    }\n    return -1;  // Return -1 if not found\n}\n\n// Linear search with vector\nint linearSearchVector(const vector<int>& vec, int target) {\n    for(int i = 0; i < vec.size(); i++) {\n        if(vec[i] == target) {\n            return i;\n        }\n    }\n    return -1;\n}\n\nvoid printArray(int arr[], int n) {\n    for(int i = 0; i < n; i++) {\n        cout << arr[i] << " ";\n    }\n    cout << endl;\n}\n\nint main() {\n    int arr[] = {10, 23, 45, 70, 11, 15};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    int target = 70;\n    \n    cout << "Array: ";\n    printArray(arr, n);\n    cout << "Searching for: " << target << endl;\n    \n    int result = linearSearch(arr, n, target);\n    \n    if(result != -1) {\n        cout << "Element found at index: " << result << endl;\n    } else {\n        cout << "Element not found in the array" << endl;\n    }\n    \n    // Using vector\n    vector<int> vec = {10, 23, 45, 70, 11, 15};\n    cout << "\\nUsing vector: ";\n    for(int num : vec) cout << num << " ";\n    cout << endl;\n    \n    int vecResult = linearSearchVector(vec, 11);\n    cout << "Element 11 found at index: " << vecResult << endl;\n    \n    return 0;\n}\n'})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Output:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"Array: 10 23 45 70 11 15 \nSearching for: 70\nElement found at index: 3\n\nUsing vector: 10 23 45 70 11 15 \nElement 11 found at index: 4\n"})}),"\n",(0,t.jsx)(e.h2,{id:"detailed-step-by-step-visualization-4",children:"Detailed Step-by-Step Visualization"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <vector>\n#include <iomanip>\nusing namespace std;\n\nvoid linearSearchVisual(int arr[], int n, int target) {\n    cout << "=== Linear Search Step-by-Step ===\\n" << endl;\n    cout << "Array: ";\n    for(int i = 0; i < n; i++) {\n        cout << "[" << i << "]: " << setw(3) << arr[i] << "  ";\n    }\n    cout << "\\nTarget: " << target << endl << endl;\n    \n    bool found = false;\n    int comparisons = 0;\n    \n    for(int i = 0; i < n; i++) {\n        comparisons++;\n        \n        cout << "Step " << i + 1 << ": ";\n        cout << "Check arr[" << i << "] = " << arr[i];\n        \n        if(arr[i] == target) {\n            cout << " \u2705 MATCH FOUND!" << endl;\n            cout << "   Element " << target << " found at index " << i << endl;\n            cout << "   Total comparisons: " << comparisons << endl;\n            found = true;\n            break;\n        } else {\n            cout << " \u2717 Not equal to " << target << endl;\n        }\n        \n        // Visual representation\n        cout << "   Array: ";\n        for(int j = 0; j < n; j++) {\n            if(j == i) {\n                cout << "[" << arr[j] << "] ";  // Current position\n            } else {\n                cout << arr[j] << " ";\n            }\n        }\n        cout << endl << endl;\n    }\n    \n    if(!found) {\n        cout << "\u274c Element " << target << " not found in the array" << endl;\n        cout << "Total comparisons: " << comparisons << endl;\n    }\n    \n    cout << "\\n" << string(50, \'=\') << endl;\n    cout << "Performance Summary:" << endl;\n    cout << "  Best case: 1 comparison (element at first position)" << endl;\n    cout << "  Worst case: " << n << " comparisons (element not found or at last)" << endl;\n    cout << "  Average case: " << n/2 << " comparisons" << endl;\n}\n\nint main() {\n    int arr[] = {64, 34, 25, 12, 22, 11, 90};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    \n    cout << "Test 1: Element present in array" << endl;\n    linearSearchVisual(arr, n, 22);\n    \n    cout << "\\n\\nTest 2: Element not in array" << endl;\n    linearSearchVisual(arr, n, 99);\n    \n    return 0;\n}\n'})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Output:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"=== Linear Search Step-by-Step ===\n\nArray: [0]:  64  [1]:  34  [2]:  25  [3]:  12  [4]:  22  [5]:  11  [6]:  90  \nTarget: 22\n\nStep 1: Check arr[0] = 64 \u2717 Not equal to 22\n   Array: [64] 34 25 12 22 11 90 \n\nStep 2: Check arr[1] = 34 \u2717 Not equal to 22\n   Array: 64 [34] 25 12 22 11 90 \n\nStep 3: Check arr[2] = 25 \u2717 Not equal to 22\n   Array: 64 34 [25] 12 22 11 90 \n\nStep 4: Check arr[3] = 12 \u2717 Not equal to 22\n   Array: 64 34 25 [12] 22 11 90 \n\nStep 5: Check arr[4] = 22 \u2705 MATCH FOUND!\n   Element 22 found at index 4\n   Total comparisons: 5\n"})}),"\n",(0,t.jsx)(e.h2,{id:"variations-of-linear-search",children:"Variations of Linear Search"}),"\n",(0,t.jsx)(e.h3,{id:"1-linear-search-with-sentinel",children:"1. Linear Search with Sentinel"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\nusing namespace std;\n\n// Sentinel linear search (reduces comparisons)\nint sentinelLinearSearch(int arr[], int n, int target) {\n    // Store last element\n    int last = arr[n - 1];\n    \n    // Set last element as target\n    arr[n - 1] = target;\n    \n    int i = 0;\n    while(arr[i] != target) {\n        i++;\n    }\n    \n    // Restore last element\n    arr[n - 1] = last;\n    \n    // Check if found\n    if(i < n - 1 || arr[n - 1] == target) {\n        return i;\n    }\n    \n    return -1;\n}\n\nint main() {\n    int arr[] = {10, 20, 30, 40, 50, 60};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    int target = 40;\n    \n    cout << "Sentinel Linear Search" << endl;\n    cout << "Array: ";\n    for(int i = 0; i < n; i++) cout << arr[i] << " ";\n    cout << "\\nSearching for: " << target << endl;\n    \n    int result = sentinelLinearSearch(arr, n, target);\n    \n    if(result != -1) {\n        cout << "Element found at index: " << result << endl;\n    } else {\n        cout << "Element not found" << endl;\n    }\n    \n    return 0;\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"2-linear-search-for-multiple-occurrences",children:"2. Linear Search for Multiple Occurrences"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Find all occurrences\nvector<int> linearSearchAll(int arr[], int n, int target) {\n    vector<int> indices;\n    \n    for(int i = 0; i < n; i++) {\n        if(arr[i] == target) {\n            indices.push_back(i);\n        }\n    }\n    \n    return indices;\n}\n\n// Find first and last occurrence\npair<int, int> linearSearchFirstLast(int arr[], int n, int target) {\n    int first = -1, last = -1;\n    \n    for(int i = 0; i < n; i++) {\n        if(arr[i] == target) {\n            if(first == -1) {\n                first = i;  // First occurrence\n            }\n            last = i;  // Update last occurrence\n        }\n    }\n    \n    return {first, last};\n}\n\nint main() {\n    int arr[] = {10, 20, 30, 20, 40, 20, 50};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    int target = 20;\n    \n    cout << "Array: ";\n    for(int i = 0; i < n; i++) cout << arr[i] << " ";\n    cout << "\\nSearching for: " << target << endl;\n    \n    // Find all occurrences\n    vector<int> allIndices = linearSearchAll(arr, n, target);\n    \n    cout << "\\nAll occurrences at indices: ";\n    for(int idx : allIndices) {\n        cout << idx << " ";\n    }\n    cout << "(" << allIndices.size() << " occurrences)" << endl;\n    \n    // Find first and last occurrence\n    auto [first, last] = linearSearchFirstLast(arr, n, target);\n    \n    cout << "First occurrence: " << first << endl;\n    cout << "Last occurrence: " << last << endl;\n    \n    return 0;\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"3-linear-search-with-frequency-count",children:"3. Linear Search with Frequency Count"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\nusing namespace std;\n\nvoid linearSearchWithFrequency(int arr[], int n, int target) {\n    int count = 0;\n    int firstIndex = -1;\n    int lastIndex = -1;\n    \n    cout << "Searching for " << target << "..." << endl;\n    \n    for(int i = 0; i < n; i++) {\n        if(arr[i] == target) {\n            count++;\n            if(firstIndex == -1) {\n                firstIndex = i;\n            }\n            lastIndex = i;\n            \n            cout << "  Found at index " << i << " (Occurrence #" << count << ")" << endl;\n        }\n    }\n    \n    cout << "\\nSummary:" << endl;\n    cout << "  Total occurrences: " << count << endl;\n    \n    if(count > 0) {\n        cout << "  First occurrence: index " << firstIndex << endl;\n        cout << "  Last occurrence: index " << lastIndex << endl;\n        cout << "  Frequency: " << count << " times" << endl;\n    } else {\n        cout << "  Element not found in array" << endl;\n    }\n}\n\nint main() {\n    int arr[] = {2, 4, 6, 8, 4, 10, 4, 12, 14, 4};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    \n    cout << "Array: ";\n    for(int i = 0; i < n; i++) cout << arr[i] << " ";\n    cout << endl;\n    \n    linearSearchWithFrequency(arr, n, 4);\n    \n    return 0;\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"linear-search-on-different-data-structures",children:"Linear Search on Different Data Structures"}),"\n",(0,t.jsx)(e.h3,{id:"1-linear-search-in-strings",children:"1. Linear Search in Strings"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\n// Search character in string\nint linearSearchString(const string& str, char target) {\n    for(int i = 0; i < str.length(); i++) {\n        if(str[i] == target) {\n            return i;\n        }\n    }\n    return -1;\n}\n\n// Search substring in string\nint linearSearchSubstring(const string& str, const string& substring) {\n    int n = str.length();\n    int m = substring.length();\n    \n    for(int i = 0; i <= n - m; i++) {\n        int j;\n        for(j = 0; j < m; j++) {\n            if(str[i + j] != substring[j]) {\n                break;\n            }\n        }\n        if(j == m) {\n            return i;  // Substring found starting at index i\n        }\n    }\n    return -1;\n}\n\nint main() {\n    string text = "Hello, welcome to C++ programming!";\n    char targetChar = \'w\';\n    string targetSubstring = "C++";\n    \n    cout << "Text: \\"" << text << "\\"" << endl;\n    \n    // Search for character\n    int charIndex = linearSearchString(text, targetChar);\n    if(charIndex != -1) {\n        cout << "Character \'" << targetChar << "\' found at index: " << charIndex << endl;\n    } else {\n        cout << "Character \'" << targetChar << "\' not found" << endl;\n    }\n    \n    // Search for substring\n    int subIndex = linearSearchSubstring(text, targetSubstring);\n    if(subIndex != -1) {\n        cout << "Substring \\"" << targetSubstring << "\\" found starting at index: " << subIndex << endl;\n    } else {\n        cout << "Substring \\"" << targetSubstring << "\\" not found" << endl;\n    }\n    \n    return 0;\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"2-linear-search-in-2d-arrays",children:"2. Linear Search in 2D Arrays"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\nusing namespace std;\n\n// Search in 2D array\npair<int, int> linearSearch2D(int matrix[][3], int rows, int cols, int target) {\n    for(int i = 0; i < rows; i++) {\n        for(int j = 0; j < cols; j++) {\n            if(matrix[i][j] == target) {\n                return {i, j};  // Return row and column indices\n            }\n        }\n    }\n    return {-1, -1};  // Not found\n}\n\n// Search in jagged array (vector of vectors)\npair<int, int> linearSearchJagged(const vector<vector<int>>& jagged, int target) {\n    for(int i = 0; i < jagged.size(); i++) {\n        for(int j = 0; j < jagged[i].size(); j++) {\n            if(jagged[i][j] == target) {\n                return {i, j};\n            }\n        }\n    }\n    return {-1, -1};\n}\n\nint main() {\n    // 2D array\n    int matrix[3][3] = {\n        {1, 2, 3},\n        {4, 5, 6},\n        {7, 8, 9}\n    };\n    \n    cout << "2D Array:" << endl;\n    for(int i = 0; i < 3; i++) {\n        for(int j = 0; j < 3; j++) {\n            cout << matrix[i][j] << " ";\n        }\n        cout << endl;\n    }\n    \n    int target = 5;\n    auto [row, col] = linearSearch2D(matrix, 3, 3, target);\n    \n    if(row != -1) {\n        cout << "Element " << target << " found at position: (" \n             << row << ", " << col << ")" << endl;\n    } else {\n        cout << "Element " << target << " not found" << endl;\n    }\n    \n    // Jagged array\n    vector<vector<int>> jagged = {\n        {1, 2},\n        {3, 4, 5, 6},\n        {7},\n        {8, 9, 10}\n    };\n    \n    cout << "\\nJagged Array:" << endl;\n    for(const auto& row : jagged) {\n        for(int num : row) {\n            cout << num << " ";\n        }\n        cout << endl;\n    }\n    \n    target = 6;\n    auto [rowJ, colJ] = linearSearchJagged(jagged, target);\n    \n    if(rowJ != -1) {\n        cout << "Element " << target << " found at position: (" \n             << rowJ << ", " << colJ << ")" << endl;\n    }\n    \n    return 0;\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"3-linear-search-in-linked-list",children:"3. Linear Search in Linked List"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\nusing namespace std;\n\nstruct Node {\n    int data;\n    Node* next;\n    Node(int val) : data(val), next(nullptr) {}\n};\n\nclass LinkedList {\nprivate:\n    Node* head;\n    \npublic:\n    LinkedList() : head(nullptr) {}\n    \n    void insert(int data) {\n        Node* newNode = new Node(data);\n        newNode->next = head;\n        head = newNode;\n    }\n    \n    // Linear search in linked list\n    Node* linearSearch(int target) {\n        Node* current = head;\n        int position = 0;\n        \n        while(current != nullptr) {\n            if(current->data == target) {\n                cout << "Found " << target << " at position " << position << endl;\n                return current;\n            }\n            current = current->next;\n            position++;\n        }\n        \n        cout << target << " not found in the list" << endl;\n        return nullptr;\n    }\n    \n    void display() {\n        Node* current = head;\n        cout << "Linked List: ";\n        while(current != nullptr) {\n            cout << current->data << " -> ";\n            current = current->next;\n        }\n        cout << "NULL" << endl;\n    }\n};\n\nint main() {\n    LinkedList list;\n    \n    // Insert elements\n    list.insert(10);\n    list.insert(20);\n    list.insert(30);\n    list.insert(40);\n    list.insert(50);\n    \n    list.display();\n    \n    // Search for elements\n    list.linearSearch(30);\n    list.linearSearch(25);  // Not in list\n    \n    return 0;\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"optimized-linear-search-techniques",children:"Optimized Linear Search Techniques"}),"\n",(0,t.jsx)(e.h3,{id:"1-transposition-move-to-front-for-frequently-accessed-items",children:"1. Transposition (Move to Front) for Frequently Accessed Items"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\nusing namespace std;\n\n// Transposition: Move found element one step forward\nint linearSearchTransposition(int arr[], int n, int target) {\n    for(int i = 0; i < n; i++) {\n        if(arr[i] == target) {\n            if(i > 0) {\n                // Swap with previous element\n                swap(arr[i], arr[i - 1]);\n                return i - 1;  // Return new position\n            }\n            return i;  // Already at front\n        }\n    }\n    return -1;\n}\n\n// Move to front: Move found element to beginning\nint linearSearchMoveToFront(int arr[], int n, int target) {\n    for(int i = 0; i < n; i++) {\n        if(arr[i] == target) {\n            if(i > 0) {\n                // Move to front\n                int temp = arr[i];\n                for(int j = i; j > 0; j--) {\n                    arr[j] = arr[j - 1];\n                }\n                arr[0] = temp;\n                return 0;  // Now at front\n            }\n            return i;  // Already at front\n        }\n    }\n    return -1;\n}\n\nvoid printArray(int arr[], int n) {\n    for(int i = 0; i < n; i++) {\n        cout << arr[i] << " ";\n    }\n    cout << endl;\n}\n\nint main() {\n    int arr[] = {10, 20, 30, 40, 50};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    \n    cout << "Original array: ";\n    printArray(arr, n);\n    \n    cout << "\\nSearching for 40 with transposition..." << endl;\n    int result1 = linearSearchTransposition(arr, n, 40);\n    cout << "Found at (new) index: " << result1 << endl;\n    cout << "Array after transposition: ";\n    printArray(arr, n);\n    \n    cout << "\\nSearching for 40 again with transposition..." << endl;\n    result1 = linearSearchTransposition(arr, n, 40);\n    cout << "Found at (new) index: " << result1 << endl;\n    cout << "Array after second transposition: ";\n    printArray(arr, n);\n    \n    // Reset array\n    int arr2[] = {10, 20, 30, 40, 50};\n    cout << "\\n\\nReset array: ";\n    printArray(arr2, n);\n    \n    cout << "\\nSearching for 40 with move-to-front..." << endl;\n    int result2 = linearSearchMoveToFront(arr2, n, 40);\n    cout << "Found at (new) index: " << result2 << endl;\n    cout << "Array after move-to-front: ";\n    printArray(arr2, n);\n    \n    return 0;\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"2-recursive-linear-search",children:"2. Recursive Linear Search"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\nusing namespace std;\n\n// Recursive linear search\nint recursiveLinearSearch(int arr[], int size, int target, int index = 0) {\n    // Base cases\n    if(index >= size) {\n        return -1;  // Element not found\n    }\n    if(arr[index] == target) {\n        return index;  // Element found\n    }\n    \n    // Recursive call\n    return recursiveLinearSearch(arr, size, target, index + 1);\n}\n\n// Recursive search from both ends\nint recursiveLinearSearchBothEnds(int arr[], int left, int right, int target) {\n    // Base cases\n    if(left > right) {\n        return -1;\n    }\n    if(arr[left] == target) {\n        return left;\n    }\n    if(arr[right] == target) {\n        return right;\n    }\n    \n    // Recursive call\n    return recursiveLinearSearchBothEnds(arr, left + 1, right - 1, target);\n}\n\nint main() {\n    int arr[] = {10, 20, 30, 40, 50, 60, 70};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    \n    cout << "Array: ";\n    for(int i = 0; i < n; i++) cout << arr[i] << " ";\n    cout << endl;\n    \n    cout << "\\nRecursive search for 40: ";\n    int result1 = recursiveLinearSearch(arr, n, 40);\n    if(result1 != -1) {\n        cout << "Found at index " << result1 << endl;\n    } else {\n        cout << "Not found" << endl;\n    }\n    \n    cout << "Recursive search for 90: ";\n    int result2 = recursiveLinearSearch(arr, n, 90);\n    if(result2 != -1) {\n        cout << "Found at index " << result2 << endl;\n    } else {\n        cout << "Not found" << endl;\n    }\n    \n    cout << "\\nRecursive search from both ends for 20: ";\n    int result3 = recursiveLinearSearchBothEnds(arr, 0, n - 1, 20);\n    if(result3 != -1) {\n        cout << "Found at index " << result3 << endl;\n    }\n    \n    return 0;\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"performance-analysis",children:"Performance Analysis"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <chrono>\n#include <random>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nusing namespace chrono;\n\nvoid performanceTest() {\n    random_device rd;\n    mt19937 gen(rd());\n    uniform_int_distribution<> dis(1, 100000);\n    \n    vector<int> sizes = {1000, 10000, 50000, 100000, 500000};\n    \n    cout << "Linear Search Performance Analysis\\n" << endl;\n    cout << "Size\\t\\tBest Case\\tWorst Case\\tAverage Case" << endl;\n    cout << string(60, \'-\') << endl;\n    \n    for(int size : sizes) {\n        // Generate random data\n        vector<int> data(size);\n        for(int i = 0; i < size; i++) {\n            data[i] = dis(gen);\n        }\n        \n        // Test Best Case (element at first position)\n        int targetBest = data[0];\n        auto start = high_resolution_clock::now();\n        \n        // Linear search\n        for(int i = 0; i < size; i++) {\n            if(data[i] == targetBest) {\n                break;\n            }\n        }\n        \n        auto end = high_resolution_clock::now();\n        auto bestTime = duration_cast<nanoseconds>(end - start).count();\n        \n        // Test Worst Case (element not present)\n        int targetWorst = -1;  // Not in array\n        start = high_resolution_clock::now();\n        \n        for(int i = 0; i < size; i++) {\n            if(data[i] == targetWorst) {\n                break;\n            }\n        }\n        \n        end = high_resolution_clock::now();\n        auto worstTime = duration_cast<nanoseconds>(end - start).count();\n        \n        // Test Average Case (element in middle)\n        int targetAvg = data[size / 2];\n        start = high_resolution_clock::now();\n        \n        for(int i = 0; i < size; i++) {\n            if(data[i] == targetAvg) {\n                break;\n            }\n        }\n        \n        end = high_resolution_clock::now();\n        auto avgTime = duration_cast<nanoseconds>(end - start).count();\n        \n        cout << size << "\\t\\t"\n             << bestTime << " ns\\t"\n             << worstTime << " ns\\t"\n             << avgTime << " ns" << endl;\n    }\n}\n\n// Compare with binary search (requires sorted data)\nvoid compareWithBinarySearch() {\n    cout << "\\n\\nComparison with Binary Search (on sorted data)\\n" << endl;\n    cout << "Size\\t\\tLinear Search\\tBinary Search\\tSpeedup" << endl;\n    cout << string(60, \'-\') << endl;\n    \n    for(int size = 1000; size <= 100000; size *= 10) {\n        vector<int> data(size);\n        for(int i = 0; i < size; i++) {\n            data[i] = i;  // Sorted data\n        }\n        \n        int target = size / 2;\n        \n        // Linear search\n        auto start = high_resolution_clock::now();\n        for(int i = 0; i < size; i++) {\n            if(data[i] == target) break;\n        }\n        auto end = high_resolution_clock::now();\n        auto linearTime = duration_cast<nanoseconds>(end - start).count();\n        \n        // Binary search\n        start = high_resolution_clock::now();\n        int left = 0, right = size - 1;\n        while(left <= right) {\n            int mid = left + (right - left) / 2;\n            if(data[mid] == target) break;\n            else if(data[mid] < target) left = mid + 1;\n            else right = mid - 1;\n        }\n        end = high_resolution_clock::now();\n        auto binaryTime = duration_cast<nanoseconds>(end - start).count();\n        \n        double speedup = (double)linearTime / binaryTime;\n        \n        cout << size << "\\t\\t"\n             << linearTime << " ns\\t"\n             << binaryTime << " ns\\t"\n             << fixed << setprecision(1) << speedup << "x" << endl;\n    }\n}\n\nint main() {\n    performanceTest();\n    compareWithBinarySearch();\n    return 0;\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"applications-of-linear-search",children:"Applications of Linear Search"}),"\n",(0,t.jsx)(e.h3,{id:"1-finding-minimummaximum-element",children:"1. Finding Minimum/Maximum Element"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <vector>\n#include <climits>\nusing namespace std;\n\npair<int, int> findMinMax(int arr[], int n) {\n    if(n == 0) return {INT_MAX, INT_MIN};\n    \n    int minVal = arr[0];\n    int maxVal = arr[0];\n    \n    for(int i = 1; i < n; i++) {\n        if(arr[i] < minVal) {\n            minVal = arr[i];\n        }\n        if(arr[i] > maxVal) {\n            maxVal = arr[i];\n        }\n    }\n    \n    return {minVal, maxVal};\n}\n\n// Find second largest element\nint findSecondLargest(int arr[], int n) {\n    if(n < 2) return -1;\n    \n    int largest = INT_MIN;\n    int secondLargest = INT_MIN;\n    \n    for(int i = 0; i < n; i++) {\n        if(arr[i] > largest) {\n            secondLargest = largest;\n            largest = arr[i];\n        } else if(arr[i] > secondLargest && arr[i] != largest) {\n            secondLargest = arr[i];\n        }\n    }\n    \n    return (secondLargest == INT_MIN) ? -1 : secondLargest;\n}\n\nint main() {\n    int arr[] = {12, 35, 1, 10, 34, 1};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    \n    cout << "Array: ";\n    for(int i = 0; i < n; i++) cout << arr[i] << " ";\n    cout << endl;\n    \n    auto [minVal, maxVal] = findMinMax(arr, n);\n    cout << "Minimum: " << minVal << endl;\n    cout << "Maximum: " << maxVal << endl;\n    \n    int secondLargest = findSecondLargest(arr, n);\n    cout << "Second Largest: " << secondLargest << endl;\n    \n    return 0;\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"2-data-validation-and-filtering",children:"2. Data Validation and Filtering"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Validate if all elements are positive\nbool validateAllPositive(const vector<int>& data) {\n    for(int num : data) {\n        if(num <= 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// Filter even numbers\nvector<int> filterEvenNumbers(const vector<int>& data) {\n    vector<int> result;\n    for(int num : data) {\n        if(num % 2 == 0) {\n            result.push_back(num);\n        }\n    }\n    return result;\n}\n\n// Find duplicates\nvector<int> findDuplicates(const vector<int>& data) {\n    vector<int> duplicates;\n    \n    for(int i = 0; i < data.size(); i++) {\n        for(int j = i + 1; j < data.size(); j++) {\n            if(data[i] == data[j]) {\n                // Check if already in duplicates\n                bool alreadyFound = false;\n                for(int dup : duplicates) {\n                    if(dup == data[i]) {\n                        alreadyFound = true;\n                        break;\n                    }\n                }\n                if(!alreadyFound) {\n                    duplicates.push_back(data[i]);\n                }\n            }\n        }\n    }\n    \n    return duplicates;\n}\n\nint main() {\n    vector<int> data = {1, 2, 3, 4, 5, 2, 3, 6, 7, 8};\n    \n    cout << "Data: ";\n    for(int num : data) cout << num << " ";\n    cout << endl;\n    \n    cout << "\\nAll positive? " << (validateAllPositive(data) ? "Yes" : "No") << endl;\n    \n    vector<int> evens = filterEvenNumbers(data);\n    cout << "Even numbers: ";\n    for(int num : evens) cout << num << " ";\n    cout << endl;\n    \n    vector<int> duplicates = findDuplicates(data);\n    cout << "Duplicates: ";\n    for(int num : duplicates) cout << num << " ";\n    cout << endl;\n    \n    return 0;\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"3-simple-database-search",children:"3. Simple Database Search"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstruct Student {\n    int id;\n    string name;\n    float grade;\n    \n    void display() const {\n        cout << "ID: " << id << ", Name: " << name << ", Grade: " << grade << endl;\n    }\n};\n\nclass StudentDatabase {\nprivate:\n    vector<Student> students;\n    \npublic:\n    void addStudent(int id, string name, float grade) {\n        students.push_back({id, name, grade});\n    }\n    \n    // Search by ID\n    Student* searchById(int id) {\n        for(auto& student : students) {\n            if(student.id == id) {\n                return &student;\n            }\n        }\n        return nullptr;\n    }\n    \n    // Search by name\n    vector<Student*> searchByName(const string& name) {\n        vector<Student*> results;\n        for(auto& student : students) {\n            if(student.name == name) {\n                results.push_back(&student);\n            }\n        }\n        return results;\n    }\n    \n    // Search by grade range\n    vector<Student*> searchByGradeRange(float minGrade, float maxGrade) {\n        vector<Student*> results;\n        for(auto& student : students) {\n            if(student.grade >= minGrade && student.grade <= maxGrade) {\n                results.push_back(&student);\n            }\n        }\n        return results;\n    }\n    \n    void displayAll() {\n        cout << "\\nAll Students:" << endl;\n        for(const auto& student : students) {\n            student.display();\n        }\n    }\n};\n\nint main() {\n    StudentDatabase db;\n    \n    // Add sample data\n    db.addStudent(101, "Alice", 85.5);\n    db.addStudent(102, "Bob", 92.0);\n    db.addStudent(103, "Charlie", 78.5);\n    db.addStudent(104, "Alice", 88.0);\n    db.addStudent(105, "David", 91.5);\n    \n    db.displayAll();\n    \n    cout << "\\nSearch by ID 103:" << endl;\n    Student* student = db.searchById(103);\n    if(student) student->display();\n    \n    cout << "\\nSearch by name \'Alice\':" << endl;\n    auto aliceStudents = db.searchByName("Alice");\n    for(auto s : aliceStudents) s->display();\n    \n    cout << "\\nSearch by grade range (80.0 - 90.0):" << endl;\n    auto gradeStudents = db.searchByGradeRange(80.0, 90.0);\n    for(auto s : gradeStudents) s->display();\n    \n    return 0;\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"common-interview-questions-2",children:"Common Interview Questions"}),"\n",(0,t.jsx)(e.h3,{id:"1-basic-linear-search-implementation",children:"1. Basic Linear Search Implementation"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:"// Already shown in basic examples\n"})}),"\n",(0,t.jsx)(e.h3,{id:"2-find-missing-number-in-array",children:"2. Find Missing Number in Array"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <vector>\nusing namespace std;\n\nint findMissingNumber(const vector<int>& arr, int n) {\n    // Array contains numbers from 1 to n with one missing\n    for(int i = 1; i <= n; i++) {\n        bool found = false;\n        for(int num : arr) {\n            if(num == i) {\n                found = true;\n                break;\n            }\n        }\n        if(!found) {\n            return i;\n        }\n    }\n    return -1;  // No missing number\n}\n\n// Better approach using sum formula\nint findMissingNumberOptimized(const vector<int>& arr, int n) {\n    int totalSum = n * (n + 1) / 2;\n    int arraySum = 0;\n    \n    for(int num : arr) {\n        arraySum += num;\n    }\n    \n    return totalSum - arraySum;\n}\n\nint main() {\n    vector<int> arr = {1, 2, 4, 5, 6};  // Missing 3\n    int n = 6;  // Numbers from 1 to 6\n    \n    cout << "Array: ";\n    for(int num : arr) cout << num << " ";\n    cout << endl;\n    \n    int missing = findMissingNumber(arr, n);\n    cout << "Missing number (linear search): " << missing << endl;\n    \n    missing = findMissingNumberOptimized(arr, n);\n    cout << "Missing number (optimized): " << missing << endl;\n    \n    return 0;\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"3-find-pair-with-given-sum",children:"3. Find Pair with Given Sum"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Brute force approach using linear search\npair<int, int> findPairWithSum(const vector<int>& arr, int target) {\n    for(int i = 0; i < arr.size(); i++) {\n        for(int j = i + 1; j < arr.size(); j++) {\n            if(arr[i] + arr[j] == target) {\n                return {arr[i], arr[j]};\n            }\n        }\n    }\n    return {-1, -1};\n}\n\n// Find all pairs\nvector<pair<int, int>> findAllPairsWithSum(const vector<int>& arr, int target) {\n    vector<pair<int, int>> pairs;\n    \n    for(int i = 0; i < arr.size(); i++) {\n        for(int j = i + 1; j < arr.size(); j++) {\n            if(arr[i] + arr[j] == target) {\n                pairs.push_back({arr[i], arr[j]});\n            }\n        }\n    }\n    \n    return pairs;\n}\n\nint main() {\n    vector<int> arr = {8, 7, 2, 5, 3, 1};\n    int target = 10;\n    \n    cout << "Array: ";\n    for(int num : arr) cout << num << " ";\n    cout << "\\nTarget sum: " << target << endl;\n    \n    auto pair = findPairWithSum(arr, target);\n    if(pair.first != -1) {\n        cout << "Pair found: " << pair.first << " + " << pair.second \n             << " = " << target << endl;\n    } else {\n        cout << "No pair found" << endl;\n    }\n    \n    cout << "\\nAll pairs with sum " << target << ":" << endl;\n    auto allPairs = findAllPairsWithSum(arr, target);\n    for(const auto& p : allPairs) {\n        cout << p.first << " + " << p.second << " = " << target << endl;\n    }\n    \n    return 0;\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"advantages-and-disadvantages-2",children:"Advantages and Disadvantages"}),"\n",(0,t.jsx)(e.h3,{id:"advantages-2",children:"Advantages:"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Simple to implement"})," - Easy to understand and code"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"No prerequisites"})," - Works on unsorted data"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Versatile"})," - Works on arrays, linked lists, files, etc."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Good for small datasets"})," - Simple and effective"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Useful for one-time searches"})," - When data won't be searched frequently"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"disadvantages-2",children:"Disadvantages:"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"O(n) time complexity"})," - Slow for large datasets"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Inefficient for frequent searches"})," - Better algorithms exist for repeated searches"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"No early termination benefit"})," for unsorted data"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Worst-case visits all elements"})," even when element not present"]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"when-to-use-linear-search",children:"When to Use Linear Search"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Small datasets"})," (n < 100)"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Unsorted data"})," where sorting cost > search cost"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"One-time searches"})," or infrequent searches"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"When simplicity"})," is more important than efficiency"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Linked lists"})," and other sequential access data structures"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Educational purposes"})," to understand searching concepts"]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"summary-3",children:"Summary"}),"\n",(0,t.jsx)(e.p,{children:"Linear Search is the most basic searching algorithm that forms the foundation for understanding more complex searching techniques. While it's inefficient for large datasets, it has several practical applications:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.strong,{children:"Simple data validation and filtering"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.strong,{children:"Small database lookups"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.strong,{children:"Finding min/max in unsorted data"})}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Educational purposes"})," to learn searching concepts"]}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Key Takeaways:"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Time complexity: O(n) worst case, O(1) best case"}),"\n",(0,t.jsx)(e.li,{children:"Space complexity: O(1)"}),"\n",(0,t.jsx)(e.li,{children:"Works on any sequential data structure"}),"\n",(0,t.jsx)(e.li,{children:"Simple to implement and understand"}),"\n",(0,t.jsx)(e.li,{children:"Foundation for more advanced algorithms"}),"\n"]}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.em,{children:"[Next: DSA Binary Search...]"})}),"\n",(0,t.jsx)(e.h1,{id:"dsa-binary-search---complete-c-guide",children:"DSA Binary Search - Complete C++ Guide"}),"\n",(0,t.jsx)(e.h2,{id:"introduction-to-binary-search",children:"Introduction to Binary Search"}),"\n",(0,t.jsxs)(e.p,{children:["Binary Search is an ",(0,t.jsx)(e.strong,{children:"efficient searching algorithm"})," that finds the position of a target value within a ",(0,t.jsx)(e.strong,{children:"sorted array"}),". It works by repeatedly dividing the search interval in half."]}),"\n",(0,t.jsx)(e.h3,{id:"key-characteristics-5",children:"Key Characteristics:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Time Complexity"}),": O(log n) - extremely efficient"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Space Complexity"}),": O(1) for iterative, O(log n) for recursive"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Prerequisite"}),": Array must be sorted"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Divide and Conquer"}),": Halves search space each iteration"]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"how-binary-search-works",children:"How Binary Search Works"}),"\n",(0,t.jsx)(e.h3,{id:"the-algorithm",children:"The Algorithm:"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsx)(e.li,{children:"Start with the entire sorted array"}),"\n",(0,t.jsx)(e.li,{children:"Compare target with middle element"}),"\n",(0,t.jsx)(e.li,{children:"If target equals middle element, return index"}),"\n",(0,t.jsx)(e.li,{children:"If target is smaller, search left half"}),"\n",(0,t.jsx)(e.li,{children:"If target is larger, search right half"}),"\n",(0,t.jsx)(e.li,{children:"Repeat until found or search space exhausted"}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"visual-example-5",children:"Visual Example:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"Array: [2, 5, 8, 12, 16, 23, 38, 56, 72, 91]\nSearch for: 23\n\nStep 1: left=0, right=9, mid=4 \u2192 arr[4]=16 < 23 \u2192 search right\nStep 2: left=5, right=9, mid=7 \u2192 arr[7]=56 > 23 \u2192 search left  \nStep 3: left=5, right=6, mid=5 \u2192 arr[5]=23 == 23 \u2192 Found!\n"})}),"\n",(0,t.jsx)(e.h2,{id:"basic-binary-search-implementation",children:"Basic Binary Search Implementation"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// Iterative binary search\nint binarySearchIterative(int arr[], int n, int target) {\n    int left = 0;\n    int right = n - 1;\n    \n    while(left <= right) {\n        int mid = left + (right - left) / 2;  // Avoid overflow\n        \n        cout << "Searching: left=" << left << ", right=" << right \n             << ", mid=" << mid << ", arr[mid]=" << arr[mid] << endl;\n        \n        if(arr[mid] == target) {\n            return mid;  // Target found\n        }\n        else if(arr[mid] < target) {\n            left = mid + 1;  // Search right half\n            cout << "  Target > arr[mid], moving left to " << left << endl;\n        }\n        else {\n            right = mid - 1;  // Search left half\n            cout << "  Target < arr[mid], moving right to " << right << endl;\n        }\n    }\n    \n    return -1;  // Target not found\n}\n\n// Recursive binary search\nint binarySearchRecursive(int arr[], int left, int right, int target) {\n    if(left > right) {\n        return -1;  // Base case: not found\n    }\n    \n    int mid = left + (right - left) / 2;\n    \n    cout << "Recursive call: left=" << left << ", right=" << right \n         << ", mid=" << mid << ", arr[mid]=" << arr[mid] << endl;\n    \n    if(arr[mid] == target) {\n        return mid;\n    }\n    else if(arr[mid] < target) {\n        return binarySearchRecursive(arr, mid + 1, right, target);\n    }\n    else {\n        return binarySearchRecursive(arr, left, mid - 1, target);\n    }\n}\n\nvoid printArray(int arr[], int n) {\n    for(int i = 0; i < n; i++) {\n        cout << arr[i] << " ";\n    }\n    cout << endl;\n}\n\nint main() {\n    int arr[] = {2, 5, 8, 12, 16, 23, 38, 56, 72, 91};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    int target = 23;\n    \n    cout << "Sorted array: ";\n    printArray(arr, n);\n    cout << "Searching for: " << target << endl << endl;\n    \n    cout << "=== Iterative Binary Search ===" << endl;\n    int resultIterative = binarySearchIterative(arr, n, target);\n    \n    if(resultIterative != -1) {\n        cout << "\\nElement found at index: " << resultIterative << endl;\n    } else {\n        cout << "\\nElement not found" << endl;\n    }\n    \n    cout << "\\n=== Recursive Binary Search ===" << endl;\n    int resultRecursive = binarySearchRecursive(arr, 0, n-1, target);\n    \n    if(resultRecursive != -1) {\n        cout << "\\nElement found at index: " << resultRecursive << endl;\n    } else {\n        cout << "\\nElement not found" << endl;\n    }\n    \n    return 0;\n}\n'})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Output:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"Sorted array: 2 5 8 12 16 23 38 56 72 91 \nSearching for: 23\n\n=== Iterative Binary Search ===\nSearching: left=0, right=9, mid=4, arr[mid]=16\n  Target > arr[mid], moving left to 5\nSearching: left=5, right=9, mid=7, arr[mid]=56\n  Target < arr[mid], moving right to 6\nSearching: left=5, right=6, mid=5, arr[mid]=23\n\nElement found at index: 5\n\n=== Recursive Binary Search ===\nRecursive call: left=0, right=9, mid=4, arr[mid]=16\nRecursive call: left=5, right=9, mid=7, arr[mid]=56\nRecursive call: left=5, right=6, mid=5, arr[mid]=23\n\nElement found at index: 5\n"})}),"\n",(0,t.jsx)(e.h2,{id:"detailed-step-by-step-visualization-5",children:"Detailed Step-by-Step Visualization"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <vector>\n#include <iomanip>\nusing namespace std;\n\nvoid binarySearchVisual(int arr[], int n, int target) {\n    cout << "=== Binary Search Visualization ===\\n" << endl;\n    cout << "Array: ";\n    for(int i = 0; i < n; i++) {\n        cout << "[" << i << "]: " << setw(3) << arr[i] << "  ";\n    }\n    cout << "\\nTarget: " << target << endl << endl;\n    \n    int left = 0;\n    int right = n - 1;\n    int step = 1;\n    \n    while(left <= right) {\n        int mid = left + (right - left) / 2;\n        \n        cout << "Step " << step++ << ":" << endl;\n        cout << "  Search space: indices " << left << " to " << right << endl;\n        \n        // Visualize current search space\n        cout << "  ";\n        for(int i = 0; i < n; i++) {\n            if(i == left) cout << "[";\n            if(i == mid) cout << "(" << arr[i] << ")";\n            else cout << arr[i];\n            if(i == right) cout << "]";\n            cout << " ";\n        }\n        cout << endl;\n        \n        cout << "  Compare target " << target << " with arr[" << mid << "] = " << arr[mid] << endl;\n        \n        if(arr[mid] == target) {\n            cout << "  \u2705 MATCH FOUND at index " << mid << "!" << endl;\n            cout << "\\nTotal steps: " << (step - 1) << endl;\n            cout << "Maximum possible steps for array of size " << n << ": " \n                 << (int)log2(n) + 1 << endl;\n            return;\n        }\n        else if(arr[mid] < target) {\n            cout << "  \u2192 Target is larger, search RIGHT half" << endl;\n            left = mid + 1;\n        }\n        else {\n            cout << "  \u2190 Target is smaller, search LEFT half" << endl;\n            right = mid - 1;\n        }\n        \n        cout << endl;\n    }\n    \n    cout << "\u274c Element not found" << endl;\n    cout << "Total steps: " << (step - 1) << endl;\n}\n\nvoid demonstrateLogarithmicNature() {\n    cout << "\\n" << string(60, \'=\') << endl;\n    cout << "Demonstrating Logarithmic Nature of Binary Search\\n" << endl;\n    cout << setw(10) << "Array Size" << setw(20) << "Max Comparisons" \n         << setw(20) << "log\u2082(n)" << endl;\n    cout << string(50, \'-\') << endl;\n    \n    vector<int> sizes = {10, 100, 1000, 10000, 100000, 1000000, 10000000};\n    for(int size : sizes) {\n        int maxComparisons = (int)log2(size) + 1;\n        cout << setw(10) << size \n             << setw(20) << maxComparisons \n             << setw(20) << fixed << setprecision(2) << log2(size) << endl;\n    }\n    \n    cout << "\\nEven with 10 million elements, binary search needs only ";\n    cout << (int)log2(10000000) + 1 << " comparisons!" << endl;\n}\n\nint main() {\n    int arr[] = {1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    \n    cout << "Test 1: Element present in array" << endl;\n    binarySearchVisual(arr, n, 15);\n    \n    cout << "\\n\\nTest 2: Element not in array" << endl;\n    binarySearchVisual(arr, n, 20);\n    \n    demonstrateLogarithmicNature();\n    \n    return 0;\n}\n'})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Output:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"=== Binary Search Visualization ===\n\nArray: [0]:   1  [1]:   3  [2]:   5  [3]:   7  [4]:   9  [5]:  11  [6]:  13  [7]:  15  [8]:  17  [9]:  19  [10]:  21  [11]:  23  [12]:  25  [13]:  27  [14]:  29  \nTarget: 15\n\nStep 1:\n  Search space: indices 0 to 14\n  [(1) 3 5 7 9 11 13 15 17 19 21 23 25 27 29]\n  Compare target 15 with arr[7] = 15\n  \u2705 MATCH FOUND at index 7!\n\nTotal steps: 1\nMaximum possible steps for array of size 15: 4\n"})}),"\n",(0,t.jsx)(e.h2,{id:"binary-search-with-stl-functions",children:"Binary Search with STL Functions"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <iterator>\nusing namespace std;\n\nvoid demonstrateSTLBinarySearch() {\n    vector<int> vec = {1, 3, 5, 7, 9, 11, 13, 15, 17, 19};\n    \n    cout << "Vector: ";\n    for(int num : vec) cout << num << " ";\n    cout << endl;\n    \n    // 1. binary_search - returns bool\n    cout << "\\n1. std::binary_search():" << endl;\n    int target = 7;\n    if(binary_search(vec.begin(), vec.end(), target)) {\n        cout << "Element " << target << " exists in vector" << endl;\n    } else {\n        cout << "Element " << target << " does not exist" << endl;\n    }\n    \n    // 2. lower_bound - returns iterator to first element >= target\n    cout << "\\n2. std::lower_bound():" << endl;\n    target = 8;\n    auto lb = lower_bound(vec.begin(), vec.end(), target);\n    if(lb != vec.end()) {\n        cout << "First element >= " << target << " is " << *lb \n             << " at index " << distance(vec.begin(), lb) << endl;\n    } else {\n        cout << "No element >= " << target << endl;\n    }\n    \n    // 3. upper_bound - returns iterator to first element > target\n    cout << "\\n3. std::upper_bound():" << endl;\n    target = 7;\n    auto ub = upper_bound(vec.begin(), vec.end(), target);\n    if(ub != vec.end()) {\n        cout << "First element > " << target << " is " << *ub \n             << " at index " << distance(vec.begin(), ub) << endl;\n    } else {\n        cout << "No element > " << target << endl;\n    }\n    \n    // 4. equal_range - returns pair of lower_bound and upper_bound\n    cout << "\\n4. std::equal_range():" << endl;\n    target = 7;\n    auto bounds = equal_range(vec.begin(), vec.end(), target);\n    cout << "Range of " << target << ": [" \n         << distance(vec.begin(), bounds.first) << ", " \n         << distance(vec.begin(), bounds.second) << ")" << endl;\n    cout << "Elements in range: ";\n    for(auto it = bounds.first; it != bounds.second; ++it) {\n        cout << *it << " ";\n    }\n    cout << endl;\n}\n\n// Custom comparator for descending order\nvoid binarySearchDescending() {\n    vector<int> vec = {19, 17, 15, 13, 11, 9, 7, 5, 3, 1};\n    \n    cout << "\\nDescending vector: ";\n    for(int num : vec) cout << num << " ";\n    cout << endl;\n    \n    // Binary search with custom comparator\n    int target = 7;\n    auto comp = [](int a, int b) { return a > b; };  // For descending order\n    \n    if(binary_search(vec.begin(), vec.end(), target, comp)) {\n        cout << "Element " << target << " found in descending vector" << endl;\n    }\n    \n    // Find position\n    auto pos = lower_bound(vec.begin(), vec.end(), target, comp);\n    cout << "Position of " << target << " (or where it would be): index " \n         << distance(vec.begin(), pos) << endl;\n}\n\nint main() {\n    cout << "=== STL Binary Search Functions ===" << endl;\n    demonstrateSTLBinarySearch();\n    binarySearchDescending();\n    \n    return 0;\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"variations-of-binary-search",children:"Variations of Binary Search"}),"\n",(0,t.jsx)(e.h3,{id:"1-finding-first-occurrence",children:"1. Finding First Occurrence"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <vector>\nusing namespace std;\n\nint findFirstOccurrence(int arr[], int n, int target) {\n    int left = 0;\n    int right = n - 1;\n    int result = -1;\n    \n    cout << "Finding FIRST occurrence of " << target << endl;\n    \n    while(left <= right) {\n        int mid = left + (right - left) / 2;\n        \n        cout << "  left=" << left << ", right=" << right \n             << ", mid=" << mid << ", arr[mid]=" << arr[mid] << endl;\n        \n        if(arr[mid] == target) {\n            result = mid;        // Record position\n            right = mid - 1;     // Continue searching left\n            cout << "    Found at " << mid << ", now searching left for earlier occurrence" << endl;\n        }\n        else if(arr[mid] < target) {\n            left = mid + 1;\n        }\n        else {\n            right = mid - 1;\n        }\n    }\n    \n    return result;\n}\n\nint main() {\n    int arr[] = {2, 4, 10, 10, 10, 18, 20, 20, 30, 30, 30, 30, 40};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    \n    cout << "Array (with duplicates): ";\n    for(int i = 0; i < n; i++) cout << arr[i] << " ";\n    cout << endl;\n    \n    int target = 10;\n    int first = findFirstOccurrence(arr, n, target);\n    \n    if(first != -1) {\n        cout << "\\nFirst occurrence of " << target << " is at index: " << first << endl;\n    } else {\n        cout << "\\nElement not found" << endl;\n    }\n    \n    target = 30;\n    first = findFirstOccurrence(arr, n, target);\n    cout << "\\nFirst occurrence of " << target << " is at index: " << first << endl;\n    \n    return 0;\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"2-finding-last-occurrence",children:"2. Finding Last Occurrence"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\nusing namespace std;\n\nint findLastOccurrence(int arr[], int n, int target) {\n    int left = 0;\n    int right = n - 1;\n    int result = -1;\n    \n    cout << "Finding LAST occurrence of " << target << endl;\n    \n    while(left <= right) {\n        int mid = left + (right - left) / 2;\n        \n        cout << "  left=" << left << ", right=" << right \n             << ", mid=" << mid << ", arr[mid]=" << arr[mid] << endl;\n        \n        if(arr[mid] == target) {\n            result = mid;        // Record position\n            left = mid + 1;      // Continue searching right\n            cout << "    Found at " << mid << ", now searching right for later occurrence" << endl;\n        }\n        else if(arr[mid] < target) {\n            left = mid + 1;\n        }\n        else {\n            right = mid - 1;\n        }\n    }\n    \n    return result;\n}\n\nint main() {\n    int arr[] = {2, 4, 10, 10, 10, 18, 20, 20, 30, 30, 30, 30, 40};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    \n    cout << "Array: ";\n    for(int i = 0; i < n; i++) cout << arr[i] << " ";\n    cout << endl;\n    \n    int target = 30;\n    int last = findLastOccurrence(arr, n, target);\n    \n    if(last != -1) {\n        cout << "\\nLast occurrence of " << target << " is at index: " << last << endl;\n    } else {\n        cout << "\\nElement not found" << endl;\n    }\n    \n    return 0;\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"3-count-occurrences-using-binary-search",children:"3. Count Occurrences using Binary Search"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\nusing namespace std;\n\nint countOccurrences(int arr[], int n, int target) {\n    // Find first occurrence\n    int first = -1;\n    int left = 0, right = n - 1;\n    \n    while(left <= right) {\n        int mid = left + (right - left) / 2;\n        if(arr[mid] == target) {\n            first = mid;\n            right = mid - 1;\n        }\n        else if(arr[mid] < target) {\n            left = mid + 1;\n        }\n        else {\n            right = mid - 1;\n        }\n    }\n    \n    if(first == -1) return 0;  // Element not found\n    \n    // Find last occurrence\n    int last = -1;\n    left = 0;\n    right = n - 1;\n    \n    while(left <= right) {\n        int mid = left + (right - left) / 2;\n        if(arr[mid] == target) {\n            last = mid;\n            left = mid + 1;\n        }\n        else if(arr[mid] < target) {\n            left = mid + 1;\n        }\n        else {\n            right = mid - 1;\n        }\n    }\n    \n    return last - first + 1;\n}\n\nint main() {\n    int arr[] = {2, 4, 10, 10, 10, 18, 20, 20, 30, 30, 30, 30, 40};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    \n    cout << "Array: ";\n    for(int i = 0; i < n; i++) cout << arr[i] << " ";\n    cout << endl;\n    \n    int target = 10;\n    int count = countOccurrences(arr, n, target);\n    cout << "\\nElement " << target << " occurs " << count << " times" << endl;\n    \n    target = 30;\n    count = countOccurrences(arr, n, target);\n    cout << "Element " << target << " occurs " << count << " times" << endl;\n    \n    target = 25;\n    count = countOccurrences(arr, n, target);\n    cout << "Element " << target << " occurs " << count << " times" << endl;\n    \n    return 0;\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"advanced-binary-search-problems",children:"Advanced Binary Search Problems"}),"\n",(0,t.jsx)(e.h3,{id:"1-find-floor-and-ceil",children:"1. Find Floor and Ceil"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <climits>\nusing namespace std;\n\npair<int, int> findFloorCeil(int arr[], int n, int target) {\n    int floor = INT_MIN;\n    int ceil = INT_MAX;\n    \n    int left = 0, right = n - 1;\n    \n    while(left <= right) {\n        int mid = left + (right - left) / 2;\n        \n        if(arr[mid] == target) {\n            return {arr[mid], arr[mid]};  // Both floor and ceil are the element itself\n        }\n        else if(arr[mid] < target) {\n            floor = max(floor, arr[mid]);  // Update floor\n            left = mid + 1;\n        }\n        else {\n            ceil = min(ceil, arr[mid]);    // Update ceil\n            right = mid - 1;\n        }\n    }\n    \n    return {floor, ceil};\n}\n\nint main() {\n    int arr[] = {1, 2, 8, 10, 10, 12, 19};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    \n    cout << "Array: ";\n    for(int i = 0; i < n; i++) cout << arr[i] << " ";\n    cout << endl;\n    \n    vector<int> testValues = {0, 1, 5, 10, 15, 20};\n    \n    for(int target : testValues) {\n        auto [floor, ceil] = findFloorCeil(arr, n, target);\n        \n        cout << "\\nTarget: " << target << endl;\n        if(floor == INT_MIN) {\n            cout << "Floor: Doesn\'t exist" << endl;\n        } else {\n            cout << "Floor: " << floor << endl;\n        }\n        \n        if(ceil == INT_MAX) {\n            cout << "Ceil: Doesn\'t exist" << endl;\n        } else {\n            cout << "Ceil: " << ceil << endl;\n        }\n    }\n    \n    return 0;\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"2-find-minimum-in-rotated-sorted-array",children:"2. Find Minimum in Rotated Sorted Array"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <vector>\nusing namespace std;\n\nint findMinInRotatedArray(int arr[], int n) {\n    int left = 0;\n    int right = n - 1;\n    \n    cout << "Finding minimum in rotated sorted array" << endl;\n    \n    // If array is not rotated\n    if(arr[left] < arr[right]) {\n        cout << "Array is not rotated, minimum is first element" << endl;\n        return arr[left];\n    }\n    \n    while(left < right) {\n        int mid = left + (right - left) / 2;\n        \n        cout << "  left=" << left << "(" << arr[left] << "), "\n             << "right=" << right << "(" << arr[right] << "), "\n             << "mid=" << mid << "(" << arr[mid] << ")" << endl;\n        \n        if(arr[mid] > arr[right]) {\n            // Minimum is in right half\n            left = mid + 1;\n            cout << "    arr[mid] > arr[right], search RIGHT" << endl;\n        } else {\n            // Minimum is in left half (including mid)\n            right = mid;\n            cout << "    arr[mid] <= arr[right], search LEFT (including mid)" << endl;\n        }\n    }\n    \n    cout << "Minimum found at index " << left << endl;\n    return arr[left];\n}\n\nint main() {\n    // Test cases\n    int arr1[] = {4, 5, 6, 7, 0, 1, 2};\n    int n1 = sizeof(arr1) / sizeof(arr1[0]);\n    \n    cout << "Array 1: ";\n    for(int i = 0; i < n1; i++) cout << arr1[i] << " ";\n    cout << endl;\n    \n    int min1 = findMinInRotatedArray(arr1, n1);\n    cout << "Minimum: " << min1 << endl;\n    \n    cout << "\\n" << string(40, \'-\') << endl;\n    \n    int arr2[] = {3, 4, 5, 1, 2};\n    int n2 = sizeof(arr2) / sizeof(arr2[0]);\n    \n    cout << "Array 2: ";\n    for(int i = 0; i < n2; i++) cout << arr2[i] << " ";\n    cout << endl;\n    \n    int min2 = findMinInRotatedArray(arr2, n2);\n    cout << "Minimum: " << min2 << endl;\n    \n    return 0;\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"3-search-in-rotated-sorted-array",children:"3. Search in Rotated Sorted Array"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\nusing namespace std;\n\nint searchInRotatedArray(int arr[], int n, int target) {\n    int left = 0;\n    int right = n - 1;\n    \n    cout << "Searching for " << target << " in rotated array" << endl;\n    \n    while(left <= right) {\n        int mid = left + (right - left) / 2;\n        \n        cout << "  left=" << left << "(" << arr[left] << "), "\n             << "right=" << right << "(" << arr[right] << "), "\n             << "mid=" << mid << "(" << arr[mid] << ")" << endl;\n        \n        if(arr[mid] == target) {\n            return mid;\n        }\n        \n        // Left half is sorted\n        if(arr[left] <= arr[mid]) {\n            cout << "    Left half [" << left << "-" << mid << "] is sorted" << endl;\n            if(arr[left] <= target && target < arr[mid]) {\n                // Target in sorted left half\n                cout << "    Target in sorted left half" << endl;\n                right = mid - 1;\n            } else {\n                // Target in right half\n                cout << "    Target in right half" << endl;\n                left = mid + 1;\n            }\n        }\n        // Right half is sorted\n        else {\n            cout << "    Right half [" << mid << "-" << right << "] is sorted" << endl;\n            if(arr[mid] < target && target <= arr[right]) {\n                // Target in sorted right half\n                cout << "    Target in sorted right half" << endl;\n                left = mid + 1;\n            } else {\n                // Target in left half\n                cout << "    Target in left half" << endl;\n                right = mid - 1;\n            }\n        }\n    }\n    \n    return -1;\n}\n\nint main() {\n    int arr[] = {4, 5, 6, 7, 0, 1, 2};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    \n    cout << "Rotated array: ";\n    for(int i = 0; i < n; i++) cout << arr[i] << " ";\n    cout << endl;\n    \n    vector<int> testTargets = {0, 3, 5, 7};\n    \n    for(int target : testTargets) {\n        cout << "\\nSearching for " << target << ":" << endl;\n        int result = searchInRotatedArray(arr, n, target);\n        \n        if(result != -1) {\n            cout << "Found at index: " << result << endl;\n        } else {\n            cout << "Not found" << endl;\n        }\n    }\n    \n    return 0;\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"binary-search-on-answer-predicate-based",children:"Binary Search on Answer (Predicate-based)"}),"\n",(0,t.jsx)(e.h3,{id:"1-find-square-root-with-precision",children:"1. Find Square Root with Precision"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <iomanip>\n#include <cmath>\nusing namespace std;\n\n// Find integer square root\nint sqrtInteger(int n) {\n    if(n < 2) return n;\n    \n    int left = 1, right = n;\n    int result = 0;\n    \n    cout << "Finding integer square root of " << n << endl;\n    \n    while(left <= right) {\n        int mid = left + (right - left) / 2;\n        long long square = (long long)mid * mid;\n        \n        cout << "  Trying mid=" << mid << ", square=" << square << endl;\n        \n        if(square == n) {\n            return mid;\n        }\n        else if(square < n) {\n            result = mid;        // Store as potential answer\n            left = mid + 1;\n            cout << "    square < n, update result to " << result << endl;\n        }\n        else {\n            right = mid - 1;\n            cout << "    square > n, search left" << endl;\n        }\n    }\n    \n    return result;\n}\n\n// Find square root with precision\ndouble sqrtPrecision(int n, int precision) {\n    double result = sqrtInteger(n);\n    \n    cout << "\\nFinding square root with precision " << precision << endl;\n    cout << "Integer part: " << result << endl;\n    \n    double increment = 0.1;\n    for(int p = 0; p < precision; p++) {\n        while(result * result <= n) {\n            result += increment;\n            cout << "  Trying " << fixed << setprecision(p+1) \n                 << result << ", square=" << result*result << endl;\n        }\n        \n        // Step back once\n        result -= increment;\n        increment /= 10;\n    }\n    \n    return result;\n}\n\nint main() {\n    int n = 50;\n    \n    cout << "=== Finding Square Root of " << n << " ===" << endl;\n    \n    int intSqrt = sqrtInteger(n);\n    cout << "\\nInteger square root: " << intSqrt << endl;\n    \n    double preciseSqrt = sqrtPrecision(n, 3);\n    cout << "\\nSquare root with 3 decimal places: " \n         << fixed << setprecision(3) << preciseSqrt << endl;\n    cout << "Actual sqrt(" << n << "): " << sqrt(n) << endl;\n    \n    return 0;\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"2-find-peak-element",children:"2. Find Peak Element"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <vector>\nusing namespace std;\n\nint findPeakElement(int arr[], int n) {\n    int left = 0;\n    int right = n - 1;\n    \n    cout << "Finding peak element" << endl;\n    \n    while(left < right) {\n        int mid = left + (right - left) / 2;\n        \n        cout << "  left=" << left << "(" << arr[left] << "), "\n             << "right=" << right << "(" << arr[right] << "), "\n             << "mid=" << mid << "(" << arr[mid] << ")" << endl;\n        \n        if(arr[mid] > arr[mid + 1]) {\n            // Peak is in left half (including mid)\n            cout << "    arr[mid] > arr[mid+1], peak in LEFT half" << endl;\n            right = mid;\n        } else {\n            // Peak is in right half\n            cout << "    arr[mid] <= arr[mid+1], peak in RIGHT half" << endl;\n            left = mid + 1;\n        }\n    }\n    \n    cout << "Peak found at index " << left << endl;\n    return left;\n}\n\nint main() {\n    // Test cases\n    int arr1[] = {1, 2, 3, 1};\n    int n1 = sizeof(arr1) / sizeof(arr1[0]);\n    \n    cout << "Array 1: ";\n    for(int i = 0; i < n1; i++) cout << arr[i] << " ";\n    cout << endl;\n    \n    int peak1 = findPeakElement(arr1, n1);\n    cout << "Peak element index: " << peak1 << ", value: " << arr1[peak1] << endl;\n    \n    cout << "\\n" << string(40, \'-\') << endl;\n    \n    int arr2[] = {1, 2, 1, 3, 5, 6, 4};\n    int n2 = sizeof(arr2) / sizeof(arr2[0]);\n    \n    cout << "Array 2: ";\n    for(int i = 0; i < n2; i++) cout << arr2[i] << " ";\n    cout << endl;\n    \n    int peak2 = findPeakElement(arr2, n2);\n    cout << "Peak element index: " << peak2 << ", value: " << arr2[peak2] << endl;\n    \n    return 0;\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"binary-search-in-2d-arrays-matrix",children:"Binary Search in 2D Arrays (Matrix)"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Binary search in sorted matrix\npair<int, int> binarySearchMatrix(vector<vector<int>>& matrix, int target) {\n    if(matrix.empty() || matrix[0].empty()) return {-1, -1};\n    \n    int rows = matrix.size();\n    int cols = matrix[0].size();\n    \n    int left = 0;\n    int right = rows * cols - 1;  // Treat matrix as 1D array\n    \n    cout << "Searching for " << target << " in " \n         << rows << "x" << cols << " matrix" << endl;\n    cout << "Treating matrix as 1D array of size " << rows * cols << endl;\n    \n    while(left <= right) {\n        int mid = left + (right - left) / 2;\n        \n        // Convert 1D index to 2D indices\n        int row = mid / cols;\n        int col = mid % cols;\n        int value = matrix[row][col];\n        \n        cout << "  left=" << left << ", right=" << right \n             << ", mid=" << mid << " -> (" << row << "," << col \n             << ") = " << value << endl;\n        \n        if(value == target) {\n            return {row, col};\n        }\n        else if(value < target) {\n            left = mid + 1;\n        }\n        else {\n            right = mid - 1;\n        }\n    }\n    \n    return {-1, -1};\n}\n\n// Search in row-wise and column-wise sorted matrix\npair<int, int> searchInSortedMatrix(vector<vector<int>>& matrix, int target) {\n    if(matrix.empty() || matrix[0].empty()) return {-1, -1};\n    \n    int rows = matrix.size();\n    int cols = matrix[0].size();\n    \n    // Start from top-right corner\n    int row = 0;\n    int col = cols - 1;\n    \n    cout << "Starting from top-right corner (" << row << "," << col << ")" << endl;\n    \n    while(row < rows && col >= 0) {\n        int value = matrix[row][col];\n        \n        cout << "  Checking (" << row << "," << col << ") = " << value << endl;\n        \n        if(value == target) {\n            return {row, col};\n        }\n        else if(value > target) {\n            cout << "    Value > target, move LEFT" << endl;\n            col--;  // Move left in same row\n        }\n        else {\n            cout << "    Value < target, move DOWN" << endl;\n            row++;  // Move down to next row\n        }\n    }\n    \n    return {-1, -1};\n}\n\nint main() {\n    // Sorted matrix (both rows and columns sorted)\n    vector<vector<int>> matrix1 = {\n        {1, 3, 5, 7},\n        {10, 11, 16, 20},\n        {23, 30, 34, 60}\n    };\n    \n    cout << "Matrix 1 (sorted):" << endl;\n    for(const auto& row : matrix1) {\n        for(int num : row) cout << num << "\\t";\n        cout << endl;\n    }\n    \n    int target = 16;\n    auto [r1, c1] = binarySearchMatrix(matrix1, target);\n    \n    if(r1 != -1) {\n        cout << "\\nFound " << target << " at (" << r1 << "," << c1 << ")" << endl;\n    } else {\n        cout << "\\n" << target << " not found" << endl;\n    }\n    \n    // Row-wise and column-wise sorted matrix\n    vector<vector<int>> matrix2 = {\n        {10, 20, 30, 40},\n        {15, 25, 35, 45},\n        {27, 29, 37, 48},\n        {32, 33, 39, 50}\n    };\n    \n    cout << "\\n\\nMatrix 2 (row and column sorted):" << endl;\n    for(const auto& row : matrix2) {\n        for(int num : row) cout << num << "\\t";\n        cout << endl;\n    }\n    \n    target = 29;\n    auto [r2, c2] = searchInSortedMatrix(matrix2, target);\n    \n    if(r2 != -1) {\n        cout << "\\nFound " << target << " at (" << r2 << "," << c2 << ")" << endl;\n    } else {\n        cout << "\\n" << target << " not found" << endl;\n    }\n    \n    return 0;\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"performance-analysis-1",children:"Performance Analysis"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <chrono>\n#include <random>\n#include <vector>\n#include <algorithm>\n#include <iomanip>\nusing namespace std;\nusing namespace chrono;\n\nvoid performanceComparison() {\n    random_device rd;\n    mt19937 gen(rd());\n    uniform_int_distribution<> dis(1, 10000000);\n    \n    vector<int> sizes = {1000, 10000, 100000, 1000000, 10000000};\n    \n    cout << "Binary Search vs Linear Search Performance\\n" << endl;\n    cout << setw(12) << "Array Size" \n         << setw(20) << "Binary Search" \n         << setw(20) << "Linear Search" \n         << setw(15) << "Speedup" << endl;\n    cout << string(67, \'-\') << endl;\n    \n    for(int size : sizes) {\n        // Generate sorted data\n        vector<int> data(size);\n        for(int i = 0; i < size; i++) {\n            data[i] = dis(gen);\n        }\n        sort(data.begin(), data.end());\n        \n        // Choose a target (middle element for average case)\n        int target = data[size / 2];\n        \n        // Binary Search\n        auto start = high_resolution_clock::now();\n        \n        int left = 0, right = size - 1;\n        while(left <= right) {\n            int mid = left + (right - left) / 2;\n            if(data[mid] == target) break;\n            else if(data[mid] < target) left = mid + 1;\n            else right = mid - 1;\n        }\n        \n        auto end = high_resolution_clock::now();\n        auto binaryTime = duration_cast<nanoseconds>(end - start).count();\n        \n        // Linear Search\n        start = high_resolution_clock::now();\n        \n        for(int i = 0; i < size; i++) {\n            if(data[i] == target) break;\n        }\n        \n        end = high_resolution_clock::now();\n        auto linearTime = duration_cast<nanoseconds>(end - start).count();\n        \n        double speedup = (double)linearTime / binaryTime;\n        \n        cout << setw(12) << size \n             << setw(20) << binaryTime << " ns"\n             << setw(20) << linearTime << " ns"\n             << setw(15) << fixed << setprecision(1) << speedup << "x" << endl;\n    }\n    \n    cout << "\\n" << string(67, \'=\') << endl;\n    cout << "Key Observations:" << endl;\n    cout << "1. Binary search is O(log n), linear search is O(n)" << endl;\n    cout << "2. For 10 million elements, binary search is thousands of times faster!" << endl;\n    cout << "3. Binary search requires sorted data as prerequisite" << endl;\n}\n\n// Demonstrate worst-case comparisons\nvoid worstCaseAnalysis() {\n    cout << "\\n\\nWorst-case Comparisons Analysis\\n" << endl;\n    cout << setw(12) << "Array Size" \n         << setw(20) << "Max Comparisons" \n         << setw(25) << "log\u2082(n) (rounded up)" << endl;\n    cout << string(57, \'-\') << endl;\n    \n    for(int size = 10; size <= 1000000000; size *= 10) {\n        int maxComparisons = (int)ceil(log2(size));\n        cout << setw(12) << size \n             << setw(20) << maxComparisons \n             << setw(25) << log2(size) << endl;\n    }\n}\n\nint main() {\n    performanceComparison();\n    worstCaseAnalysis();\n    return 0;\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"common-interview-questions-3",children:"Common Interview Questions"}),"\n",(0,t.jsx)(e.h3,{id:"1-implement-binary-search",children:"1. Implement Binary Search"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:"// Already shown in basic examples\n"})}),"\n",(0,t.jsx)(e.h3,{id:"2-find-first-and-last-position-of-element",children:"2. Find First and Last Position of Element"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> searchRange(int arr[], int n, int target) {\n    vector<int> result = {-1, -1};\n    \n    // Find first position\n    int left = 0, right = n - 1;\n    while(left <= right) {\n        int mid = left + (right - left) / 2;\n        if(arr[mid] == target) {\n            result[0] = mid;\n            right = mid - 1;  // Continue searching left\n        }\n        else if(arr[mid] < target) {\n            left = mid + 1;\n        }\n        else {\n            right = mid - 1;\n        }\n    }\n    \n    // Find last position\n    left = 0, right = n - 1;\n    while(left <= right) {\n        int mid = left + (right - left) / 2;\n        if(arr[mid] == target) {\n            result[1] = mid;\n            left = mid + 1;  // Continue searching right\n        }\n        else if(arr[mid] < target) {\n            left = mid + 1;\n        }\n        else {\n            right = mid - 1;\n        }\n    }\n    \n    return result;\n}\n\nint main() {\n    int arr[] = {5, 7, 7, 8, 8, 10};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    int target = 8;\n    \n    cout << "Array: ";\n    for(int i = 0; i < n; i++) cout << arr[i] << " ";\n    cout << "\\nTarget: " << target << endl;\n    \n    vector<int> range = searchRange(arr, n, target);\n    cout << "Range: [" << range[0] << ", " << range[1] << "]" << endl;\n    \n    return 0;\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"3-find-minimum-in-rotated-sorted-array",children:"3. Find Minimum in Rotated Sorted Array"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:"// Already shown in advanced problems\n"})}),"\n",(0,t.jsx)(e.h3,{id:"4-find-peak-element",children:"4. Find Peak Element"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:"// Already shown in advanced problems\n"})}),"\n",(0,t.jsx)(e.h3,{id:"5-search-in-infinite-sorted-array",children:"5. Search in Infinite Sorted Array"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Simulating infinite array with bounds\nint searchInfiniteArray(int arr[], int target) {\n    // Start with small window\n    int low = 0;\n    int high = 1;\n    \n    cout << "Searching in \'infinite\' array for " << target << endl;\n    \n    // Double the window until we find bounds\n    while(arr[high] < target) {\n        cout << "  Window [" << low << "-" << high << "], arr[" \n             << high << "]=" << arr[high] << " < " << target << endl;\n        low = high;\n        high *= 2;\n        cout << "  Doubling window to [" << low << "-" << high << "]" << endl;\n    }\n    \n    cout << "  Final window: [" << low << "-" << high \n         << "], arr[" << high << "]=" << arr[high] << " >= " << target << endl;\n    \n    // Now perform normal binary search\n    while(low <= high) {\n        int mid = low + (high - low) / 2;\n        \n        if(arr[mid] == target) {\n            return mid;\n        }\n        else if(arr[mid] < target) {\n            low = mid + 1;\n        }\n        else {\n            high = mid - 1;\n        }\n    }\n    \n    return -1;\n}\n\nint main() {\n    // Simulating "infinite" array (actually finite but we don\'t know size)\n    const int SIZE = 1000;\n    int arr[SIZE];\n    for(int i = 0; i < SIZE; i++) {\n        arr[i] = i * 2;  // Even numbers\n    }\n    \n    int target = 256;\n    int result = searchInfiniteArray(arr, target);\n    \n    if(result != -1) {\n        cout << "\\nFound " << target << " at index " << result << endl;\n    } else {\n        cout << "\\n" << target << " not found" << endl;\n    }\n    \n    return 0;\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"advantages-and-disadvantages-3",children:"Advantages and Disadvantages"}),"\n",(0,t.jsx)(e.h3,{id:"advantages-3",children:"Advantages:"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Extremely fast"}),": O(log n) time complexity"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Efficient for large datasets"}),": Scales well with input size"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Simple concept"}),": Easy to understand and implement"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Foundation for many algorithms"}),": Used in trees, databases, etc."]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"disadvantages-3",children:"Disadvantages:"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Requires sorted data"}),": Sorting adds O(n log n) overhead"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Not suitable for linked lists"}),": Random access required"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"More complex than linear search"}),": Slightly harder to implement correctly"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Overflow risk"}),": Calculating mid can overflow for large indices"]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"when-to-use-binary-search",children:"When to Use Binary Search"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Large sorted datasets"})," (n > 1000)"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Frequent search operations"})," on static data"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"When data can be pre-sorted"})," once and searched many times"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Memory is limited"})," (binary search uses O(1) space)"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"When predictable performance"})," is required"]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"summary-4",children:"Summary"}),"\n",(0,t.jsx)(e.p,{children:"Binary Search is one of the most important and efficient searching algorithms in computer science. Its logarithmic time complexity makes it incredibly fast even for massive datasets."}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Key Takeaways:"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Requires sorted data as prerequisite"}),"\n",(0,t.jsx)(e.li,{children:"Time complexity: O(log n) - extremely efficient"}),"\n",(0,t.jsx)(e.li,{children:"Space complexity: O(1) for iterative, O(log n) for recursive"}),"\n",(0,t.jsx)(e.li,{children:"Foundation for more advanced algorithms and data structures"}),"\n",(0,t.jsx)(e.li,{children:"Many variations: first/last occurrence, rotated arrays, etc."}),"\n",(0,t.jsx)(e.li,{children:"Used in databases, file systems, and many real-world applications"}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Remember:"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Always check if data is sorted before using binary search"}),"\n",(0,t.jsx)(e.li,{children:"Be careful with integer overflow when calculating mid"}),"\n",(0,t.jsx)(e.li,{children:"Consider using STL functions (binary_search, lower_bound, etc.) when possible"}),"\n",(0,t.jsx)(e.li,{children:"Understand the variations for different problem types"}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:"Binary Search demonstrates the power of divide-and-conquer algorithms and is essential knowledge for any programmer or computer scientist."}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.em,{children:"This completes our comprehensive DSA notes covering Arrays, Sorting Algorithms (Bubble, Selection, Insertion, Quick, Counting, Radix, Merge), and Searching Algorithms (Linear, Binary). Each section includes theory, implementations, visualizations, complexity analysis, and practical applications."})})]})}function u(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(d,{...n})}):d(n)}},8453(n,e,i){i.d(e,{R:()=>s,x:()=>o});var t=i(6540);const r={},a=t.createContext(r);function s(n){const e=t.useContext(a);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function o(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:s(n.components),t.createElement(a.Provider,{value:e},n.children)}}}]);