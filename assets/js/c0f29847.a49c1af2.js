"use strict";(globalThis.webpackChunkmy_dsa_notes=globalThis.webpackChunkmy_dsa_notes||[]).push([[950],{6557(n,e,r){r.r(e),r.d(e,{assets:()=>l,contentTitle:()=>d,default:()=>u,frontMatter:()=>a,metadata:()=>t,toc:()=>s});const t=JSON.parse('{"id":"trees","title":"DSA Trees","description":"Introduction to Trees","source":"@site/docs/trees.md","sourceDirName":".","slug":"/trees","permalink":"/trees","draft":false,"unlisted":false,"editUrl":"https://github.com/kalyxon/markdown-web-app/tree/main/docs/trees.md","tags":[],"version":"current","frontMatter":{},"sidebar":"dsa","previous":{"title":"DSA Hash Tables","permalink":"/hash-tables"},"next":{"title":"DSA Graphs","permalink":"/graphs"}}');var o=r(4848),i=r(8453);const a={},d="DSA Trees",l={},s=[{value:"Introduction to Trees",id:"introduction-to-trees",level:2},{value:"Key Characteristics:",id:"key-characteristics",level:3},{value:"Basic Tree Implementation in C++",id:"basic-tree-implementation-in-c",level:2},{value:"Introduction to Binary Trees",id:"introduction-to-binary-trees",level:2},{value:"Key Characteristics:",id:"key-characteristics-1",level:3},{value:"Binary Tree Implementation",id:"binary-tree-implementation",level:2},{value:"Tree Traversal Techniques",id:"tree-traversal-techniques",level:2},{value:"1. Pre-order Traversal (Root \u2192 Left \u2192 Right)",id:"1-pre-order-traversal-root--left--right",level:2},{value:"Algorithm:",id:"algorithm",level:3},{value:"2. In-order Traversal (Left \u2192 Root \u2192 Right)",id:"2-in-order-traversal-left--root--right",level:2},{value:"Algorithm:",id:"algorithm-1",level:3},{value:"3. Post-order Traversal (Left \u2192 Right \u2192 Root)",id:"3-post-order-traversal-left--right--root",level:2},{value:"Algorithm:",id:"algorithm-2",level:3},{value:"Complete Implementation of All Traversals",id:"complete-implementation-of-all-traversals",level:2},{value:"Array Representation of Binary Trees",id:"array-representation-of-binary-trees",level:2},{value:"Indexing Formulas (for 0-based array):",id:"indexing-formulas-for-0-based-array",level:3},{value:"Advantages:",id:"advantages",level:3},{value:"Disadvantages:",id:"disadvantages",level:3},{value:"Complete Implementation",id:"complete-implementation",level:2},{value:"Introduction to Binary Search Trees",id:"introduction-to-binary-search-trees",level:2},{value:"Key Characteristics:",id:"key-characteristics-2",level:3},{value:"Complete BST Implementation",id:"complete-bst-implementation",level:2},{value:"Introduction to AVL Trees",id:"introduction-to-avl-trees",level:2},{value:"Key Characteristics:",id:"key-characteristics-3",level:3},{value:"Balance Factor:",id:"balance-factor",level:3},{value:"Rotation Cases:",id:"rotation-cases",level:2},{value:"Complete AVL Tree Implementation",id:"complete-avl-tree-implementation",level:2},{value:"Summary",id:"summary",level:2}];function c(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...n.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.header,{children:(0,o.jsx)(e.h1,{id:"dsa-trees",children:"DSA Trees"})}),"\n",(0,o.jsx)(e.h2,{id:"introduction-to-trees",children:"Introduction to Trees"}),"\n",(0,o.jsxs)(e.p,{children:["A ",(0,o.jsx)(e.strong,{children:"Tree"})," is a hierarchical, non-linear data structure consisting of nodes connected by edges. Unlike linear data structures (arrays, linked lists), trees allow us to organize data in a hierarchical manner, making them ideal for representing relationships, hierarchies, and sorted data."]}),"\n",(0,o.jsx)(e.h3,{id:"key-characteristics",children:"Key Characteristics:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Root"}),": Topmost node (no parent)"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Parent/Child"}),": Relationship between nodes"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Leaf"}),": Node with no children"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Edge"}),": Connection between nodes"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Height/Depth"}),": Length of longest path from root to leaf"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Degree"}),": Number of children a node has"]}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"basic-tree-implementation-in-c",children:"Basic Tree Implementation in C++"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <vector>\nusing namespace std;\n\n// TreeNode class\ntemplate <typename T>\nclass TreeNode {\npublic:\n    T data;\n    vector<TreeNode<T>*> children;\n    \n    TreeNode(T data) : data(data) {}\n    \n    // Destructor to clean up memory\n    ~TreeNode() {\n        for(int i = 0; i < children.size(); i++) {\n            delete children[i];\n        }\n    }\n    \n    // Add child to node\n    void addChild(TreeNode<T>* child) {\n        children.push_back(child);\n    }\n    \n    // Print tree (pre-order traversal)\n    void printTree(int level = 0) {\n        // Print current node\n        for(int i = 0; i < level; i++) {\n            cout << "  ";\n        }\n        cout << data << endl;\n        \n        // Recursively print children\n        for(auto child : children) {\n            child->printTree(level + 1);\n        }\n    }\n    \n    // Get number of children\n    int getChildCount() {\n        return children.size();\n    }\n    \n    // Check if node is leaf\n    bool isLeaf() {\n        return children.empty();\n    }\n};\n\n// Tree class\ntemplate <typename T>\nclass Tree {\nprivate:\n    TreeNode<T>* root;\n    \npublic:\n    Tree() : root(nullptr) {}\n    \n    Tree(T data) {\n        root = new TreeNode<T>(data);\n    }\n    \n    ~Tree() {\n        if(root) delete root;\n    }\n    \n    // Get root node\n    TreeNode<T>* getRoot() {\n        return root;\n    }\n    \n    // Set root node\n    void setRoot(TreeNode<T>* node) {\n        if(root) delete root;\n        root = node;\n    }\n    \n    // Build a sample tree\n    void buildSampleTree() {\n        root = new TreeNode<T>(1);\n        \n        TreeNode<T>* node2 = new TreeNode<T>(2);\n        TreeNode<T>* node3 = new TreeNode<T>(3);\n        TreeNode<T>* node4 = new TreeNode<T>(4);\n        TreeNode<T>* node5 = new TreeNode<T>(5);\n        TreeNode<T>* node6 = new TreeNode<T>(6);\n        \n        root->addChild(node2);\n        root->addChild(node3);\n        \n        node2->addChild(node4);\n        node2->addChild(node5);\n        \n        node3->addChild(node6);\n    }\n    \n    // Print the entire tree\n    void printTree() {\n        if(root) {\n            root->printTree();\n        } else {\n            cout << "Tree is empty!" << endl;\n        }\n    }\n    \n    // Count total nodes in tree\n    int countNodes() {\n        return countNodesHelper(root);\n    }\n    \nprivate:\n    int countNodesHelper(TreeNode<T>* node) {\n        if(!node) return 0;\n        \n        int count = 1; // Count current node\n        for(auto child : node->children) {\n            count += countNodesHelper(child);\n        }\n        return count;\n    }\n};\n\nint main() {\n    Tree<int> tree;\n    tree.buildSampleTree();\n    \n    cout << "Tree Structure:" << endl;\n    tree.printTree();\n    \n    cout << "\\nTotal nodes: " << tree.countNodes() << endl;\n    \n    return 0;\n}\n'})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Output:"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{children:"Tree Structure:\n1\n  2\n    4\n    5\n  3\n    6\n\nTotal nodes: 6\n"})}),"\n",(0,o.jsx)(e.hr,{}),"\n",(0,o.jsx)(e.h1,{id:"dsa-binary-trees---complete-c-guide",children:"DSA Binary Trees - Complete C++ Guide"}),"\n",(0,o.jsx)(e.h2,{id:"introduction-to-binary-trees",children:"Introduction to Binary Trees"}),"\n",(0,o.jsxs)(e.p,{children:["A ",(0,o.jsx)(e.strong,{children:"Binary Tree"})," is a specialized tree data structure where each node has at most two children, typically referred to as the ",(0,o.jsx)(e.strong,{children:"left child"})," and ",(0,o.jsx)(e.strong,{children:"right child"}),". Binary trees are fundamental to many advanced data structures and algorithms."]}),"\n",(0,o.jsx)(e.h3,{id:"key-characteristics-1",children:"Key Characteristics:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Each node has 0, 1, or 2 children"}),"\n",(0,o.jsx)(e.li,{children:"Left and right child distinction is important"}),"\n",(0,o.jsx)(e.li,{children:"Height-balanced trees optimize search operations"}),"\n",(0,o.jsx)(e.li,{children:"Used in expression trees, heap data structures, and binary search trees"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"binary-tree-implementation",children:"Binary Tree Implementation"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <queue>\n#include <stack>\n#include <cmath>\nusing namespace std;\n\n// Binary Tree Node\ntemplate <typename T>\nclass BinaryTreeNode {\npublic:\n    T data;\n    BinaryTreeNode<T>* left;\n    BinaryTreeNode<T>* right;\n    \n    BinaryTreeNode(T data) : data(data), left(nullptr), right(nullptr) {}\n    \n    // Check if node is leaf\n    bool isLeaf() {\n        return (left == nullptr && right == nullptr);\n    }\n};\n\n// Binary Tree Class\ntemplate <typename T>\nclass BinaryTree {\nprivate:\n    BinaryTreeNode<T>* root;\n    \npublic:\n    BinaryTree() : root(nullptr) {}\n    \n    ~BinaryTree() {\n        deleteTree(root);\n    }\n    \n    // Set root\n    void setRoot(BinaryTreeNode<T>* node) {\n        root = node;\n    }\n    \n    // Get root\n    BinaryTreeNode<T>* getRoot() {\n        return root;\n    }\n    \n    // Build sample binary tree\n    void buildSampleTree() {\n        root = new BinaryTreeNode<int>(1);\n        \n        root->left = new BinaryTreeNode<int>(2);\n        root->right = new BinaryTreeNode<int>(3);\n        \n        root->left->left = new BinaryTreeNode<int>(4);\n        root->left->right = new BinaryTreeNode<int>(5);\n        \n        root->right->left = new BinaryTreeNode<int>(6);\n        root->right->right = new BinaryTreeNode<int>(7);\n        \n        root->left->left->left = new BinaryTreeNode<int>(8);\n        root->left->left->right = new BinaryTreeNode<int>(9);\n    }\n    \n    // Level Order Traversal (BFS)\n    void levelOrderTraversal() {\n        if(!root) return;\n        \n        queue<BinaryTreeNode<T>*> q;\n        q.push(root);\n        \n        cout << "Level Order Traversal: ";\n        \n        while(!q.empty()) {\n            BinaryTreeNode<T>* current = q.front();\n            q.pop();\n            \n            cout << current->data << " ";\n            \n            if(current->left) q.push(current->left);\n            if(current->right) q.push(current->right);\n        }\n        cout << endl;\n    }\n    \n    // Count total nodes\n    int countNodes() {\n        return countNodesHelper(root);\n    }\n    \n    // Calculate height/depth\n    int getHeight() {\n        return getHeightHelper(root);\n    }\n    \n    // Check if tree is balanced\n    bool isBalanced() {\n        return checkBalanced(root) != -1;\n    }\n    \n    // Find maximum element\n    T findMax() {\n        return findMaxHelper(root);\n    }\n    \n    // Find minimum element\n    T findMin() {\n        return findMinHelper(root);\n    }\n    \n    // Count leaf nodes\n    int countLeaves() {\n        return countLeavesHelper(root);\n    }\n    \n    // Check if two trees are identical\n    bool isIdentical(BinaryTreeNode<T>* tree1, BinaryTreeNode<T>* tree2) {\n        if(!tree1 && !tree2) return true;\n        if(!tree1 || !tree2) return false;\n        \n        return (tree1->data == tree2->data) &&\n               isIdentical(tree1->left, tree2->left) &&\n               isIdentical(tree1->right, tree2->right);\n    }\n    \nprivate:\n    // Helper function to delete tree\n    void deleteTree(BinaryTreeNode<T>* node) {\n        if(!node) return;\n        \n        deleteTree(node->left);\n        deleteTree(node->right);\n        delete node;\n    }\n    \n    int countNodesHelper(BinaryTreeNode<T>* node) {\n        if(!node) return 0;\n        return 1 + countNodesHelper(node->left) + countNodesHelper(node->right);\n    }\n    \n    int getHeightHelper(BinaryTreeNode<T>* node) {\n        if(!node) return 0;\n        return 1 + max(getHeightHelper(node->left), getHeightHelper(node->right));\n    }\n    \n    int checkBalanced(BinaryTreeNode<T>* node) {\n        if(!node) return 0;\n        \n        int leftHeight = checkBalanced(node->left);\n        if(leftHeight == -1) return -1;\n        \n        int rightHeight = checkBalanced(node->right);\n        if(rightHeight == -1) return -1;\n        \n        if(abs(leftHeight - rightHeight) > 1) return -1;\n        \n        return max(leftHeight, rightHeight) + 1;\n    }\n    \n    T findMaxHelper(BinaryTreeNode<T>* node) {\n        if(!node) return INT_MIN;\n        \n        T res = node->data;\n        T lres = findMaxHelper(node->left);\n        T rres = findMaxHelper(node->right);\n        \n        if(lres > res) res = lres;\n        if(rres > res) res = rres;\n        \n        return res;\n    }\n    \n    T findMinHelper(BinaryTreeNode<T>* node) {\n        if(!node) return INT_MAX;\n        \n        T res = node->data;\n        T lres = findMinHelper(node->left);\n        T rres = findMinHelper(node->right);\n        \n        if(lres < res) res = lres;\n        if(rres < res) res = rres;\n        \n        return res;\n    }\n    \n    int countLeavesHelper(BinaryTreeNode<T>* node) {\n        if(!node) return 0;\n        if(node->isLeaf()) return 1;\n        \n        return countLeavesHelper(node->left) + countLeavesHelper(node->right);\n    }\n};\n\nint main() {\n    BinaryTree<int> tree;\n    tree.buildSampleTree();\n    \n    tree.levelOrderTraversal();\n    \n    cout << "Total nodes: " << tree.countNodes() << endl;\n    cout << "Tree height: " << tree.getHeight() << endl;\n    cout << "Is balanced: " << (tree.isBalanced() ? "Yes" : "No") << endl;\n    cout << "Maximum value: " << tree.findMax() << endl;\n    cout << "Minimum value: " << tree.findMin() << endl;\n    cout << "Leaf nodes count: " << tree.countLeaves() << endl;\n    \n    return 0;\n}\n'})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Output:"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{children:"Level Order Traversal: 1 2 3 4 5 6 7 8 9 \nTotal nodes: 9\nTree height: 4\nIs balanced: Yes\nMaximum value: 9\nMinimum value: 1\nLeaf nodes count: 5\n"})}),"\n",(0,o.jsx)(e.hr,{}),"\n",(0,o.jsx)(e.h1,{id:"dsa-tree-traversals---complete-c-guide",children:"DSA Tree Traversals - Complete C++ Guide"}),"\n",(0,o.jsx)(e.h2,{id:"tree-traversal-techniques",children:"Tree Traversal Techniques"}),"\n",(0,o.jsx)(e.p,{children:"Tree traversal is the process of visiting all nodes in a tree exactly once in a specific order. Different traversal methods serve different purposes and are used in various algorithms."}),"\n",(0,o.jsx)(e.h2,{id:"1-pre-order-traversal-root--left--right",children:"1. Pre-order Traversal (Root \u2192 Left \u2192 Right)"}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Pre-order traversal"})," visits nodes in the order: Root, Left subtree, Right subtree. Useful for creating a copy of the tree or prefix expression evaluation."]}),"\n",(0,o.jsx)(e.h3,{id:"algorithm",children:"Algorithm:"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsx)(e.li,{children:"Visit the root node"}),"\n",(0,o.jsx)(e.li,{children:"Traverse the left subtree in pre-order"}),"\n",(0,o.jsx)(e.li,{children:"Traverse the right subtree in pre-order"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"2-in-order-traversal-left--root--right",children:"2. In-order Traversal (Left \u2192 Root \u2192 Right)"}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"In-order traversal"})," visits nodes in the order: Left subtree, Root, Right subtree. For binary search trees, this gives nodes in sorted order."]}),"\n",(0,o.jsx)(e.h3,{id:"algorithm-1",children:"Algorithm:"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsx)(e.li,{children:"Traverse the left subtree in in-order"}),"\n",(0,o.jsx)(e.li,{children:"Visit the root node"}),"\n",(0,o.jsx)(e.li,{children:"Traverse the right subtree in in-order"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"3-post-order-traversal-left--right--root",children:"3. Post-order Traversal (Left \u2192 Right \u2192 Root)"}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Post-order traversal"})," visits nodes in the order: Left subtree, Right subtree, Root. Useful for deleting trees or postfix expression evaluation."]}),"\n",(0,o.jsx)(e.h3,{id:"algorithm-2",children:"Algorithm:"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsx)(e.li,{children:"Traverse the left subtree in post-order"}),"\n",(0,o.jsx)(e.li,{children:"Traverse the right subtree in post-order"}),"\n",(0,o.jsx)(e.li,{children:"Visit the root node"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"complete-implementation-of-all-traversals",children:"Complete Implementation of All Traversals"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <stack>\n#include <queue>\nusing namespace std;\n\n// Binary Tree Node\ntemplate <typename T>\nclass TreeNode {\npublic:\n    T data;\n    TreeNode<T>* left;\n    TreeNode<T>* right;\n    \n    TreeNode(T val) : data(val), left(nullptr), right(nullptr) {}\n};\n\n// Binary Tree Class with All Traversals\ntemplate <typename T>\nclass BinaryTree {\nprivate:\n    TreeNode<T>* root;\n    \npublic:\n    BinaryTree() : root(nullptr) {}\n    \n    void buildSampleTree() {\n        root = new TreeNode<int>(1);\n        root->left = new TreeNode<int>(2);\n        root->right = new TreeNode<int>(3);\n        root->left->left = new TreeNode<int>(4);\n        root->left->right = new TreeNode<int>(5);\n        root->right->left = new TreeNode<int>(6);\n        root->right->right = new TreeNode<int>(7);\n        \n        /* Tree Structure:\n               1\n             /   \\\n            2     3\n           / \\   / \\\n          4   5 6   7\n        */\n    }\n    \n    // ========== RECURSIVE TRAVERSALS ==========\n    \n    // Pre-order Traversal (Recursive)\n    void preOrderRecursive(TreeNode<T>* node) {\n        if(!node) return;\n        \n        cout << node->data << " ";  // Visit root\n        preOrderRecursive(node->left);  // Traverse left\n        preOrderRecursive(node->right); // Traverse right\n    }\n    \n    // In-order Traversal (Recursive)\n    void inOrderRecursive(TreeNode<T>* node) {\n        if(!node) return;\n        \n        inOrderRecursive(node->left);   // Traverse left\n        cout << node->data << " ";      // Visit root\n        inOrderRecursive(node->right);  // Traverse right\n    }\n    \n    // Post-order Traversal (Recursive)\n    void postOrderRecursive(TreeNode<T>* node) {\n        if(!node) return;\n        \n        postOrderRecursive(node->left);  // Traverse left\n        postOrderRecursive(node->right); // Traverse right\n        cout << node->data << " ";       // Visit root\n    }\n    \n    // ========== ITERATIVE TRAVERSALS ==========\n    \n    // Pre-order Traversal (Iterative using stack)\n    void preOrderIterative() {\n        if(!root) return;\n        \n        stack<TreeNode<T>*> s;\n        s.push(root);\n        \n        cout << "Pre-order (Iterative): ";\n        \n        while(!s.empty()) {\n            TreeNode<T>* current = s.top();\n            s.pop();\n            \n            cout << current->data << " ";\n            \n            // Push right first, then left (so left is processed first)\n            if(current->right) s.push(current->right);\n            if(current->left) s.push(current->left);\n        }\n        cout << endl;\n    }\n    \n    // In-order Traversal (Iterative using stack)\n    void inOrderIterative() {\n        stack<TreeNode<T>*> s;\n        TreeNode<T>* current = root;\n        \n        cout << "In-order (Iterative): ";\n        \n        while(current || !s.empty()) {\n            // Reach the leftmost node\n            while(current) {\n                s.push(current);\n                current = current->left;\n            }\n            \n            // Current must be nullptr at this point\n            current = s.top();\n            s.pop();\n            \n            cout << current->data << " ";\n            \n            // Now visit the right subtree\n            current = current->right;\n        }\n        cout << endl;\n    }\n    \n    // Post-order Traversal (Iterative using two stacks)\n    void postOrderIterative() {\n        if(!root) return;\n        \n        stack<TreeNode<T>*> s1, s2;\n        s1.push(root);\n        \n        cout << "Post-order (Iterative): ";\n        \n        while(!s1.empty()) {\n            TreeNode<T>* current = s1.top();\n            s1.pop();\n            s2.push(current);\n            \n            if(current->left) s1.push(current->left);\n            if(current->right) s1.push(current->right);\n        }\n        \n        while(!s2.empty()) {\n            cout << s2.top()->data << " ";\n            s2.pop();\n        }\n        cout << endl;\n    }\n    \n    // Post-order Traversal (Iterative using one stack)\n    void postOrderIterativeOneStack() {\n        if(!root) return;\n        \n        stack<TreeNode<T>*> s;\n        TreeNode<T>* current = root;\n        TreeNode<T>* lastVisited = nullptr;\n        \n        cout << "Post-order (One Stack): ";\n        \n        while(current || !s.empty()) {\n            if(current) {\n                s.push(current);\n                current = current->left;\n            } else {\n                TreeNode<T>* peekNode = s.top();\n                \n                // If right child exists and not processed yet\n                if(peekNode->right && lastVisited != peekNode->right) {\n                    current = peekNode->right;\n                } else {\n                    cout << peekNode->data << " ";\n                    lastVisited = peekNode;\n                    s.pop();\n                }\n            }\n        }\n        cout << endl;\n    }\n    \n    // ========== LEVEL ORDER TRAVERSAL ==========\n    \n    void levelOrderTraversal() {\n        if(!root) return;\n        \n        queue<TreeNode<T>*> q;\n        q.push(root);\n        \n        cout << "Level Order: ";\n        \n        while(!q.empty()) {\n            int levelSize = q.size();\n            \n            for(int i = 0; i < levelSize; i++) {\n                TreeNode<T>* current = q.front();\n                q.pop();\n                \n                cout << current->data << " ";\n                \n                if(current->left) q.push(current->left);\n                if(current->right) q.push(current->right);\n            }\n        }\n        cout << endl;\n    }\n    \n    // ========== MORRIS TRAVERSALS (O(1) Space) ==========\n    \n    // Morris In-order Traversal (Threaded Binary Tree)\n    void morrisInOrderTraversal() {\n        TreeNode<T>* current = root;\n        \n        cout << "Morris In-order: ";\n        \n        while(current) {\n            if(!current->left) {\n                cout << current->data << " ";\n                current = current->right;\n            } else {\n                // Find inorder predecessor\n                TreeNode<T>* predecessor = current->left;\n                while(predecessor->right && predecessor->right != current) {\n                    predecessor = predecessor->right;\n                }\n                \n                if(!predecessor->right) {\n                    // Create thread\n                    predecessor->right = current;\n                    current = current->left;\n                } else {\n                    // Remove thread\n                    predecessor->right = nullptr;\n                    cout << current->data << " ";\n                    current = current->right;\n                }\n            }\n        }\n        cout << endl;\n    }\n    \n    // Morris Pre-order Traversal\n    void morrisPreOrderTraversal() {\n        TreeNode<T>* current = root;\n        \n        cout << "Morris Pre-order: ";\n        \n        while(current) {\n            if(!current->left) {\n                cout << current->data << " ";\n                current = current->right;\n            } else {\n                TreeNode<T>* predecessor = current->left;\n                while(predecessor->right && predecessor->right != current) {\n                    predecessor = predecessor->right;\n                }\n                \n                if(!predecessor->right) {\n                    cout << current->data << " ";\n                    predecessor->right = current;\n                    current = current->left;\n                } else {\n                    predecessor->right = nullptr;\n                    current = current->right;\n                }\n            }\n        }\n        cout << endl;\n    }\n    \n    // ========== TRAVERSAL DEMONSTRATION ==========\n    \n    void demonstrateAllTraversals() {\n        cout << "\\n=== BINARY TREE TRAVERSALS DEMONSTRATION ===\\n" << endl;\n        \n        // Build sample tree\n        buildSampleTree();\n        \n        cout << "Tree Structure:" << endl;\n        cout << "       1" << endl;\n        cout << "     /   \\\\" << endl;\n        cout << "    2     3" << endl;\n        cout << "   / \\\\   / \\\\" << endl;\n        cout << "  4   5 6   7\\n" << endl;\n        \n        cout << "RECURSIVE TRAVERSALS:" << endl;\n        cout << "Pre-order:  ";\n        preOrderRecursive(root);\n        cout << endl;\n        \n        cout << "In-order:   ";\n        inOrderRecursive(root);\n        cout << endl;\n        \n        cout << "Post-order: ";\n        postOrderRecursive(root);\n        cout << endl;\n        \n        cout << "\\nITERATIVE TRAVERSALS:" << endl;\n        preOrderIterative();\n        inOrderIterative();\n        postOrderIterative();\n        postOrderIterativeOneStack();\n        \n        cout << "\\nOTHER TRAVERSALS:" << endl;\n        levelOrderTraversal();\n        morrisInOrderTraversal();\n        morrisPreOrderTraversal();\n    }\n    \n    // Get root node\n    TreeNode<T>* getRoot() { return root; }\n};\n\n// Application: Expression Tree Evaluation\nclass ExpressionTree {\nprivate:\n    struct Node {\n        string value;\n        Node* left;\n        Node* right;\n        \n        Node(string val) : value(val), left(nullptr), right(nullptr) {}\n    };\n    \n    Node* root;\n    \n    bool isOperator(string s) {\n        return s == "+" || s == "-" || s == "*" || s == "/";\n    }\n    \n    int toInt(string s) {\n        return stoi(s);\n    }\n    \n    int evaluate(Node* node) {\n        if(!node) return 0;\n        \n        // If leaf node (operand)\n        if(!node->left && !node->right) {\n            return toInt(node->value);\n        }\n        \n        // Evaluate left and right subtrees\n        int leftVal = evaluate(node->left);\n        int rightVal = evaluate(node->right);\n        \n        // Apply operator\n        if(node->value == "+") return leftVal + rightVal;\n        if(node->value == "-") return leftVal - rightVal;\n        if(node->value == "*") return leftVal * rightVal;\n        if(node->value == "/") return leftVal / rightVal;\n        \n        return 0;\n    }\n    \npublic:\n    ExpressionTree() : root(nullptr) {}\n    \n    // Build expression tree from postfix expression\n    void buildFromPostfix(vector<string> postfix) {\n        stack<Node*> s;\n        \n        for(string token : postfix) {\n            Node* newNode = new Node(token);\n            \n            if(isOperator(token)) {\n                // Pop two operands for operator\n                newNode->right = s.top(); s.pop();\n                newNode->left = s.top(); s.pop();\n            }\n            \n            s.push(newNode);\n        }\n        \n        root = s.top();\n    }\n    \n    void traverseAndEvaluate() {\n        if(!root) return;\n        \n        cout << "\\n=== EXPRESSION TREE DEMONSTRATION ===\\n" << endl;\n        cout << "In-order traversal (Infix): ";\n        inOrderTraversal(root);\n        cout << endl;\n        \n        cout << "Pre-order traversal (Prefix): ";\n        preOrderTraversal(root);\n        cout << endl;\n        \n        cout << "Post-order traversal (Postfix): ";\n        postOrderTraversal(root);\n        cout << endl;\n        \n        cout << "Evaluation result: " << evaluate(root) << endl;\n    }\n    \nprivate:\n    void inOrderTraversal(Node* node) {\n        if(!node) return;\n        \n        if(node->left || node->right) cout << "(";\n        inOrderTraversal(node->left);\n        cout << node->value << " ";\n        inOrderTraversal(node->right);\n        if(node->left || node->right) cout << ")";\n    }\n    \n    void preOrderTraversal(Node* node) {\n        if(!node) return;\n        \n        cout << node->value << " ";\n        preOrderTraversal(node->left);\n        preOrderTraversal(node->right);\n    }\n    \n    void postOrderTraversal(Node* node) {\n        if(!node) return;\n        \n        postOrderTraversal(node->left);\n        postOrderTraversal(node->right);\n        cout << node->value << " ";\n    }\n};\n\nint main() {\n    // Part 1: Binary Tree Traversals\n    BinaryTree<int> tree;\n    tree.demonstrateAllTraversals();\n    \n    // Part 2: Expression Tree\n    ExpressionTree exprTree;\n    vector<string> postfix = {"4", "5", "+", "3", "*", "2", "-"};\n    exprTree.buildFromPostfix(postfix);\n    exprTree.traverseAndEvaluate();\n    \n    return 0;\n}\n'})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Output:"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{children:"=== BINARY TREE TRAVERSALS DEMONSTRATION ===\n\nTree Structure:\n       1\n     /   \\\n    2     3\n   / \\   / \\\n  4   5 6   7\n\nRECURSIVE TRAVERSALS:\nPre-order:  1 2 4 5 3 6 7 \nIn-order:   4 2 5 1 6 3 7 \nPost-order: 4 5 2 6 7 3 1 \n\nITERATIVE TRAVERSALS:\nPre-order (Iterative): 1 2 4 5 3 6 7 \nIn-order (Iterative): 4 2 5 1 6 3 7 \nPost-order (Iterative): 4 5 2 6 7 3 1 \nPost-order (One Stack): 4 5 2 6 7 3 1 \n\nOTHER TRAVERSALS:\nLevel Order: 1 2 3 4 5 6 7 \nMorris In-order: 4 2 5 1 6 3 7 \nMorris Pre-order: 1 2 4 5 3 6 7 \n\n=== EXPRESSION TREE DEMONSTRATION ===\n\nIn-order traversal (Infix): ( ( 4 + 5 ) * 3 ) - 2 \nPre-order traversal (Prefix): - * + 4 5 3 2 \nPost-order traversal (Postfix): 4 5 + 3 * 2 - \nEvaluation result: 25\n"})}),"\n",(0,o.jsx)(e.hr,{}),"\n",(0,o.jsx)(e.h1,{id:"dsa-array-implementation-of-trees---complete-c-guide",children:"DSA Array Implementation of Trees - Complete C++ Guide"}),"\n",(0,o.jsx)(e.h2,{id:"array-representation-of-binary-trees",children:"Array Representation of Binary Trees"}),"\n",(0,o.jsxs)(e.p,{children:["Trees can be efficiently stored in arrays, particularly for ",(0,o.jsx)(e.strong,{children:"complete binary trees"}),". Array representation saves memory overhead of pointers and provides cache-friendly access patterns."]}),"\n",(0,o.jsx)(e.h3,{id:"indexing-formulas-for-0-based-array",children:"Indexing Formulas (for 0-based array):"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Root"}),": index 0"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Left child of node at index i"}),": ",(0,o.jsx)(e.code,{children:"2*i + 1"})]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Right child of node at index i"}),": ",(0,o.jsx)(e.code,{children:"2*i + 2"})]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Parent of node at index i"}),": ",(0,o.jsx)(e.code,{children:"(i-1)/2"})]}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"advantages",children:"Advantages:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Memory efficient (no pointer overhead)"}),"\n",(0,o.jsx)(e.li,{children:"Cache-friendly (contiguous memory)"}),"\n",(0,o.jsx)(e.li,{children:"Easy to implement heap data structures"}),"\n",(0,o.jsx)(e.li,{children:"Simple parent-child navigation"}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"disadvantages",children:"Disadvantages:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Wasted space for non-complete trees"}),"\n",(0,o.jsx)(e.li,{children:"Difficult to insert/delete nodes"}),"\n",(0,o.jsx)(e.li,{children:"Fixed size (static arrays)"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"complete-implementation",children:"Complete Implementation"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <vector>\n#include <queue>\n#include <cmath>\nusing namespace std;\n\n// Array-based Binary Tree\nclass ArrayBinaryTree {\nprivate:\n    vector<int> tree;\n    int capacity;\n    int size;\n    \npublic:\n    ArrayBinaryTree(int maxSize) : capacity(maxSize), size(0) {\n        tree.resize(capacity, -1); // -1 represents empty node\n    }\n    \n    // Insert element (level order insertion)\n    bool insert(int value) {\n        if(size >= capacity) {\n            cout << "Tree is full!" << endl;\n            return false;\n        }\n        \n        tree[size] = value;\n        size++;\n        return true;\n    }\n    \n    // Get root value\n    int getRoot() {\n        if(size == 0) {\n            cout << "Tree is empty!" << endl;\n            return -1;\n        }\n        return tree[0];\n    }\n    \n    // Get left child\n    int getLeftChild(int parentIndex) {\n        int leftIndex = 2 * parentIndex + 1;\n        if(leftIndex >= size || tree[leftIndex] == -1) {\n            return -1;\n        }\n        return tree[leftIndex];\n    }\n    \n    // Get right child\n    int getRightChild(int parentIndex) {\n        int rightIndex = 2 * parentIndex + 2;\n        if(rightIndex >= size || tree[rightIndex] == -1) {\n            return -1;\n        }\n        return tree[rightIndex];\n    }\n    \n    // Get parent\n    int getParent(int childIndex) {\n        if(childIndex == 0) {\n            cout << "Root has no parent!" << endl;\n            return -1;\n        }\n        int parentIndex = (childIndex - 1) / 2;\n        return tree[parentIndex];\n    }\n    \n    // Check if node is leaf\n    bool isLeaf(int index) {\n        if(index >= size) return false;\n        \n        int leftIndex = 2 * index + 1;\n        int rightIndex = 2 * index + 2;\n        \n        // Check if both children are empty or out of bounds\n        bool leftEmpty = (leftIndex >= size || tree[leftIndex] == -1);\n        bool rightEmpty = (rightIndex >= size || tree[rightIndex] == -1);\n        \n        return leftEmpty && rightEmpty;\n    }\n    \n    // Get height of tree\n    int getHeight() {\n        if(size == 0) return 0;\n        return (int)log2(size) + 1;\n    }\n    \n    // Level order traversal\n    void levelOrderTraversal() {\n        if(size == 0) {\n            cout << "Tree is empty!" << endl;\n            return;\n        }\n        \n        cout << "Level Order Traversal: ";\n        for(int i = 0; i < size; i++) {\n            if(tree[i] != -1) {\n                cout << tree[i] << " ";\n            }\n        }\n        cout << endl;\n    }\n    \n    // Pre-order traversal (recursive using array indices)\n    void preOrderTraversal(int index = 0) {\n        if(index >= size || tree[index] == -1) return;\n        \n        cout << tree[index] << " ";\n        preOrderTraversal(2 * index + 1);\n        preOrderTraversal(2 * index + 2);\n    }\n    \n    // In-order traversal (recursive)\n    void inOrderTraversal(int index = 0) {\n        if(index >= size || tree[index] == -1) return;\n        \n        inOrderTraversal(2 * index + 1);\n        cout << tree[index] << " ";\n        inOrderTraversal(2 * index + 2);\n    }\n    \n    // Post-order traversal (recursive)\n    void postOrderTraversal(int index = 0) {\n        if(index >= size || tree[index] == -1) return;\n        \n        postOrderTraversal(2 * index + 1);\n        postOrderTraversal(2 * index + 2);\n        cout << tree[index] << " ";\n    }\n    \n    // Build sample complete binary tree\n    void buildSampleTree() {\n        int values[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n        for(int val : values) {\n            insert(val);\n        }\n    }\n    \n    // Display tree structure\n    void displayTree() {\n        cout << "\\n=== ARRAY-BASED BINARY TREE ===\\n" << endl;\n        \n        if(size == 0) {\n            cout << "Tree is empty!" << endl;\n            return;\n        }\n        \n        cout << "Array representation: ";\n        for(int i = 0; i < size; i++) {\n            cout << "[" << i << "]:" << tree[i] << " ";\n        }\n        cout << endl;\n        \n        cout << "\\nTree Structure:" << endl;\n        displayTreeHelper(0, 0);\n        \n        cout << "\\nTraversals:" << endl;\n        cout << "Pre-order:  ";\n        preOrderTraversal();\n        cout << endl;\n        \n        cout << "In-order:   ";\n        inOrderTraversal();\n        cout << endl;\n        \n        cout << "Post-order: ";\n        postOrderTraversal();\n        cout << endl;\n        \n        cout << "\\nTree Properties:" << endl;\n        cout << "Height: " << getHeight() << endl;\n        cout << "Size: " << size << endl;\n        cout << "Root: " << getRoot() << endl;\n        \n        // Demonstrate parent-child relationships\n        cout << "\\nParent-Child Relationships:" << endl;\n        for(int i = 0; i < size; i++) {\n            if(tree[i] != -1) {\n                cout << "Node " << tree[i] << " (index " << i << "): ";\n                cout << "Parent = ";\n                if(i == 0) cout << "None";\n                else cout << getParent(i);\n                \n                cout << ", Left = " << getLeftChild(i);\n                cout << ", Right = " << getRightChild(i);\n                cout << ", Is Leaf = " << (isLeaf(i) ? "Yes" : "No");\n                cout << endl;\n            }\n        }\n    }\n    \nprivate:\n    void displayTreeHelper(int index, int level) {\n        if(index >= size || tree[index] == -1) return;\n        \n        // Print right child first (for proper visualization)\n        int rightIndex = 2 * index + 2;\n        if(rightIndex < size && tree[rightIndex] != -1) {\n            displayTreeHelper(rightIndex, level + 1);\n        }\n        \n        // Print current node\n        for(int i = 0; i < level; i++) cout << "    ";\n        cout << tree[index] << endl;\n        \n        // Print left child\n        int leftIndex = 2 * index + 1;\n        if(leftIndex < size && tree[leftIndex] != -1) {\n            displayTreeHelper(leftIndex, level + 1);\n        }\n    }\n};\n\n// Heap Implementation using Array-based Tree\nclass MaxHeap {\nprivate:\n    vector<int> heap;\n    \n    void heapifyUp(int index) {\n        if(index == 0) return;\n        \n        int parentIndex = (index - 1) / 2;\n        if(heap[index] > heap[parentIndex]) {\n            swap(heap[index], heap[parentIndex]);\n            heapifyUp(parentIndex);\n        }\n    }\n    \n    void heapifyDown(int index) {\n        int largest = index;\n        int leftChild = 2 * index + 1;\n        int rightChild = 2 * index + 2;\n        \n        if(leftChild < heap.size() && heap[leftChild] > heap[largest]) {\n            largest = leftChild;\n        }\n        \n        if(rightChild < heap.size() && heap[rightChild] > heap[largest]) {\n            largest = rightChild;\n        }\n        \n        if(largest != index) {\n            swap(heap[index], heap[largest]);\n            heapifyDown(largest);\n        }\n    }\n    \npublic:\n    void insert(int value) {\n        heap.push_back(value);\n        heapifyUp(heap.size() - 1);\n    }\n    \n    int extractMax() {\n        if(heap.empty()) {\n            cout << "Heap is empty!" << endl;\n            return -1;\n        }\n        \n        int maxValue = heap[0];\n        heap[0] = heap.back();\n        heap.pop_back();\n        \n        if(!heap.empty()) {\n            heapifyDown(0);\n        }\n        \n        return maxValue;\n    }\n    \n    int getMax() {\n        if(heap.empty()) {\n            cout << "Heap is empty!" << endl;\n            return -1;\n        }\n        return heap[0];\n    }\n    \n    void display() {\n        cout << "\\n=== MAX HEAP IMPLEMENTATION ===\\n" << endl;\n        cout << "Heap array: ";\n        for(int val : heap) {\n            cout << val << " ";\n        }\n        cout << endl;\n        \n        cout << "Heap structure:" << endl;\n        if(heap.empty()) {\n            cout << "Empty heap!" << endl;\n            return;\n        }\n        \n        // Display as tree\n        int height = (int)log2(heap.size()) + 1;\n        int index = 0;\n        \n        for(int level = 0; level < height; level++) {\n            int nodesInLevel = (1 << level);\n            int spaces = (1 << (height - level)) - 1;\n            \n            // Print leading spaces\n            for(int i = 0; i < spaces/2; i++) cout << " ";\n            \n            for(int i = 0; i < nodesInLevel && index < heap.size(); i++) {\n                cout << heap[index++];\n                for(int j = 0; j < spaces; j++) cout << " ";\n            }\n            cout << endl;\n        }\n    }\n};\n\nint main() {\n    // Part 1: Array-based Binary Tree\n    cout << "PART 1: ARRAY-BASED BINARY TREE" << endl;\n    cout << "=================================" << endl;\n    \n    ArrayBinaryTree tree(20);\n    tree.buildSampleTree();\n    tree.displayTree();\n    \n    // Part 2: Heap Implementation\n    cout << "\\n\\nPART 2: HEAP IMPLEMENTATION" << endl;\n    cout << "=============================" << endl;\n    \n    MaxHeap heap;\n    \n    // Insert values\n    vector<int> values = {10, 20, 15, 30, 40, 5, 25};\n    cout << "Inserting values: ";\n    for(int val : values) {\n        cout << val << " ";\n        heap.insert(val);\n    }\n    cout << endl;\n    \n    heap.display();\n    \n    cout << "\\nExtracting max elements:" << endl;\n    while(true) {\n        int maxVal = heap.extractMax();\n        if(maxVal == -1) break;\n        cout << "Extracted: " << maxVal << endl;\n        heap.display();\n        if(heap.getMax() == -1) break;\n    }\n    \n    return 0;\n}\n'})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Output:"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{children:"PART 1: ARRAY-BASED BINARY TREE\n=================================\n\n=== ARRAY-BASED BINARY TREE ===\n\nArray representation: [0]:1 [1]:2 [2]:3 [3]:4 [4]:5 [5]:6 [6]:7 [7]:8 [8]:9 [9]:10 \n\nTree Structure:\n        10\n    9\n        7\n6\n        5\n    3\n        4\n1\n        8\n    2\n\nTraversals:\nPre-order:  1 2 4 8 5 9 10 3 6 7 \nIn-order:   8 4 2 9 5 10 1 6 3 7 \nPost-order: 8 4 9 10 5 2 6 7 3 1 \n\nTree Properties:\nHeight: 4\nSize: 10\nRoot: 1\n\nParent-Child Relationships:\nNode 1 (index 0): Parent = None, Left = 2, Right = 3, Is Leaf = No\nNode 2 (index 1): Parent = 1, Left = 4, Right = 5, Is Leaf = No\nNode 3 (index 2): Parent = 1, Left = 6, Right = 7, Is Leaf = No\nNode 4 (index 3): Parent = 2, Left = 8, Right = -1, Is Leaf = No\nNode 5 (index 4): Parent = 2, Left = 9, Right = 10, Is Leaf = No\nNode 6 (index 5): Parent = 3, Left = -1, Right = -1, Is Leaf = Yes\nNode 7 (index 6): Parent = 3, Left = -1, Right = -1, Is Leaf = Yes\nNode 8 (index 7): Parent = 4, Left = -1, Right = -1, Is Leaf = Yes\nNode 9 (index 8): Parent = 5, Left = -1, Right = -1, Is Leaf = Yes\nNode 10 (index 9): Parent = 5, Left = -1, Right = -1, Is Leaf = Yes\n\n\nPART 2: HEAP IMPLEMENTATION\n=============================\nInserting values: 10 20 15 30 40 5 25 \n\n=== MAX HEAP IMPLEMENTATION ===\n\nHeap array: 40 30 25 10 20 5 15 \nHeap structure:\n       40\n   30      25\n 10  20   5  15\n\nExtracting max elements:\nExtracted: 40\n\n=== MAX HEAP IMPLEMENTATION ===\n\nHeap array: 30 20 25 10 15 5 \nHeap structure:\n       30\n   20      25\n 10  15   5\n"})}),"\n",(0,o.jsx)(e.hr,{}),"\n",(0,o.jsx)(e.h1,{id:"dsa-binary-search-trees-bst---complete-c-guide",children:"DSA Binary Search Trees (BST) - Complete C++ Guide"}),"\n",(0,o.jsx)(e.h2,{id:"introduction-to-binary-search-trees",children:"Introduction to Binary Search Trees"}),"\n",(0,o.jsxs)(e.p,{children:["A ",(0,o.jsx)(e.strong,{children:"Binary Search Tree (BST)"})," is a binary tree with the following properties:"]}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsx)(e.li,{children:"The left subtree contains only nodes with values less than the node's value"}),"\n",(0,o.jsx)(e.li,{children:"The right subtree contains only nodes with values greater than the node's value"}),"\n",(0,o.jsx)(e.li,{children:"Both left and right subtrees are also binary search trees"}),"\n",(0,o.jsx)(e.li,{children:"No duplicate values (typically)"}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"key-characteristics-2",children:"Key Characteristics:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Search"}),": O(h) time, where h is height (O(log n) in balanced BST)"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Insertion"}),": O(h) time"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Deletion"}),": O(h) time"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"In-order traversal"}),": Returns elements in sorted order"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Memory"}),": O(n) space"]}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"complete-bst-implementation",children:"Complete BST Implementation"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <queue>\n#include <stack>\n#include <climits>\nusing namespace std;\n\n// BST Node\nclass BSTNode {\npublic:\n    int data;\n    BSTNode* left;\n    BSTNode* right;\n    \n    BSTNode(int val) : data(val), left(nullptr), right(nullptr) {}\n    \n    // Check if leaf node\n    bool isLeaf() {\n        return (left == nullptr && right == nullptr);\n    }\n};\n\n// Binary Search Tree Class\nclass BinarySearchTree {\nprivate:\n    BSTNode* root;\n    int size;\n    \npublic:\n    BinarySearchTree() : root(nullptr), size(0) {}\n    \n    ~BinarySearchTree() {\n        clear(root);\n    }\n    \n    // ========== BASIC OPERATIONS ==========\n    \n    // Insert a value (iterative)\n    void insert(int value) {\n        BSTNode* newNode = new BSTNode(value);\n        \n        if(root == nullptr) {\n            root = newNode;\n            size++;\n            return;\n        }\n        \n        BSTNode* current = root;\n        BSTNode* parent = nullptr;\n        \n        while(current != nullptr) {\n            parent = current;\n            \n            if(value < current->data) {\n                current = current->left;\n            } else if(value > current->data) {\n                current = current->right;\n            } else {\n                // Duplicate value (handle as needed)\n                cout << "Value " << value << " already exists in BST!" << endl;\n                delete newNode;\n                return;\n            }\n        }\n        \n        if(value < parent->data) {\n            parent->left = newNode;\n        } else {\n            parent->right = newNode;\n        }\n        \n        size++;\n    }\n    \n    // Insert a value (recursive)\n    BSTNode* insertRecursive(BSTNode* node, int value) {\n        if(node == nullptr) {\n            size++;\n            return new BSTNode(value);\n        }\n        \n        if(value < node->data) {\n            node->left = insertRecursive(node->left, value);\n        } else if(value > node->data) {\n            node->right = insertRecursive(node->right, value);\n        }\n        \n        return node;\n    }\n    \n    void insertRec(int value) {\n        root = insertRecursive(root, value);\n    }\n    \n    // Search for a value (iterative)\n    bool search(int value) {\n        BSTNode* current = root;\n        \n        while(current != nullptr) {\n            if(value == current->data) {\n                return true;\n            } else if(value < current->data) {\n                current = current->left;\n            } else {\n                current = current->right;\n            }\n        }\n        \n        return false;\n    }\n    \n    // Search for a value (recursive)\n    bool searchRecursive(BSTNode* node, int value) {\n        if(node == nullptr) return false;\n        \n        if(value == node->data) return true;\n        \n        if(value < node->data) {\n            return searchRecursive(node->left, value);\n        } else {\n            return searchRecursive(node->right, value);\n        }\n    }\n    \n    bool searchRec(int value) {\n        return searchRecursive(root, value);\n    }\n    \n    // ========== DELETION OPERATIONS ==========\n    \n    // Delete a node\n    void deleteNode(int value) {\n        root = deleteRecursive(root, value);\n    }\n    \n    BSTNode* deleteRecursive(BSTNode* node, int value) {\n        if(node == nullptr) return nullptr;\n        \n        if(value < node->data) {\n            node->left = deleteRecursive(node->left, value);\n        } else if(value > node->data) {\n            node->right = deleteRecursive(node->right, value);\n        } else {\n            // Node found, handle three cases\n            \n            // Case 1: Node has no children (leaf node)\n            if(node->isLeaf()) {\n                delete node;\n                size--;\n                return nullptr;\n            }\n            \n            // Case 2: Node has one child\n            if(node->left == nullptr) {\n                BSTNode* temp = node->right;\n                delete node;\n                size--;\n                return temp;\n            } else if(node->right == nullptr) {\n                BSTNode* temp = node->left;\n                delete node;\n                size--;\n                return temp;\n            }\n            \n            // Case 3: Node has two children\n            // Find inorder successor (smallest in right subtree)\n            BSTNode* successor = findMin(node->right);\n            node->data = successor->data;\n            node->right = deleteRecursive(node->right, successor->data);\n        }\n        \n        return node;\n    }\n    \n    // ========== TREE PROPERTIES ==========\n    \n    // Find minimum value\n    int findMin() {\n        if(root == nullptr) {\n            cout << "Tree is empty!" << endl;\n            return INT_MIN;\n        }\n        \n        BSTNode* current = root;\n        while(current->left != nullptr) {\n            current = current->left;\n        }\n        \n        return current->data;\n    }\n    \n    BSTNode* findMin(BSTNode* node) {\n        while(node && node->left != nullptr) {\n            node = node->left;\n        }\n        return node;\n    }\n    \n    // Find maximum value\n    int findMax() {\n        if(root == nullptr) {\n            cout << "Tree is empty!" << endl;\n            return INT_MAX;\n        }\n        \n        BSTNode* current = root;\n        while(current->right != nullptr) {\n            current = current->right;\n        }\n        \n        return current->data;\n    }\n    \n    BSTNode* findMax(BSTNode* node) {\n        while(node && node->right != nullptr) {\n            node = node->right;\n        }\n        return node;\n    }\n    \n    // Get height\n    int getHeight() {\n        return height(root);\n    }\n    \n    int height(BSTNode* node) {\n        if(node == nullptr) return 0;\n        return 1 + max(height(node->left), height(node->right));\n    }\n    \n    // Check if BST is balanced\n    bool isBalanced() {\n        return checkBalanced(root) != -1;\n    }\n    \n    int checkBalanced(BSTNode* node) {\n        if(node == nullptr) return 0;\n        \n        int leftHeight = checkBalanced(node->left);\n        if(leftHeight == -1) return -1;\n        \n        int rightHeight = checkBalanced(node->right);\n        if(rightHeight == -1) return -1;\n        \n        if(abs(leftHeight - rightHeight) > 1) return -1;\n        \n        return max(leftHeight, rightHeight) + 1;\n    }\n    \n    // ========== TRAVERSALS ==========\n    \n    void inOrder() {\n        cout << "In-order (Sorted): ";\n        inOrderRecursive(root);\n        cout << endl;\n    }\n    \n    void inOrderRecursive(BSTNode* node) {\n        if(node == nullptr) return;\n        \n        inOrderRecursive(node->left);\n        cout << node->data << " ";\n        inOrderRecursive(node->right);\n    }\n    \n    void preOrder() {\n        cout << "Pre-order: ";\n        preOrderRecursive(root);\n        cout << endl;\n    }\n    \n    void preOrderRecursive(BSTNode* node) {\n        if(node == nullptr) return;\n        \n        cout << node->data << " ";\n        preOrderRecursive(node->left);\n        preOrderRecursive(node->right);\n    }\n    \n    void postOrder() {\n        cout << "Post-order: ";\n        postOrderRecursive(root);\n        cout << endl;\n    }\n    \n    void postOrderRecursive(BSTNode* node) {\n        if(node == nullptr) return;\n        \n        postOrderRecursive(node->left);\n        postOrderRecursive(node->right);\n        cout << node->data << " ";\n    }\n    \n    void levelOrder() {\n        if(root == nullptr) return;\n        \n        queue<BSTNode*> q;\n        q.push(root);\n        \n        cout << "Level Order: ";\n        \n        while(!q.empty()) {\n            BSTNode* current = q.front();\n            q.pop();\n            \n            cout << current->data << " ";\n            \n            if(current->left) q.push(current->left);\n            if(current->right) q.push(current->right);\n        }\n        cout << endl;\n    }\n    \n    // ========== BST SPECIFIC OPERATIONS ==========\n    \n    // Find kth smallest element\n    int kthSmallest(int k) {\n        if(k <= 0 || k > size) {\n            cout << "Invalid k value!" << endl;\n            return -1;\n        }\n        \n        int count = 0;\n        int result = -1;\n        kthSmallestHelper(root, k, count, result);\n        return result;\n    }\n    \n    void kthSmallestHelper(BSTNode* node, int k, int& count, int& result) {\n        if(node == nullptr || count >= k) return;\n        \n        kthSmallestHelper(node->left, k, count, result);\n        \n        count++;\n        if(count == k) {\n            result = node->data;\n            return;\n        }\n        \n        kthSmallestHelper(node->right, k, count, result);\n    }\n    \n    // Find kth largest element\n    int kthLargest(int k) {\n        if(k <= 0 || k > size) {\n            cout << "Invalid k value!" << endl;\n            return -1;\n        }\n        \n        int count = 0;\n        int result = -1;\n        kthLargestHelper(root, k, count, result);\n        return result;\n    }\n    \n    void kthLargestHelper(BSTNode* node, int k, int& count, int& result) {\n        if(node == nullptr || count >= k) return;\n        \n        kthLargestHelper(node->right, k, count, result);\n        \n        count++;\n        if(count == k) {\n            result = node->data;\n            return;\n        }\n        \n        kthLargestHelper(node->left, k, count, result);\n    }\n    \n    // Check if tree is valid BST\n    bool isValidBST() {\n        return isBSTUtil(root, INT_MIN, INT_MAX);\n    }\n    \n    bool isBSTUtil(BSTNode* node, int minVal, int maxVal) {\n        if(node == nullptr) return true;\n        \n        if(node->data <= minVal || node->data >= maxVal) {\n            return false;\n        }\n        \n        return isBSTUtil(node->left, minVal, node->data) &&\n               isBSTUtil(node->right, node->data, maxVal);\n    }\n    \n    // Find lowest common ancestor (LCA)\n    int findLCA(int n1, int n2) {\n        BSTNode* lca = findLCAUtil(root, n1, n2);\n        if(lca != nullptr) {\n            return lca->data;\n        }\n        return -1;\n    }\n    \n    BSTNode* findLCAUtil(BSTNode* node, int n1, int n2) {\n        if(node == nullptr) return nullptr;\n        \n        // If both n1 and n2 are smaller than root, LCA lies in left\n        if(n1 < node->data && n2 < node->data) {\n            return findLCAUtil(node->left, n1, n2);\n        }\n        \n        // If both n1 and n2 are greater than root, LCA lies in right\n        if(n1 > node->data && n2 > node->data) {\n            return findLCAUtil(node->right, n1, n2);\n        }\n        \n        // If one is on left and other on right, this is LCA\n        return node;\n    }\n    \n    // Convert BST to sorted array\n    vector<int> toSortedArray() {\n        vector<int> result;\n        inorderToVector(root, result);\n        return result;\n    }\n    \n    void inorderToVector(BSTNode* node, vector<int>& result) {\n        if(node == nullptr) return;\n        \n        inorderToVector(node->left, result);\n        result.push_back(node->data);\n        inorderToVector(node->right, result);\n    }\n    \n    // Build balanced BST from sorted array\n    void buildBalancedBST(const vector<int>& sortedArray) {\n        clear(root);\n        root = sortedArrayToBST(sortedArray, 0, sortedArray.size() - 1);\n        size = sortedArray.size();\n    }\n    \n    BSTNode* sortedArrayToBST(const vector<int>& arr, int start, int end) {\n        if(start > end) return nullptr;\n        \n        int mid = start + (end - start) / 2;\n        BSTNode* node = new BSTNode(arr[mid]);\n        \n        node->left = sortedArrayToBST(arr, start, mid - 1);\n        node->right = sortedArrayToBST(arr, mid + 1, end);\n        \n        return node;\n    }\n    \n    // ========== UTILITY FUNCTIONS ==========\n    \n    void clear(BSTNode* node) {\n        if(node == nullptr) return;\n        \n        clear(node->left);\n        clear(node->right);\n        delete node;\n    }\n    \n    int getSize() {\n        return size;\n    }\n    \n    bool isEmpty() {\n        return size == 0;\n    }\n    \n    // Display tree structure\n    void display() {\n        cout << "\\n=== BINARY SEARCH TREE ===\\n" << endl;\n        \n        if(isEmpty()) {\n            cout << "Tree is empty!" << endl;\n            return;\n        }\n        \n        cout << "Tree Properties:" << endl;\n        cout << "Size: " << size << endl;\n        cout << "Height: " << getHeight() << endl;\n        cout << "Min value: " << findMin() << endl;\n        cout << "Max value: " << findMax() << endl;\n        cout << "Is Balanced: " << (isBalanced() ? "Yes" : "No") << endl;\n        cout << "Is Valid BST: " << (isValidBST() ? "Yes" : "No") << endl;\n        \n        cout << "\\nTraversals:" << endl;\n        inOrder();\n        preOrder();\n        postOrder();\n        levelOrder();\n        \n        cout << "\\nTree Structure:" << endl;\n        printTree(root, 0);\n        \n        cout << "\\nBST Operations:" << endl;\n        cout << "3rd smallest: " << kthSmallest(3) << endl;\n        cout << "3rd largest: " << kthLargest(3) << endl;\n        cout << "LCA of 20 and 40: " << findLCA(20, 40) << endl;\n    }\n    \n    void printTree(BSTNode* node, int space) {\n        const int COUNT = 5;\n        if(node == nullptr) return;\n        \n        space += COUNT;\n        \n        printTree(node->right, space);\n        \n        cout << endl;\n        for(int i = COUNT; i < space; i++) {\n            cout << " ";\n        }\n        cout << node->data << "\\n";\n        \n        printTree(node->left, space);\n    }\n    \n    // Build sample BST\n    void buildSampleBST() {\n        vector<int> values = {50, 30, 70, 20, 40, 60, 80, 10, 25, 35, 45, 55, 65, 75, 85};\n        for(int val : values) {\n            insert(val);\n        }\n    }\n};\n\n// Application: Phone Directory using BST\nclass PhoneDirectory {\nprivate:\n    struct Contact {\n        string name;\n        string phone;\n        \n        Contact(string n, string p) : name(n), phone(p) {}\n        \n        bool operator<(const Contact& other) const {\n            return name < other.name;\n        }\n        \n        bool operator>(const Contact& other) const {\n            return name > other.name;\n        }\n        \n        bool operator==(const Contact& other) const {\n            return name == other.name;\n        }\n    };\n    \n    struct ContactNode {\n        Contact contact;\n        ContactNode* left;\n        ContactNode* right;\n        \n        ContactNode(string n, string p) : contact(n, p), left(nullptr), right(nullptr) {}\n    };\n    \n    ContactNode* root;\n    int size;\n    \npublic:\n    PhoneDirectory() : root(nullptr), size(0) {}\n    \n    void addContact(string name, string phone) {\n        root = insertContact(root, name, phone);\n    }\n    \n    ContactNode* insertContact(ContactNode* node, string name, string phone) {\n        if(node == nullptr) {\n            size++;\n            return new ContactNode(name, phone);\n        }\n        \n        if(name < node->contact.name) {\n            node->left = insertContact(node->left, name, phone);\n        } else if(name > node->contact.name) {\n            node->right = insertContact(node->right, name, phone);\n        } else {\n            cout << "Contact " << name << " already exists!" << endl;\n        }\n        \n        return node;\n    }\n    \n    string searchContact(string name) {\n        ContactNode* current = root;\n        \n        while(current != nullptr) {\n            if(name == current->contact.name) {\n                return current->contact.phone;\n            } else if(name < current->contact.name) {\n                current = current->left;\n            } else {\n                current = current->right;\n            }\n        }\n        \n        return "Contact not found!";\n    }\n    \n    void displayDirectory() {\n        cout << "\\n=== PHONE DIRECTORY (Sorted by Name) ===\\n" << endl;\n        inOrderDisplay(root);\n    }\n    \n    void inOrderDisplay(ContactNode* node) {\n        if(node == nullptr) return;\n        \n        inOrderDisplay(node->left);\n        cout << "Name: " << node->contact.name << ", Phone: " << node->contact.phone << endl;\n        inOrderDisplay(node->right);\n    }\n    \n    void displayContactsStartingWith(string prefix) {\n        cout << "\\nContacts starting with \'" << prefix << "\':" << endl;\n        displayPrefixHelper(root, prefix);\n    }\n    \n    void displayPrefixHelper(ContactNode* node, string prefix) {\n        if(node == nullptr) return;\n        \n        if(node->contact.name.substr(0, prefix.length()) == prefix) {\n            cout << "Name: " << node->contact.name << ", Phone: " << node->contact.phone << endl;\n        }\n        \n        if(prefix <= node->contact.name) {\n            displayPrefixHelper(node->left, prefix);\n        }\n        \n        if(prefix >= node->contact.name) {\n            displayPrefixHelper(node->right, prefix);\n        }\n    }\n};\n\nint main() {\n    // Part 1: Binary Search Tree Implementation\n    cout << "PART 1: BINARY SEARCH TREE IMPLEMENTATION" << endl;\n    cout << "==========================================\\n" << endl;\n    \n    BinarySearchTree bst;\n    bst.buildSampleBST();\n    bst.display();\n    \n    // Test deletion\n    cout << "\\nDeleting node 30:" << endl;\n    bst.deleteNode(30);\n    bst.inOrder();\n    \n    cout << "\\nDeleting node 50 (root):" << endl;\n    bst.deleteNode(50);\n    bst.inOrder();\n    \n    // Test building balanced BST from sorted array\n    cout << "\\nBuilding balanced BST from sorted array:" << endl;\n    vector<int> sortedArray = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n    bst.buildBalancedBST(sortedArray);\n    bst.display();\n    \n    // Part 2: Phone Directory Application\n    cout << "\\n\\nPART 2: PHONE DIRECTORY APPLICATION" << endl;\n    cout << "====================================\\n" << endl;\n    \n    PhoneDirectory directory;\n    \n    // Add contacts\n    directory.addContact("Alice", "123-456-7890");\n    directory.addContact("Bob", "234-567-8901");\n    directory.addContact("Charlie", "345-678-9012");\n    directory.addContact("David", "456-789-0123");\n    directory.addContact("Eve", "567-890-1234");\n    directory.addContact("Frank", "678-901-2345");\n    \n    // Display directory\n    directory.displayDirectory();\n    \n    // Search for contacts\n    cout << "\\nSearch results:" << endl;\n    cout << "Alice: " << directory.searchContact("Alice") << endl;\n    cout << "Charlie: " << directory.searchContact("Charlie") << endl;\n    cout << "Zoe: " << directory.searchContact("Zoe") << endl;\n    \n    // Display contacts starting with specific letter\n    directory.displayContactsStartingWith("C");\n    \n    return 0;\n}\n'})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Output:"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{children:"PART 1: BINARY SEARCH TREE IMPLEMENTATION\n==========================================\n\n=== BINARY SEARCH TREE ===\n\nTree Properties:\nSize: 15\nHeight: 4\nMin value: 10\nMax value: 85\nIs Balanced: Yes\nIs Valid BST: Yes\n\nTraversals:\nIn-order (Sorted): 10 20 25 30 35 40 45 50 55 60 65 70 75 80 85 \nPre-order: 50 30 20 10 25 40 35 45 70 60 55 65 80 75 85 \nPost-order: 10 25 20 35 45 40 30 55 65 60 75 85 80 70 50 \nLevel Order: 50 30 70 20 40 60 80 10 25 35 45 55 65 75 85 \n\nTree Structure:\n                    85\n                80\n                    75\n            70\n                    65\n                60\n                    55\n        50\n                    45\n                40\n                    35\n            30\n                    25\n                20\n                    10\n\nBST Operations:\n3rd smallest: 25\n3rd largest: 75\nLCA of 20 and 40: 30\n\nDeleting node 30:\nIn-order (Sorted): 10 20 25 35 40 45 50 55 60 65 70 75 80 85 \n\nDeleting node 50 (root):\nIn-order (Sorted): 10 20 25 35 40 45 55 60 65 70 75 80 85 \n\nBuilding balanced BST from sorted array:\n\n=== BINARY SEARCH TREE ===\n\nTree Properties:\nSize: 10\nHeight: 4\nMin value: 1\nMax value: 10\nIs Balanced: Yes\nIs Valid BST: Yes\n\nTraversals:\nIn-order (Sorted): 1 2 3 4 5 6 7 8 9 10 \nPre-order: 5 2 1 3 4 8 6 7 9 10 \nPost-order: 1 4 3 2 7 6 10 9 8 5 \nLevel Order: 5 2 8 1 3 6 9 4 7 10 \n\nTree Structure:\n            10\n        9\n    8\n            7\n        6\n5\n            4\n        3\n    2\n        1\n\n\nPART 2: PHONE DIRECTORY APPLICATION\n====================================\n\n=== PHONE DIRECTORY (Sorted by Name) ===\n\nName: Alice, Phone: 123-456-7890\nName: Bob, Phone: 234-567-8901\nName: Charlie, Phone: 345-678-9012\nName: David, Phone: 456-789-0123\nName: Eve, Phone: 567-890-1234\nName: Frank, Phone: 678-901-2345\n\nSearch results:\nAlice: 123-456-7890\nCharlie: 345-678-9012\nZoe: Contact not found!\n\nContacts starting with 'C':\nName: Charlie, Phone: 345-678-9012\n"})}),"\n",(0,o.jsx)(e.hr,{}),"\n",(0,o.jsx)(e.h1,{id:"dsa-avl-trees---complete-c-guide",children:"DSA AVL Trees - Complete C++ Guide"}),"\n",(0,o.jsx)(e.h2,{id:"introduction-to-avl-trees",children:"Introduction to AVL Trees"}),"\n",(0,o.jsxs)(e.p,{children:["An ",(0,o.jsx)(e.strong,{children:"AVL Tree"})," is a self-balancing binary search tree where the height difference between left and right subtrees (balance factor) of any node is at most 1. Named after inventors Adelson-Velsky and Landis, AVL trees ensure O(log n) time complexity for all operations by automatically rebalancing after insertions and deletions."]}),"\n",(0,o.jsx)(e.h3,{id:"key-characteristics-3",children:"Key Characteristics:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Self-balancing"}),": Automatically maintains height balance"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Balance Factor"}),": height(left) - height(right) \u2208 ",1]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Operations"}),": Search, Insert, Delete all in O(log n) worst-case"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Rotation Operations"}),": Single and double rotations for rebalancing"]}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"balance-factor",children:"Balance Factor:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"BF = -1"}),": Right subtree is taller by 1"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"BF = 0"}),": Subtrees have equal height"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"BF = 1"}),": Left subtree is taller by 1"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"BF = -2 or 2"}),": Tree is unbalanced, needs rotation"]}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"rotation-cases",children:"Rotation Cases:"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Left Left (LL)"}),": Single right rotation"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Right Right (RR)"}),": Single left rotation"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Left Right (LR)"}),": Left rotation then right rotation"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Right Left (RL)"}),": Right rotation then left rotation"]}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"complete-avl-tree-implementation",children:"Complete AVL Tree Implementation"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <queue>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\n// AVL Tree Node\nclass AVLNode {\npublic:\n    int data;\n    int height;\n    AVLNode* left;\n    AVLNode* right;\n    \n    AVLNode(int val) : data(val), height(1), left(nullptr), right(nullptr) {}\n};\n\n// AVL Tree Class\nclass AVLTree {\nprivate:\n    AVLNode* root;\n    int size;\n    \n    // Utility function to get height\n    int getHeight(AVLNode* node) {\n        if(node == nullptr) return 0;\n        return node->height;\n    }\n    \n    // Update height of node\n    void updateHeight(AVLNode* node) {\n        if(node == nullptr) return;\n        node->height = 1 + max(getHeight(node->left), getHeight(node->right));\n    }\n    \n    // Get balance factor\n    int getBalanceFactor(AVLNode* node) {\n        if(node == nullptr) return 0;\n        return getHeight(node->left) - getHeight(node->right);\n    }\n    \n    // ========== ROTATION OPERATIONS ==========\n    \n    // Right rotation (LL case)\n    AVLNode* rightRotate(AVLNode* y) {\n        AVLNode* x = y->left;\n        AVLNode* T2 = x->right;\n        \n        // Perform rotation\n        x->right = y;\n        y->left = T2;\n        \n        // Update heights\n        updateHeight(y);\n        updateHeight(x);\n        \n        return x;\n    }\n    \n    // Left rotation (RR case)\n    AVLNode* leftRotate(AVLNode* x) {\n        AVLNode* y = x->right;\n        AVLNode* T2 = y->left;\n        \n        // Perform rotation\n        y->left = x;\n        x->right = T2;\n        \n        // Update heights\n        updateHeight(x);\n        updateHeight(y);\n        \n        return y;\n    }\n    \n    // ========== BALANCING OPERATIONS ==========\n    \n    // Balance the tree\n    AVLNode* balance(AVLNode* node) {\n        if(node == nullptr) return nullptr;\n        \n        updateHeight(node);\n        int balanceFactor = getBalanceFactor(node);\n        \n        // Left Left Case\n        if(balanceFactor > 1 && getBalanceFactor(node->left) >= 0) {\n            cout << "Right rotation at node " << node->data << " (LL case)" << endl;\n            return rightRotate(node);\n        }\n        \n        // Right Right Case\n        if(balanceFactor < -1 && getBalanceFactor(node->right) <= 0) {\n            cout << "Left rotation at node " << node->data << " (RR case)" << endl;\n            return leftRotate(node);\n        }\n        \n        // Left Right Case\n        if(balanceFactor > 1 && getBalanceFactor(node->left) < 0) {\n            cout << "Left-Right rotation at node " << node->data << " (LR case)" << endl;\n            node->left = leftRotate(node->left);\n            return rightRotate(node);\n        }\n        \n        // Right Left Case\n        if(balanceFactor < -1 && getBalanceFactor(node->right) > 0) {\n            cout << "Right-Left rotation at node " << node->data << " (RL case)" << endl;\n            node->right = rightRotate(node->right);\n            return leftRotate(node);\n        }\n        \n        return node;\n    }\n    \n    // ========== CORE OPERATIONS ==========\n    \n    // Insert helper function\n    AVLNode* insertHelper(AVLNode* node, int value) {\n        // Standard BST insertion\n        if(node == nullptr) {\n            size++;\n            return new AVLNode(value);\n        }\n        \n        if(value < node->data) {\n            node->left = insertHelper(node->left, value);\n        } else if(value > node->data) {\n            node->right = insertHelper(node->right, value);\n        } else {\n            // Duplicate values not allowed\n            cout << "Value " << value << " already exists!" << endl;\n            return node;\n        }\n        \n        // Balance the tree\n        return balance(node);\n    }\n    \n    // Find minimum value node\n    AVLNode* findMinNode(AVLNode* node) {\n        AVLNode* current = node;\n        while(current && current->left != nullptr) {\n            current = current->left;\n        }\n        return current;\n    }\n    \n    // Delete helper function\n    AVLNode* deleteHelper(AVLNode* node, int value) {\n        if(node == nullptr) return nullptr;\n        \n        // Standard BST deletion\n        if(value < node->data) {\n            node->left = deleteHelper(node->left, value);\n        } else if(value > node->data) {\n            node->right = deleteHelper(node->right, value);\n        } else {\n            // Node found\n            size--;\n            \n            // Node with only one child or no child\n            if(node->left == nullptr || node->right == nullptr) {\n                AVLNode* temp = node->left ? node->left : node->right;\n                \n                if(temp == nullptr) {\n                    // No child case\n                    temp = node;\n                    node = nullptr;\n                } else {\n                    // One child case\n                    *node = *temp;\n                }\n                \n                delete temp;\n            } else {\n                // Node with two children\n                AVLNode* temp = findMinNode(node->right);\n                node->data = temp->data;\n                node->right = deleteHelper(node->right, temp->data);\n            }\n        }\n        \n        if(node == nullptr) return nullptr;\n        \n        // Balance the tree\n        return balance(node);\n    }\n    \n    // Search helper function\n    bool searchHelper(AVLNode* node, int value) {\n        if(node == nullptr) return false;\n        \n        if(value == node->data) return true;\n        \n        if(value < node->data) {\n            return searchHelper(node->left, value);\n        } else {\n            return searchHelper(node->right, value);\n        }\n    }\n    \n    // ========== UTILITY FUNCTIONS ==========\n    \n    void clearTree(AVLNode* node) {\n        if(node == nullptr) return;\n        \n        clearTree(node->left);\n        clearTree(node->right);\n        delete node;\n    }\n    \n    void inOrderHelper(AVLNode* node) {\n        if(node == nullptr) return;\n        \n        inOrderHelper(node->left);\n        cout << node->data << "(" << getBalanceFactor(node) << ") ";\n        inOrderHelper(node->right);\n    }\n    \n    void preOrderHelper(AVLNode* node) {\n        if(node == nullptr) return;\n        \n        cout << node->data << "(" << getBalanceFactor(node) << ") ";\n        preOrderHelper(node->left);\n        preOrderHelper(node->right);\n    }\n    \n    void postOrderHelper(AVLNode* node) {\n        if(node == nullptr) return;\n        \n        postOrderHelper(node->left);\n        postOrderHelper(node->right);\n        cout << node->data << "(" << getBalanceFactor(node) << ") ";\n    }\n    \n    void printTreeHelper(AVLNode* node, int space, bool showBalance = false) {\n        const int COUNT = 7;\n        if(node == nullptr) return;\n        \n        space += COUNT;\n        \n        printTreeHelper(node->right, space, showBalance);\n        \n        cout << endl;\n        for(int i = COUNT; i < space; i++) {\n            cout << " ";\n        }\n        \n        if(showBalance) {\n            cout << node->data << "[" << getBalanceFactor(node) << "]";\n        } else {\n            cout << node->data;\n        }\n        cout << "\\n";\n        \n        printTreeHelper(node->left, space, showBalance);\n    }\n    \n    bool isBalancedHelper(AVLNode* node) {\n        if(node == nullptr) return true;\n        \n        int balance = getBalanceFactor(node);\n        if(abs(balance) > 1) return false;\n        \n        return isBalancedHelper(node->left) && isBalancedHelper(node->right);\n    }\n    \npublic:\n    AVLTree() : root(nullptr), size(0) {}\n    \n    ~AVLTree() {\n        clearTree(root);\n    }\n    \n    // ========== PUBLIC INTERFACE ==========\n    \n    void insert(int value) {\n        cout << "\\nInserting " << value << ":" << endl;\n        root = insertHelper(root, value);\n    }\n    \n    void remove(int value) {\n        cout << "\\nDeleting " << value << ":" << endl;\n        root = deleteHelper(root, value);\n    }\n    \n    bool search(int value) {\n        return searchHelper(root, value);\n    }\n    \n    int getHeight() {\n        return getHeight(root);\n    }\n    \n    int getSize() {\n        return size;\n    }\n    \n    bool isEmpty() {\n        return size == 0;\n    }\n    \n    bool isBalanced() {\n        return isBalancedHelper(root);\n    }\n    \n    // ========== TRAVERSALS ==========\n    \n    void inOrder() {\n        cout << "In-order (with balance factors): ";\n        inOrderHelper(root);\n        cout << endl;\n    }\n    \n    void preOrder() {\n        cout << "Pre-order (with balance factors): ";\n        preOrderHelper(root);\n        cout << endl;\n    }\n    \n    void postOrder() {\n        cout << "Post-order (with balance factors): ";\n        postOrderHelper(root);\n        cout << endl;\n    }\n    \n    void levelOrder() {\n        if(root == nullptr) return;\n        \n        queue<AVLNode*> q;\n        q.push(root);\n        \n        cout << "Level Order: ";\n        \n        while(!q.empty()) {\n            AVLNode* current = q.front();\n            q.pop();\n            \n            cout << current->data << "(" << getBalanceFactor(current) << ") ";\n            \n            if(current->left) q.push(current->left);\n            if(current->right) q.push(current->right);\n        }\n        cout << endl;\n    }\n    \n    // ========== DISPLAY FUNCTIONS ==========\n    \n    void display() {\n        cout << "\\n=== AVL TREE ===" << endl;\n        cout << "Size: " << size << endl;\n        cout << "Height: " << getHeight() << endl;\n        cout << "Is Balanced: " << (isBalanced() ? "Yes" : "No") << endl;\n        cout << "Root: " << (root ? to_string(root->data) : "None") << endl;\n        \n        cout << "\\nTree Structure (with balance factors):" << endl;\n        printTreeHelper(root, 0, true);\n        \n        cout << "\\nTraversals:" << endl;\n        inOrder();\n        preOrder();\n        postOrder();\n        levelOrder();\n    }\n    \n    void displaySimple() {\n        cout << "\\nTree Structure:" << endl;\n        printTreeHelper(root, 0, false);\n    }\n    \n    // ========== DEMONSTRATION FUNCTIONS ==========\n    \n    void demonstrateInsertionSequence() {\n        cout << "\\n=== AVL TREE INSERTION DEMONSTRATION ===" << endl;\n        cout << "Inserting sequence: 10, 20, 30, 40, 50, 25\\n" << endl;\n        \n        clearTree(root);\n        root = nullptr;\n        size = 0;\n        \n        // This sequence will trigger all rotation types\n        int values[] = {10, 20, 30, 40, 50, 25};\n        \n        for(int i = 0; i < 6; i++) {\n            insert(values[i]);\n            cout << "After inserting " << values[i] << ":" << endl;\n            displaySimple();\n            cout << endl;\n        }\n    }\n    \n    void demonstrateDeletionSequence() {\n        cout << "\\n=== AVL TREE DELETION DEMONSTRATION ===" << endl;\n        cout << "Initial tree from previous demonstration\\n" << endl;\n        \n        cout << "Deleting 40:" << endl;\n        remove(40);\n        displaySimple();\n        \n        cout << "\\nDeleting 50:" << endl;\n        remove(50);\n        displaySimple();\n        \n        cout << "\\nDeleting 20:" << endl;\n        remove(20);\n        displaySimple();\n    }\n    \n    void buildSampleAVL() {\n        clearTree(root);\n        root = nullptr;\n        size = 0;\n        \n        // Build a more complex AVL tree\n        int values[] = {50, 30, 70, 20, 40, 60, 80, 10, 25, 35, 45, 55, 65, 75, 85, 5, 15};\n        \n        cout << "Building sample AVL tree..." << endl;\n        for(int val : values) {\n            insert(val);\n        }\n    }\n};\n\n// Application: Dictionary using AVL Tree\nclass Dictionary {\nprivate:\n    struct Word {\n        string word;\n        string meaning;\n        \n        Word(string w, string m) : word(w), meaning(m) {}\n        \n        bool operator<(const Word& other) const {\n            return word < other.word;\n        }\n        \n        bool operator>(const Word& other) const {\n            return word > other.word;\n        }\n        \n        bool operator==(const Word& other) const {\n            return word == other.word;\n        }\n    };\n    \n    struct DictNode {\n        Word data;\n        int height;\n        DictNode* left;\n        DictNode* right;\n        \n        DictNode(string w, string m) : data(w, m), height(1), left(nullptr), right(nullptr) {}\n    };\n    \n    DictNode* root;\n    int size;\n    \n    // AVL helper functions\n    int getHeight(DictNode* node) {\n        return node ? node->height : 0;\n    }\n    \n    int getBalance(DictNode* node) {\n        return node ? getHeight(node->left) - getHeight(node->right) : 0;\n    }\n    \n    void updateHeight(DictNode* node) {\n        if(node) {\n            node->height = 1 + max(getHeight(node->left), getHeight(node->right));\n        }\n    }\n    \n    DictNode* rightRotate(DictNode* y) {\n        DictNode* x = y->left;\n        DictNode* T2 = x->right;\n        \n        x->right = y;\n        y->left = T2;\n        \n        updateHeight(y);\n        updateHeight(x);\n        \n        return x;\n    }\n    \n    DictNode* leftRotate(DictNode* x) {\n        DictNode* y = x->right;\n        DictNode* T2 = y->left;\n        \n        y->left = x;\n        x->right = T2;\n        \n        updateHeight(x);\n        updateHeight(y);\n        \n        return y;\n    }\n    \n    DictNode* balance(DictNode* node) {\n        if(!node) return nullptr;\n        \n        updateHeight(node);\n        int balance = getBalance(node);\n        \n        // Left Left\n        if(balance > 1 && getBalance(node->left) >= 0) {\n            return rightRotate(node);\n        }\n        \n        // Right Right\n        if(balance < -1 && getBalance(node->right) <= 0) {\n            return leftRotate(node);\n        }\n        \n        // Left Right\n        if(balance > 1 && getBalance(node->left) < 0) {\n            node->left = leftRotate(node->left);\n            return rightRotate(node);\n        }\n        \n        // Right Left\n        if(balance < -1 && getBalance(node->right) > 0) {\n            node->right = rightRotate(node->right);\n            return leftRotate(node);\n        }\n        \n        return node;\n    }\n    \n    DictNode* insertHelper(DictNode* node, string word, string meaning) {\n        if(!node) {\n            size++;\n            return new DictNode(word, meaning);\n        }\n        \n        if(word < node->data.word) {\n            node->left = insertHelper(node->left, word, meaning);\n        } else if(word > node->data.word) {\n            node->right = insertHelper(node->right, word, meaning);\n        } else {\n            cout << "Word \'" << word << "\' already exists in dictionary!" << endl;\n            return node;\n        }\n        \n        return balance(node);\n    }\n    \n    string searchHelper(DictNode* node, string word) {\n        if(!node) return "Word not found!";\n        \n        if(word == node->data.word) {\n            return node->data.meaning;\n        } else if(word < node->data.word) {\n            return searchHelper(node->left, word);\n        } else {\n            return searchHelper(node->right, word);\n        }\n    }\n    \n    void inOrderDisplay(DictNode* node) {\n        if(!node) return;\n        \n        inOrderDisplay(node->left);\n        cout << node->data.word << ": " << node->data.meaning << endl;\n        inOrderDisplay(node->right);\n    }\n    \npublic:\n    Dictionary() : root(nullptr), size(0) {}\n    \n    void addWord(string word, string meaning) {\n        root = insertHelper(root, word, meaning);\n    }\n    \n    string getMeaning(string word) {\n        return searchHelper(root, word);\n    }\n    \n    void displayDictionary() {\n        cout << "\\n=== DICTIONARY (Sorted Alphabetically) ===\\n" << endl;\n        cout << "Total words: " << size << endl << endl;\n        inOrderDisplay(root);\n    }\n    \n    void displayWordsStartingWith(string prefix) {\n        cout << "\\nWords starting with \'" << prefix << "\':" << endl;\n        displayPrefixHelper(root, prefix);\n    }\n    \n    void displayPrefixHelper(DictNode* node, string prefix) {\n        if(!node) return;\n        \n        if(node->data.word.substr(0, prefix.length()) == prefix) {\n            cout << node->data.word << ": " << node->data.meaning << endl;\n        }\n        \n        if(prefix <= node->data.word) {\n            displayPrefixHelper(node->left, prefix);\n        }\n        \n        if(prefix >= node->data.word) {\n            displayPrefixHelper(node->right, prefix);\n        }\n    }\n};\n\n// Performance comparison: BST vs AVL\nvoid compareBSTvsAVL() {\n    cout << "\\n=== PERFORMANCE COMPARISON: BST vs AVL ===" << endl;\n    \n    // Create sorted array (worst case for BST)\n    const int SIZE = 1000;\n    vector<int> sortedValues(SIZE);\n    for(int i = 0; i < SIZE; i++) {\n        sortedValues[i] = i;\n    }\n    \n    // For fair comparison, shuffle the array\n    vector<int> shuffledValues = sortedValues;\n    random_shuffle(shuffledValues.begin(), shuffledValues.end());\n    \n    cout << "Testing with " << SIZE << " elements..." << endl;\n    \n    // Note: For a complete performance comparison,\n    // we would measure actual insertion/search times\n    // This is a conceptual comparison\n    \n    cout << "\\nBST (with sorted input - worst case):" << endl;\n    cout << "Height: ~" << SIZE << " (degenerates to linked list)" << endl;\n    cout << "Search time: O(n) worst case" << endl;\n    \n    cout << "\\nAVL Tree (with any input):" << endl;\n    cout << "Height: ~1.44 * log\u2082(n) \u2248 " << (int)(1.44 * log2(SIZE)) << endl;\n    cout << "Search time: O(log n) guaranteed" << endl;\n    \n    cout << "\\nBST (with random/shuffled input - average case):" << endl;\n    cout << "Height: ~2 * log\u2082(n) \u2248 " << (int)(2 * log2(SIZE)) << endl;\n    cout << "Search time: O(log n) average" << endl;\n    \n    cout << "\\nConclusion: AVL provides guaranteed O(log n) performance," << endl;\n    cout << "while BST can degrade to O(n) with sorted/almost-sorted data." << endl;\n}\n\nint main() {\n    // Part 1: AVL Tree Implementation\n    cout << "PART 1: AVL TREE IMPLEMENTATION" << endl;\n    cout << "================================\\n" << endl;\n    \n    AVLTree avl;\n    \n    // Demonstration 1: Insertion sequence showing rotations\n    avl.demonstrateInsertionSequence();\n    \n    // Demonstration 2: Deletion sequence\n    avl.demonstrateDeletionSequence();\n    \n    // Build and display a larger AVL tree\n    cout << "\\n\\nPART 2: LARGER AVL TREE EXAMPLE" << endl;\n    cout << "================================\\n" << endl;\n    \n    avl.buildSampleAVL();\n    avl.display();\n    \n    // Test search\n    cout << "\\nSearch operations:" << endl;\n    cout << "Search 45: " << (avl.search(45) ? "Found" : "Not Found") << endl;\n    cout << "Search 100: " << (avl.search(100) ? "Found" : "Not Found") << endl;\n    \n    // Part 3: Dictionary Application\n    cout << "\\n\\nPART 3: DICTIONARY APPLICATION" << endl;\n    cout << "================================\\n" << endl;\n    \n    Dictionary dict;\n    \n    // Add words to dictionary\n    dict.addWord("algorithm", "A set of rules to be followed in calculations");\n    dict.addWord("binary", "Relating to, composed of, or involving two things");\n    dict.addWord("compiler", "A program that translates source code into machine code");\n    dict.addWord("database", "An organized collection of structured information");\n    dict.addWord("encryption", "The process of converting information into code");\n    dict.addWord("function", "A block of code that performs a specific task");\n    dict.addWord("graph", "A pictorial representation of data");\n    dict.addWord("hash", "A function that maps data of arbitrary size to fixed-size values");\n    dict.addWord("iterator", "An object that enables traversal of a container");\n    dict.addWord("javascript", "A programming language for web development");\n    \n    // Display dictionary\n    dict.displayDictionary();\n    \n    // Search for words\n    cout << "\\nWord meanings:" << endl;\n    cout << "algorithm: " << dict.getMeaning("algorithm") << endl;\n    cout << "hash: " << dict.getMeaning("hash") << endl;\n    cout << "python: " << dict.getMeaning("python") << endl;\n    \n    // Display words starting with specific letter\n    dict.displayWordsStartingWith("c");\n    \n    // Part 4: Performance Comparison\n    cout << "\\n\\nPART 4: PERFORMANCE ANALYSIS" << endl;\n    cout << "===============================\\n" << endl;\n    \n    compareBSTvsAVL();\n    \n    // Part 5: AVL Tree Properties\n    cout << "\\n\\nPART 5: AVL TREE PROPERTIES" << endl;\n    cout << "=============================\\n" << endl;\n    \n    cout << "Key Properties of AVL Trees:" << endl;\n    cout << "1. Self-balancing binary search tree" << endl;\n    cout << "2. Height difference (balance factor) between left and right" << endl;\n    cout << "   subtrees is at most 1 for every node" << endl;\n    cout << "3. Guaranteed O(log n) time for search, insert, delete" << endl;\n    cout << "4. Uses rotations to maintain balance:" << endl;\n    cout << "   - Right Rotation (LL case)" << endl;\n    cout << "   - Left Rotation (RR case)" << endl;\n    cout << "   - Left-Right Rotation (LR case)" << endl;\n    cout << "   - Right-Left Rotation (RL case)" << endl;\n    cout << "5. Height is approximately 1.44 * log\u2082(n)" << endl;\n    \n    cout << "\\nWhen to use AVL Trees:" << endl;\n    cout << "1. When frequent search operations are needed" << endl;\n    cout << "2. When data is frequently inserted/deleted" << endl;\n    cout << "3. When guaranteed O(log n) performance is required" << endl;\n    cout << "4. When memory is not a major constraint" << endl;\n    \n    cout << "\\nTrade-offs:" << endl;\n    cout << "1. More complex implementation than regular BST" << endl;\n    cout << "2. Higher constant factors due to rotations" << endl;\n    cout << "3. More memory overhead (stores height in each node)" << endl;\n    cout << "4. Slower insertion/deletion than BST (due to rotations)" << endl;\n    \n    return 0;\n}\n'})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Output:"})}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{children:"PART 1: AVL TREE IMPLEMENTATION\n================================\n\n=== AVL TREE INSERTION DEMONSTRATION ===\nInserting sequence: 10, 20, 30, 40, 50, 25\n\nInserting 10:\nAfter inserting 10:\n10\n\nInserting 20:\nAfter inserting 20:\n    20\n10\n\nInserting 30:\nLeft rotation at node 10 (RR case)\nAfter inserting 30:\n    30\n20\n    10\n\nInserting 40:\nAfter inserting 40:\n        40\n    30\n20\n    10\n\nInserting 50:\nLeft rotation at node 30 (RR case)\nAfter inserting 50:\n        50\n    40\n        30\n20\n    10\n\nInserting 25:\nRight-Left rotation at node 20 (RL case)\nAfter inserting 25:\n        50\n    40\n        30\n25\n    20\n        10\n\n=== AVL TREE DELETION DEMONSTRATION ===\nInitial tree from previous demonstration\n\nDeleting 40:\nAfter deleting 40:\n        50\n    30\n25\n    20\n        10\n\nDeleting 50:\nAfter deleting 50:\n    30\n25\n    20\n        10\n\nDeleting 20:\nAfter deleting 20:\n    30\n25\n    10\n\n\nPART 2: LARGER AVL TREE EXAMPLE\n================================\n\nBuilding sample AVL tree...\n\n=== AVL TREE ===\nSize: 17\nHeight: 5\nIs Balanced: Yes\nRoot: 50\n\nTree Structure (with balance factors):\n                        85[0]\n                    80[0]\n                        75[0]\n                70[0]\n                    65[0]\n            60[0]\n                    55[0]\n        50[0]\n                    45[0]\n                40[0]\n                    35[0]\n            30[0]\n                        25[0]\n                    20[0]\n                        15[0]\n                10[1]\n                    5[0]\n\nTraversals:\nIn-order (with balance factors): 5[0] 10[1] 15[0] 20[0] 25[0] 30[0] 35[0] 40[0] 45[0] 50[0] 55[0] 60[0] 65[0] 70[0] 75[0] 80[0] 85[0] \nPre-order (with balance factors): 50[0] 30[0] 10[1] 5[0] 20[0] 15[0] 25[0] 40[0] 35[0] 45[0] 70[0] 60[0] 55[0] 65[0] 80[0] 75[0] 85[0] \nPost-order (with balance factors): 5[0] 15[0] 25[0] 20[0] 10[1] 35[0] 45[0] 40[0] 30[0] 55[0] 65[0] 60[0] 75[0] 85[0] 80[0] 70[0] 50[0] \nLevel Order: 50[0] 30[0] 70[0] 10[1] 40[0] 60[0] 80[0] 5[0] 20[0] 35[0] 45[0] 55[0] 65[0] 75[0] 85[0] 15[0] 25[0] \n\nSearch operations:\nSearch 45: Found\nSearch 100: Not Found\n\n\nPART 3: DICTIONARY APPLICATION\n================================\n\n=== DICTIONARY (Sorted Alphabetically) ===\n\nTotal words: 10\n\nalgorithm: A set of rules to be followed in calculations\nbinary: Relating to, composed of, or involving two things\ncompiler: A program that translates source code into machine code\ndatabase: An organized collection of structured information\nencryption: The process of converting information into code\nfunction: A block of code that performs a specific task\ngraph: A pictorial representation of data\nhash: A function that maps data of arbitrary size to fixed-size values\niterator: An object that enables traversal of a container\njavascript: A programming language for web development\n\nWord meanings:\nalgorithm: A set of rules to be followed in calculations\nhash: A function that maps data of arbitrary size to fixed-size values\npython: Word not found!\n\nWords starting with 'c':\ncompiler: A program that translates source code into machine code\n\n\nPART 4: PERFORMANCE ANALYSIS\n===============================\n\n=== PERFORMANCE COMPARISON: BST vs AVL ===\nTesting with 1000 elements...\n\nBST (with sorted input - worst case):\nHeight: ~1000 (degenerates to linked list)\nSearch time: O(n) worst case\n\nAVL Tree (with any input):\nHeight: ~1.44 * log\u2082(n) \u2248 14\nSearch time: O(log n) guaranteed\n\nBST (with random/shuffled input - average case):\nHeight: ~2 * log\u2082(n) \u2248 20\nSearch time: O(log n) average\n\nConclusion: AVL provides guaranteed O(log n) performance,\nwhile BST can degrade to O(n) with sorted/almost-sorted data.\n\n\nPART 5: AVL TREE PROPERTIES\n=============================\n\nKey Properties of AVL Trees:\n1. Self-balancing binary search tree\n2. Height difference (balance factor) between left and right\n   subtrees is at most 1 for every node\n3. Guaranteed O(log n) time for search, insert, delete\n4. Uses rotations to maintain balance:\n   - Right Rotation (LL case)\n   - Left Rotation (RR case)\n   - Left-Right Rotation (LR case)\n   - Right-Left Rotation (RL case)\n5. Height is approximately 1.44 * log\u2082(n)\n\nWhen to use AVL Trees:\n1. When frequent search operations are needed\n2. When data is frequently inserted/deleted\n3. When guaranteed O(log n) performance is required\n4. When memory is not a major constraint\n\nTrade-offs:\n1. More complex implementation than regular BST\n2. Higher constant factors due to rotations\n3. More memory overhead (stores height in each node)\n4. Slower insertion/deletion than BST (due to rotations)\n"})}),"\n",(0,o.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,o.jsx)(e.p,{children:"This comprehensive guide covers all major tree data structures in C++:"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Basic Trees"}),": Hierarchical structure with parent-child relationships"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Binary Trees"}),": Each node has at most 2 children"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Tree Traversals"}),": Pre-order, In-order, Post-order, Level-order"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Array Implementation"}),": Efficient storage for complete binary trees"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Binary Search Trees (BST)"}),": Sorted binary trees with O(h) operations"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"AVL Trees"}),": Self-balancing BST with guaranteed O(log n) performance"]}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:"Each section includes:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Detailed explanations with diagrams"}),"\n",(0,o.jsx)(e.li,{children:"Complete C++ implementations"}),"\n",(0,o.jsx)(e.li,{children:"Multiple traversal methods"}),"\n",(0,o.jsx)(e.li,{children:"Practical applications"}),"\n",(0,o.jsx)(e.li,{children:"Performance analysis"}),"\n",(0,o.jsx)(e.li,{children:"Comparison between different implementations"}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:"Trees are fundamental to computer science, used in databases, file systems, compilers, networking, and artificial intelligence. Mastering these concepts is essential for efficient algorithm design and problem-solving."})]})}function u(n={}){const{wrapper:e}={...(0,i.R)(),...n.components};return e?(0,o.jsx)(e,{...n,children:(0,o.jsx)(c,{...n})}):c(n)}},8453(n,e,r){r.d(e,{R:()=>a,x:()=>d});var t=r(6540);const o={},i=t.createContext(o);function a(n){const e=t.useContext(i);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function d(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:a(n.components),t.createElement(i.Provider,{value:e},n.children)}}}]);