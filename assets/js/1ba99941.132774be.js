"use strict";(globalThis.webpackChunkmarkdown_web_app=globalThis.webpackChunkmarkdown_web_app||[]).push([[503],{4177(n,e,i){i.r(e),i.d(e,{assets:()=>l,contentTitle:()=>o,default:()=>m,frontMatter:()=>s,metadata:()=>a,toc:()=>c});var t=i(4848),r=i(8453);const s={id:"time-complexity",title:"time complexity"},o="Time Complexity",a={id:"time-complexity",title:"time complexity",description:"Time Complexity is a fundamental concept in computer science that describes the amount of computational time an algorithm takes to run as a function of the input size. It provides a theoretical estimate of the time required for an algorithm to complete, helping us understand and compare the efficiency of different algorithms.",source:"@site/docs/time-complexity.md",sourceDirName:".",slug:"/time-complexity",permalink:"/markdown-web-app/time-complexity",draft:!1,unlisted:!1,editUrl:"https://github.com/kalyxon/markdown-web-app/tree/main/docs/time-complexity.md",tags:[],version:"current",frontMatter:{id:"time-complexity",title:"time complexity"},sidebar:"dsa",previous:{title:"graphs",permalink:"/markdown-web-app/graphs"},next:{title:"minimum spanning tree",permalink:"/markdown-web-app/minimum-spanning-tree"}},l={},c=[{value:"Introduction to Time Complexity",id:"introduction-to-time-complexity",level:2},{value:"Common Time Complexities",id:"common-time-complexities",level:3},{value:"Why Time Complexity Matters",id:"why-time-complexity-matters",level:3},{value:"Bubble Sort",id:"bubble-sort",level:2},{value:"Implementation with Time Analysis",id:"implementation-with-time-analysis",level:3},{value:"Selection Sort",id:"selection-sort",level:2},{value:"Implementation with Time Analysis",id:"implementation-with-time-analysis-1",level:3},{value:"Insertion Sort",id:"insertion-sort",level:2},{value:"Implementation with Time Analysis",id:"implementation-with-time-analysis-2",level:3},{value:"Quick Sort",id:"quick-sort",level:2},{value:"Implementation with Time Analysis",id:"implementation-with-time-analysis-3",level:3},{value:"Counting Sort",id:"counting-sort",level:2},{value:"Implementation with Time Analysis",id:"implementation-with-time-analysis-4",level:3},{value:"Radix Sort",id:"radix-sort",level:2},{value:"Implementation with Time Analysis",id:"implementation-with-time-analysis-5",level:3},{value:"Merge Sort",id:"merge-sort",level:2},{value:"Implementation with Time Analysis",id:"implementation-with-time-analysis-6",level:3},{value:"Linear Search",id:"linear-search",level:2},{value:"Implementation with Time Analysis",id:"implementation-with-time-analysis-7",level:3},{value:"Binary Search",id:"binary-search",level:2},{value:"Implementation with Time Analysis",id:"implementation-with-time-analysis-8",level:3},{value:"Iterative vs Recursive Binary Search",id:"iterative-vs-recursive-binary-search",level:3},{value:"Comprehensive Comparison Table",id:"comprehensive-comparison-table",level:2},{value:"Practical Guidelines for Algorithm Selection",id:"practical-guidelines-for-algorithm-selection",level:2},{value:"Complexity Classes Visualization",id:"complexity-classes-visualization",level:2},{value:"Time Complexity in Practice",id:"time-complexity-in-practice",level:2},{value:"Key Takeaways",id:"key-takeaways",level:2}];function d(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.header,{children:(0,t.jsx)(e.h1,{id:"time-complexity",children:"Time Complexity"})}),"\n",(0,t.jsx)(e.p,{children:"Time Complexity is a fundamental concept in computer science that describes the amount of computational time an algorithm takes to run as a function of the input size. It provides a theoretical estimate of the time required for an algorithm to complete, helping us understand and compare the efficiency of different algorithms."}),"\n",(0,t.jsx)(e.h2,{id:"introduction-to-time-complexity",children:"Introduction to Time Complexity"}),"\n",(0,t.jsx)(e.p,{children:"Time complexity is typically expressed using Big O notation, which describes the upper bound of growth rate as input size increases. We focus on the worst-case scenario to guarantee performance under any condition."}),"\n",(0,t.jsx)(e.h3,{id:"common-time-complexities",children:"Common Time Complexities"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <vector>\n#include <chrono>\n#include <algorithm>\nusing namespace std;\nusing namespace std::chrono;\n\n// Function to demonstrate different time complexities\nvoid demonstrateComplexities() {\n    cout << "Common Time Complexities:\\n" << endl;\n    cout << "O(1)     - Constant Time:      Accessing array element" << endl;\n    cout << "O(log n) - Logarithmic Time:   Binary search" << endl;\n    cout << "O(n)     - Linear Time:        Linear search" << endl;\n    cout << "O(n log n) - Linearithmic:     Merge sort, Quick sort" << endl;\n    cout << "O(n\xb2)    - Quadratic Time:     Bubble sort, Selection sort" << endl;\n    cout << "O(2\u207f)    - Exponential Time:   Fibonacci recursive" << endl;\n    cout << "O(n!)    - Factorial Time:     Traveling salesman brute force\\n" << endl;\n}\n\n// Example: O(1) Constant Time\nvoid constantTime(int arr[], int index) {\n    // Accessing array element takes constant time\n    cout << "Element at index " << index << ": " << arr[index] << " (O(1) operation)" << endl;\n}\n\n// Example: O(n) Linear Time\nvoid linearTime(int arr[], int n, int target) {\n    for(int i = 0; i < n; i++) {\n        if(arr[i] == target) {\n            cout << "Found " << target << " at index " << i << " (O(n) operation)" << endl;\n            return;\n        }\n    }\n    cout << target << " not found (O(n) operation)" << endl;\n}\n\n// Example: O(n\xb2) Quadratic Time\nvoid quadraticTime(int arr[], int n) {\n    int comparisons = 0;\n    for(int i = 0; i < n; i++) {\n        for(int j = 0; j < n; j++) {\n            comparisons++;\n        }\n    }\n    cout << "Performed " << comparisons << " comparisons (O(n\xb2) operation)" << endl;\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"why-time-complexity-matters",children:"Why Time Complexity Matters"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <cmath>\nusing namespace std;\n\nvoid compareComplexities() {\n    cout << "\\n=== Growth Rate Comparison ===\\n" << endl;\n    cout << "Input Size | O(1) | O(log n) | O(n) | O(n log n) | O(n\xb2) | O(2\u207f)" << endl;\n    cout << "-----------|------|----------|------|------------|-------|------" << endl;\n    \n    int sizes[] = {10, 100, 1000, 10000};\n    \n    for(int n : sizes) {\n        cout << n << "\\t   | 1";\n        cout << "\\t   | " << (int)log2(n);\n        cout << "\\t    | " << n;\n        cout << "\\t| " << (int)(n * log2(n));\n        cout << "\\t     | " << n * n;\n        cout << "\\t| " << (long long)pow(2, n) << endl;\n    }\n    \n    cout << "\\nKey Insight: As n grows, efficient algorithms make huge differences!" << endl;\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"bubble-sort",children:"Bubble Sort"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Time Complexity:"})," O(n\xb2) in worst and average cases, O(n) in best case (already sorted)"]}),"\n",(0,t.jsx)(e.h3,{id:"implementation-with-time-analysis",children:"Implementation with Time Analysis"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <vector>\n#include <chrono>\nusing namespace std;\nusing namespace std::chrono;\n\nvoid bubbleSort(int arr[], int n) {\n    long long comparisons = 0;\n    long long swaps = 0;\n    \n    for(int i = 0; i < n-1; i++) {\n        for(int j = 0; j < n-i-1; j++) {\n            comparisons++;\n            if(arr[j] > arr[j+1]) {\n                swaps++;\n                int temp = arr[j];\n                arr[j] = arr[j+1];\n                arr[j+1] = temp;\n            }\n        }\n    }\n    \n    cout << "Bubble Sort completed with:" << endl;\n    cout << "Comparisons: " << comparisons << " (\u2248 n\xb2/2 = " << (n*n)/2 << ")" << endl;\n    cout << "Swaps: " << swaps << endl;\n    cout << "Time Complexity: O(n\xb2)" << endl;\n}\n\nvoid optimizedBubbleSort(int arr[], int n) {\n    long long comparisons = 0;\n    long long swaps = 0;\n    bool swapped;\n    \n    for(int i = 0; i < n-1; i++) {\n        swapped = false;\n        for(int j = 0; j < n-i-1; j++) {\n            comparisons++;\n            if(arr[j] > arr[j+1]) {\n                swaps++;\n                swap(arr[j], arr[j+1]);\n                swapped = true;\n            }\n        }\n        if(!swapped) break; // Early termination\n    }\n    \n    cout << "\\nOptimized Bubble Sort completed with:" << endl;\n    cout << "Comparisons: " << comparisons << endl;\n    cout << "Swaps: " << swaps << endl;\n    cout << "Best Case Time: O(n) when already sorted" << endl;\n    cout << "Average/Worst Case Time: O(n\xb2)" << endl;\n}\n'})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Complexity Analysis:"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Worst Case (Reverse Sorted):"})," O(n\xb2) comparisons and swaps"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Average Case:"})," O(n\xb2)"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Best Case (Already Sorted):"})," O(n) comparisons, O(1) swaps"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Space Complexity:"})," O(1) - In-place sorting"]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"selection-sort",children:"Selection Sort"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Time Complexity:"})," O(n\xb2) in all cases (best, average, worst)"]}),"\n",(0,t.jsx)(e.h3,{id:"implementation-with-time-analysis-1",children:"Implementation with Time Analysis"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\nusing namespace std;\n\nvoid selectionSort(int arr[], int n) {\n    long long comparisons = 0;\n    long long swaps = 0;\n    \n    cout << "\\n=== Selection Sort Process ===" << endl;\n    \n    for(int i = 0; i < n-1; i++) {\n        int minIndex = i;\n        \n        // Find minimum in unsorted part\n        for(int j = i+1; j < n; j++) {\n            comparisons++;\n            if(arr[j] < arr[minIndex]) {\n                minIndex = j;\n            }\n        }\n        \n        // Swap if needed\n        if(minIndex != i) {\n            swaps++;\n            swap(arr[i], arr[minIndex]);\n        }\n        \n        cout << "Pass " << i+1 << ": Comparisons = " << comparisons \n             << ", Swaps = " << swaps << endl;\n    }\n    \n    cout << "\\nTotal Comparisons: " << comparisons << " (n*(n-1)/2 = " \n         << (n*(n-1))/2 << ")" << endl;\n    cout << "Total Swaps: " << swaps << " (n-1 at maximum)" << endl;\n    cout << "Time Complexity: Always O(n\xb2)" << endl;\n    cout << "Space Complexity: O(1)" << endl;\n}\n'})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Complexity Analysis:"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Comparisons:"})," Always n(n-1)/2 = O(n\xb2)"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Swaps:"})," At most n-1 = O(n)"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Best/Worst/Average Case:"})," All O(n\xb2) for comparisons"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Advantage:"})," Minimal swaps compared to Bubble Sort"]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"insertion-sort",children:"Insertion Sort"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Time Complexity:"})," O(n\xb2) worst/average, O(n) best case"]}),"\n",(0,t.jsx)(e.h3,{id:"implementation-with-time-analysis-2",children:"Implementation with Time Analysis"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\nusing namespace std;\n\nvoid insertionSort(int arr[], int n) {\n    long long comparisons = 0;\n    long long shifts = 0;\n    \n    cout << "\\n=== Insertion Sort Process ===" << endl;\n    \n    for(int i = 1; i < n; i++) {\n        int key = arr[i];\n        int j = i - 1;\n        \n        // Move elements greater than key one position ahead\n        while(j >= 0) {\n            comparisons++;\n            if(arr[j] > key) {\n                arr[j + 1] = arr[j];\n                shifts++;\n                j--;\n            } else {\n                break;\n            }\n        }\n        arr[j + 1] = key;\n        \n        cout << "After iteration " << i << ": Comparisons = " << comparisons \n             << ", Shifts = " << shifts << endl;\n    }\n    \n    cout << "\\nTotal Comparisons: " << comparisons << endl;\n    cout << "Total Shifts: " << shifts << endl;\n    cout << "Best Case (sorted): O(n) comparisons, O(1) shifts" << endl;\n    cout << "Worst Case (reverse sorted): O(n\xb2) comparisons and shifts" << endl;\n    cout << "Average Case: O(n\xb2)" << endl;\n    cout << "Space Complexity: O(1)" << endl;\n}\n'})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Complexity Analysis:"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Best Case (Sorted Array):"})," O(n) comparisons, O(1) shifts"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Worst Case (Reverse Sorted):"})," O(n\xb2) comparisons and shifts"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Average Case:"})," O(n\xb2)"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Stable:"})," Yes (maintains relative order)"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Adaptive:"})," Performs better on partially sorted arrays"]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"quick-sort",children:"Quick Sort"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Time Complexity:"})," O(n log n) average, O(n\xb2) worst case"]}),"\n",(0,t.jsx)(e.h3,{id:"implementation-with-time-analysis-3",children:"Implementation with Time Analysis"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <ctime>\n#include <cstdlib>\nusing namespace std;\n\nlong long comparisons = 0;\nlong long swaps = 0;\n\nint partition(int arr[], int low, int high) {\n    int pivot = arr[high];\n    int i = low - 1;\n    \n    for(int j = low; j < high; j++) {\n        comparisons++;\n        if(arr[j] <= pivot) {\n            i++;\n            swaps++;\n            swap(arr[i], arr[j]);\n        }\n    }\n    swaps++;\n    swap(arr[i + 1], arr[high]);\n    return i + 1;\n}\n\nint randomizedPartition(int arr[], int low, int high) {\n    // Random pivot reduces chance of worst case\n    int random = low + rand() % (high - low + 1);\n    swap(arr[random], arr[high]);\n    return partition(arr, low, high);\n}\n\nvoid quickSort(int arr[], int low, int high, bool randomized = false) {\n    if(low < high) {\n        int pi;\n        if(randomized) {\n            pi = randomizedPartition(arr, low, high);\n        } else {\n            pi = partition(arr, low, high);\n        }\n        \n        quickSort(arr, low, pi - 1, randomized);\n        quickSort(arr, pi + 1, high, randomized);\n    }\n}\n\nvoid analyzeQuickSort() {\n    srand(time(0));\n    \n    // Worst case array (already sorted)\n    int worstArr[] = {1, 2, 3, 4, 5, 6, 7, 8};\n    int n = 8;\n    \n    cout << "\\n=== Quick Sort Analysis ===" << endl;\n    \n    // Reset counters\n    comparisons = 0;\n    swaps = 0;\n    \n    cout << "\\nWorst Case (Sorted Array):" << endl;\n    quickSort(worstArr, 0, n-1, false);\n    cout << "Comparisons: " << comparisons << " (n\xb2/2 = " << (n*n)/2 << ")" << endl;\n    cout << "Swaps: " << swaps << endl;\n    cout << "Time Complexity: O(n\xb2)" << endl;\n    \n    // Random array for average case\n    int avgArr[] = {3, 7, 1, 8, 4, 2, 6, 5};\n    comparisons = 0;\n    swaps = 0;\n    \n    cout << "\\nAverage Case (Random Array):" << endl;\n    quickSort(avgArr, 0, n-1, true);\n    cout << "Comparisons: " << comparisons << " (\u2248 n log n = " << n * (int)log2(n) << ")" << endl;\n    cout << "Swaps: " << swaps << endl;\n    cout << "Time Complexity: O(n log n)" << endl;\n    \n    cout << "\\nKey Points:" << endl;\n    cout << "1. Average Case: O(n log n)" << endl;\n    cout << "2. Worst Case: O(n\xb2) when pivot is smallest/largest" << endl;\n    cout << "3. Randomized pivot helps avoid worst case" << endl;\n    cout << "4. Space Complexity: O(log n) for recursion stack" << endl;\n}\n'})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Complexity Analysis:"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Best Case:"})," O(n log n) - balanced partitions"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Average Case:"})," O(n log n)"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Worst Case:"})," O(n\xb2) - unbalanced partitions"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Space Complexity:"})," O(log n) average, O(n) worst for recursion stack"]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"counting-sort",children:"Counting Sort"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Time Complexity:"})," O(n + k) where k is range of input"]}),"\n",(0,t.jsx)(e.h3,{id:"implementation-with-time-analysis-4",children:"Implementation with Time Analysis"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvoid countingSort(int arr[], int n) {\n    cout << "\\n=== Counting Sort ===" << endl;\n    \n    // Find range\n    int maxVal = *max_element(arr, arr + n);\n    int minVal = *min_element(arr, arr + n);\n    int range = maxVal - minVal + 1;\n    \n    cout << "Input Range: " << minVal << " to " << maxVal << endl;\n    cout << "Range size (k): " << range << endl;\n    \n    vector<int> count(range, 0);\n    vector<int> output(n);\n    \n    // Count occurrences\n    long long operations = 0;\n    for(int i = 0; i < n; i++) {\n        count[arr[i] - minVal]++;\n        operations++;\n    }\n    cout << "Counting phase operations: " << operations << " (O(n))" << endl;\n    \n    // Cumulative count\n    operations = 0;\n    for(int i = 1; i < range; i++) {\n        count[i] += count[i-1];\n        operations++;\n    }\n    cout << "Cumulative count operations: " << operations << " (O(k))" << endl;\n    \n    // Build output array\n    operations = 0;\n    for(int i = n-1; i >= 0; i--) {\n        output[count[arr[i] - minVal] - 1] = arr[i];\n        count[arr[i] - minVal]--;\n        operations++;\n    }\n    cout << "Building output operations: " << operations << " (O(n))" << endl;\n    \n    // Copy back\n    for(int i = 0; i < n; i++) {\n        arr[i] = output[i];\n    }\n    \n    cout << "\\nTotal Time Complexity: O(n + k)" << endl;\n    cout << "When k = O(n), time is O(n)" << endl;\n    cout << "Space Complexity: O(n + k)" << endl;\n    cout << "Stable: Yes" << endl;\n}\n'})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Complexity Analysis:"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Time Complexity:"})," O(n + k) where k is range of input"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Space Complexity:"})," O(n + k)"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Best Use Case:"})," When k = O(n) - small range integers"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Stable:"})," Yes"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Not Comparison Based:"})," Doesn't use comparisons"]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"radix-sort",children:"Radix Sort"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Time Complexity:"})," O(d \xd7 (n + b)) where d is digits, b is base"]}),"\n",(0,t.jsx)(e.h3,{id:"implementation-with-time-analysis-5",children:"Implementation with Time Analysis"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// Get digit at position (1s, 10s, 100s, etc.)\nint getDigit(int num, int position) {\n    for(int i = 0; i < position; i++) {\n        num /= 10;\n    }\n    return num % 10;\n}\n\n// Get maximum number of digits\nint getMaxDigits(int arr[], int n) {\n    int maxNum = *max_element(arr, arr + n);\n    int digits = 0;\n    while(maxNum > 0) {\n        digits++;\n        maxNum /= 10;\n    }\n    return digits;\n}\n\nvoid radixSort(int arr[], int n) {\n    cout << "\\n=== Radix Sort ===" << endl;\n    \n    int maxDigits = getMaxDigits(arr, n);\n    cout << "Maximum digits: " << maxDigits << endl;\n    \n    long long totalOperations = 0;\n    \n    for(int digitPos = 0; digitPos < maxDigits; digitPos++) {\n        vector<vector<int>> buckets(10);\n        long long operations = 0;\n        \n        // Distribute numbers into buckets\n        for(int i = 0; i < n; i++) {\n            int digit = getDigit(arr[i], digitPos);\n            buckets[digit].push_back(arr[i]);\n            operations++;\n        }\n        \n        // Collect from buckets\n        int index = 0;\n        for(int d = 0; d < 10; d++) {\n            for(int num : buckets[d]) {\n                arr[index++] = num;\n                operations++;\n            }\n        }\n        \n        cout << "Digit position " << digitPos << ": " << operations << " operations" << endl;\n        totalOperations += operations;\n    }\n    \n    cout << "\\nTotal Operations: " << totalOperations << endl;\n    cout << "Time Complexity: O(d \xd7 (n + b))" << endl;\n    cout << "Where: d = " << maxDigits << " digits, n = " << n \n         << " elements, b = 10 (decimal base)" << endl;\n    cout << "When d is constant and b = O(n): O(n)" << endl;\n    cout << "Space Complexity: O(n + b)" << endl;\n}\n'})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Complexity Analysis:"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Time Complexity:"})," O(d \xd7 (n + b))"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Space Complexity:"})," O(n + b)"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Best Use Case:"})," Fixed-length integer keys"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Stable:"})," Yes (when counting sort is used for digit sorting)"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"LSD vs MSD:"})," LSD (Least Significant Digit) is more common"]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"merge-sort",children:"Merge Sort"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Time Complexity:"})," O(n log n) in all cases"]}),"\n",(0,t.jsx)(e.h3,{id:"implementation-with-time-analysis-6",children:"Implementation with Time Analysis"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <vector>\nusing namespace std;\n\nlong long comparisons = 0;\nlong long merges = 0;\n\nvoid merge(int arr[], int left, int mid, int right) {\n    int n1 = mid - left + 1;\n    int n2 = right - mid;\n    \n    vector<int> L(n1), R(n2);\n    \n    // Copy data\n    for(int i = 0; i < n1; i++) L[i] = arr[left + i];\n    for(int j = 0; j < n2; j++) R[j] = arr[mid + 1 + j];\n    \n    // Merge\n    int i = 0, j = 0, k = left;\n    \n    while(i < n1 && j < n2) {\n        comparisons++;\n        if(L[i] <= R[j]) {\n            arr[k] = L[i];\n            i++;\n        } else {\n            arr[k] = R[j];\n            j++;\n        }\n        k++;\n    }\n    \n    // Copy remaining\n    while(i < n1) {\n        arr[k] = L[i];\n        i++; k++;\n    }\n    while(j < n2) {\n        arr[k] = R[j];\n        j++; k++;\n    }\n    \n    merges++;\n}\n\nvoid mergeSort(int arr[], int left, int right) {\n    if(left >= right) return;\n    \n    int mid = left + (right - left) / 2;\n    \n    mergeSort(arr, left, mid);\n    mergeSort(arr, mid + 1, right);\n    merge(arr, left, mid, right);\n}\n\nvoid analyzeMergeSort() {\n    cout << "\\n=== Merge Sort Analysis ===" << endl;\n    \n    // Reset counters\n    comparisons = 0;\n    merges = 0;\n    \n    int arr[] = {38, 27, 43, 3, 9, 82, 10};\n    int n = sizeof(arr)/sizeof(arr[0]);\n    \n    cout << "Array size: " << n << endl;\n    cout << "Theoretical comparisons: n log n = " \n         << n * (int)log2(n) << " to " << n * (int)log2(n) * 2 << endl;\n    \n    mergeSort(arr, 0, n-1);\n    \n    cout << "\\nActual Results:" << endl;\n    cout << "Comparisons: " << comparisons << endl;\n    cout << "Merge operations: " << merges << endl;\n    \n    cout << "\\nTime Complexity Analysis:" << endl;\n    cout << "Recurrence Relation: T(n) = 2T(n/2) + O(n)" << endl;\n    cout << "Using Master Theorem: O(n log n)" << endl;\n    cout << "Best/Worst/Average Case: All O(n log n)" << endl;\n    cout << "Space Complexity: O(n) for temporary arrays" << endl;\n    cout << "Stable: Yes" << endl;\n}\n'})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Complexity Analysis:"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Time Complexity:"})," Always O(n log n)"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Space Complexity:"})," O(n) auxiliary space"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Stable:"})," Yes"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Parallelizable:"})," Yes (divide and conquer nature)"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Not In-place:"})," Requires extra memory"]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"linear-search",children:"Linear Search"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Time Complexity:"})," O(n) worst/average, O(1) best case"]}),"\n",(0,t.jsx)(e.h3,{id:"implementation-with-time-analysis-7",children:"Implementation with Time Analysis"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <vector>\n#include <ctime>\n#include <cstdlib>\nusing namespace std;\n\nvoid linearSearchAnalysis() {\n    cout << "\\n=== Linear Search Analysis ===" << endl;\n    \n    srand(time(0));\n    \n    // Create arrays of different sizes\n    int sizes[] = {100, 1000, 10000, 100000};\n    \n    cout << "\\nSize\\tBest Case\\tWorst Case\\tAverage Case" << endl;\n    cout << "----\\t----------\\t-----------\\t------------" << endl;\n    \n    for(int size : sizes) {\n        vector<int> arr(size);\n        \n        // Fill with random numbers\n        for(int i = 0; i < size; i++) {\n            arr[i] = rand() % 1000000;\n        }\n        \n        // Best case: search for first element\n        int bestCaseKey = arr[0];\n        long long comparisons = 0;\n        for(int i = 0; i < size; i++) {\n            comparisons++;\n            if(arr[i] == bestCaseKey) break;\n        }\n        int bestCaseComp = comparisons;\n        \n        // Worst case: search for non-existent element\n        comparisons = 0;\n        int worstCaseKey = -1; // Not in array\n        for(int i = 0; i < size; i++) {\n            comparisons++;\n            if(arr[i] == worstCaseKey) break;\n        }\n        int worstCaseComp = comparisons;\n        \n        // Average case: search random element\n        comparisons = 0;\n        int avgKey = arr[rand() % size];\n        for(int i = 0; i < size; i++) {\n            comparisons++;\n            if(arr[i] == avgKey) break;\n        }\n        int avgCaseComp = comparisons;\n        \n        cout << size << "\\t" << bestCaseComp << "\\t\\t" \n             << worstCaseComp << "\\t\\t" << avgCaseComp << endl;\n    }\n    \n    cout << "\\nTime Complexity Summary:" << endl;\n    cout << "Best Case (element at front): O(1)" << endl;\n    cout << "Worst Case (element at end or not present): O(n)" << endl;\n    cout << "Average Case: O(n)" << endl;\n    cout << "Space Complexity: O(1)" << endl;\n}\n'})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Complexity Analysis:"})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Best Case:"})," O(1) - element at first position"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Worst Case:"})," O(n) - element at last position or not found"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Average Case:"})," O(n) - element somewhere in middle"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Space Complexity:"})," O(1)"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Use Case:"})," Unsorted or small datasets"]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"binary-search",children:"Binary Search"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Time Complexity:"})," O(log n) worst/average, O(1) best case"]}),"\n",(0,t.jsx)(e.h3,{id:"implementation-with-time-analysis-8",children:"Implementation with Time Analysis"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nvoid binarySearchAnalysis() {\n    cout << "\\n=== Binary Search Analysis ===" << endl;\n    \n    // Demonstrate logarithmic growth\n    cout << "\\nSize (n)\\tlog\u2082(n)\\tMaximum Comparisons" << endl;\n    cout << "--------\\t-------\\t-------------------" << endl;\n    \n    int sizes[] = {10, 100, 1000, 10000, 100000, 1000000};\n    \n    for(int size : sizes) {\n        int maxComparisons = (int)log2(size) + 1;\n        cout << size << "\\t\\t" << (int)log2(size) << "\\t" << maxComparisons << endl;\n    }\n    \n    // Interactive binary search with step counting\n    cout << "\\n=== Binary Search Demonstration ===" << endl;\n    \n    vector<int> sortedArray;\n    for(int i = 0; i < 100; i++) {\n        sortedArray.push_back(i * 2); // Even numbers 0-198\n    }\n    \n    int target = 86;\n    cout << "Searching for " << target << " in sorted array of 100 elements" << endl;\n    \n    int left = 0, right = sortedArray.size() - 1;\n    int steps = 0;\n    bool found = false;\n    \n    while(left <= right) {\n        steps++;\n        int mid = left + (right - left) / 2;\n        \n        cout << "Step " << steps << ": ";\n        cout << "Search range [" << sortedArray[left] << "..." << sortedArray[right] << "]";\n        cout << ", Mid index = " << mid << ", Value = " << sortedArray[mid] << endl;\n        \n        if(sortedArray[mid] == target) {\n            cout << "Found at index " << mid << " in " << steps << " steps!" << endl;\n            found = true;\n            break;\n        } else if(sortedArray[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    \n    if(!found) {\n        cout << "Not found after " << steps << " steps." << endl;\n    }\n    \n    cout << "\\nTime Complexity Analysis:" << endl;\n    cout << "Recurrence: T(n) = T(n/2) + O(1)" << endl;\n    cout << "Solution: O(log n)" << endl;\n    cout << "Best Case: O(1) - middle element" << endl;\n    cout << "Worst/Average Case: O(log n)" << endl;\n    cout << "Space Complexity:" << endl;\n    cout << "  Iterative: O(1)" << endl;\n    cout << "  Recursive: O(log n) for call stack" << endl;\n    cout << "Prerequisite: Array must be sorted" << endl;\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"iterative-vs-recursive-binary-search",children:"Iterative vs Recursive Binary Search"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\nusing namespace std;\n\n// Iterative Binary Search\nint binarySearchIterative(int arr[], int n, int target, int& comparisons) {\n    int left = 0, right = n - 1;\n    \n    while(left <= right) {\n        comparisons++;\n        int mid = left + (right - left) / 2;\n        \n        if(arr[mid] == target) {\n            return mid;\n        } else if(arr[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    return -1;\n}\n\n// Recursive Binary Search\nint binarySearchRecursive(int arr[], int left, int right, int target, int& comparisons) {\n    comparisons++;\n    if(left > right) return -1;\n    \n    int mid = left + (right - left) / 2;\n    \n    if(arr[mid] == target) {\n        return mid;\n    } else if(arr[mid] < target) {\n        return binarySearchRecursive(arr, mid + 1, right, target, comparisons);\n    } else {\n        return binarySearchRecursive(arr, left, mid - 1, target, comparisons);\n    }\n}\n\nvoid compareBinarySearchMethods() {\n    cout << "\\n=== Iterative vs Recursive Binary Search ===" << endl;\n    \n    int arr[] = {2, 5, 8, 12, 16, 23, 38, 45, 56, 72, 91};\n    int n = sizeof(arr)/sizeof(arr[0]);\n    int target = 23;\n    \n    int iterComp = 0, recurComp = 0;\n    \n    int iterResult = binarySearchIterative(arr, n, target, iterComp);\n    int recurResult = binarySearchRecursive(arr, 0, n-1, target, recurComp);\n    \n    cout << "Array size: " << n << endl;\n    cout << "Target: " << target << endl;\n    cout << "\\nIterative Search:" << endl;\n    cout << "  Found at index: " << iterResult << endl;\n    cout << "  Comparisons: " << iterComp << endl;\n    cout << "  Space: O(1)" << endl;\n    \n    cout << "\\nRecursive Search:" << endl;\n    cout << "  Found at index: " << recurResult << endl;\n    cout << "  Comparisons: " << recurComp << endl;\n    cout << "  Space: O(log n) for call stack" << endl;\n    \n    cout << "\\nBoth have O(log n) time complexity!" << endl;\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"comprehensive-comparison-table",children:"Comprehensive Comparison Table"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <iomanip>\nusing namespace std;\n\nvoid comparisonTable() {\n    cout << "\\n=== Sorting Algorithms Comparison ===" << endl;\n    cout << "\\nAlgorithm\\t\\tBest\\t\\tAverage\\t\\tWorst\\t\\tSpace\\tStable" << endl;\n    cout << "---------\\t\\t----\\t\\t-------\\t\\t-----\\t\\t-----\\t-----" << endl;\n    \n    cout << left;\n    cout << setw(20) << "Bubble Sort" << setw(12) << "O(n)" << setw(12) << "O(n\xb2)" \n         << setw(12) << "O(n\xb2)" << setw(12) << "O(1)" << "Yes" << endl;\n    \n    cout << setw(20) << "Selection Sort" << setw(12) << "O(n\xb2)" << setw(12) << "O(n\xb2)" \n         << setw(12) << "O(n\xb2)" << setw(12) << "O(1)" << "No" << endl;\n    \n    cout << setw(20) << "Insertion Sort" << setw(12) << "O(n)" << setw(12) << "O(n\xb2)" \n         << setw(12) << "O(n\xb2)" << setw(12) << "O(1)" << "Yes" << endl;\n    \n    cout << setw(20) << "Quick Sort" << setw(12) << "O(n log n)" << setw(12) << "O(n log n)" \n         << setw(12) << "O(n\xb2)" << setw(12) << "O(log n)" << "No" << endl;\n    \n    cout << setw(20) << "Merge Sort" << setw(12) << "O(n log n)" << setw(12) << "O(n log n)" \n         << setw(12) << "O(n log n)" << setw(12) << "O(n)" << "Yes" << endl;\n    \n    cout << setw(20) << "Counting Sort" << setw(12) << "O(n + k)" << setw(12) << "O(n + k)" \n         << setw(12) << "O(n + k)" << setw(12) << "O(n + k)" << "Yes" << endl;\n    \n    cout << setw(20) << "Radix Sort" << setw(12) << "O(d(n + b))" << setw(12) << "O(d(n + b))" \n         << setw(12) << "O(d(n + b))" << setw(12) << "O(n + b)" << "Yes" << endl;\n    \n    cout << "\\n=== Searching Algorithms Comparison ===" << endl;\n    cout << "\\nAlgorithm\\t\\tBest\\t\\tAverage\\t\\tWorst\\t\\tSpace\\tRequires Sort" << endl;\n    cout << "---------\\t\\t----\\t\\t-------\\t\\t-----\\t\\t-----\\t-------------" << endl;\n    \n    cout << setw(20) << "Linear Search" << setw(12) << "O(1)" << setw(12) << "O(n)" \n         << setw(12) << "O(n)" << setw(12) << "O(1)" << "No" << endl;\n    \n    cout << setw(20) << "Binary Search" << setw(12) << "O(1)" << setw(12) << "O(log n)" \n         << setw(12) << "O(log n)" << setw(12) << "O(1)" << "Yes" << endl;\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"practical-guidelines-for-algorithm-selection",children:"Practical Guidelines for Algorithm Selection"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\nusing namespace std;\n\nvoid algorithmSelectionGuide() {\n    cout << "\\n=== Algorithm Selection Guide ===" << endl;\n    \n    cout << "\\nWhen to use which sorting algorithm:\\n" << endl;\n    \n    cout << "1. Small datasets (< 100 elements):" << endl;\n    cout << "   - Insertion Sort (simple, stable, good for nearly sorted)" << endl;\n    cout << "   - Bubble Sort (educational purposes only)" << endl;\n    \n    cout << "\\n2. Medium to large datasets:" << endl;\n    cout << "   - Quick Sort (general purpose, fastest average case)" << endl;\n    cout << "   - Merge Sort (stable, predictable O(n log n), good for linked lists)" << endl;\n    \n    cout << "\\n3. Special cases:" << endl;\n    cout << "   - Counting Sort (small integer range, k = O(n))" << endl;\n    cout << "   - Radix Sort (fixed-length integer keys)" << endl;\n    cout << "   - Selection Sort (when swaps are expensive)" << endl;\n    \n    cout << "\\nWhen to use which searching algorithm:\\n" << endl;\n    \n    cout << "1. Unsorted array:" << endl;\n    cout << "   - Linear Search (only option)" << endl;\n    \n    cout << "\\n2. Sorted array:" << endl;\n    cout << "   - Binary Search (most efficient, O(log n))" << endl;\n    cout << "   - Linear Search (if array is small)" << endl;\n    \n    cout << "\\n3. Multiple searches:" << endl;\n    cout << "   - Sort first (O(n log n)), then binary search (O(log n) each)" << endl;\n    cout << "   - Only beneficial if performing many searches" << endl;\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"complexity-classes-visualization",children:"Complexity Classes Visualization"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <cmath>\nusing namespace std;\n\nvoid complexityGraph() {\n    cout << "\\n=== Complexity Growth Visualization ===\\n" << endl;\n    cout << "n\\tO(1)\\tO(log n)\\tO(n)\\tO(n log n)\\tO(n\xb2)\\tO(2\u207f)" << endl;\n    cout << "-\\t----\\t--------\\t----\\t---------\\t----\\t----" << endl;\n    \n    for(int n = 2; n <= 32; n *= 2) {\n        cout << n << "\\t1";\n        cout << "\\t" << (int)log2(n);\n        cout << "\\t\\t" << n;\n        cout << "\\t" << (int)(n * log2(n));\n        cout << "\\t\\t" << n * n;\n        \n        if(pow(2, n) > 1000000) {\n            cout << "\\t>1M";\n        } else {\n            cout << "\\t" << (int)pow(2, n);\n        }\n        cout << endl;\n    }\n    \n    cout << "\\nTakeaway: Exponential algorithms become impractical quickly!" << endl;\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"time-complexity-in-practice",children:"Time Complexity in Practice"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <chrono>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nusing namespace std::chrono;\n\nvoid practicalTiming() {\n    cout << "\\n=== Practical Timing Examples ===" << endl;\n    \n    // Test different algorithms with increasing sizes\n    vector<int> sizes = {1000, 10000, 50000};\n    \n    for(int size : sizes) {\n        cout << "\\nArray size: " << size << endl;\n        \n        // Generate random array\n        vector<int> arr(size);\n        for(int i = 0; i < size; i++) {\n            arr[i] = rand() % 100000;\n        }\n        \n        // Test Linear Search (worst case)\n        auto start = high_resolution_clock::now();\n        linearSearch(arr.data(), size, -1); // Search for non-existent\n        auto stop = high_resolution_clock::now();\n        auto duration = duration_cast<microseconds>(stop - start);\n        cout << "Linear Search: " << duration.count() << " \u03bcs (O(n))" << endl;\n        \n        // Sort array for binary search\n        sort(arr.begin(), arr.end());\n        \n        // Test Binary Search\n        start = high_resolution_clock::now();\n        binary_search(arr.begin(), arr.end(), -1); // Search for non-existent\n        stop = high_resolution_clock::now();\n        duration = duration_cast<microseconds>(stop - start);\n        cout << "Binary Search: " << duration.count() << " \u03bcs (O(log n))" << endl;\n        \n        // The difference grows dramatically with size!\n    }\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Time Complexity Matters"}),": The difference between O(n\xb2) and O(n log n) is huge for large n"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Know Your Data"}),": Choose algorithms based on data characteristics (sorted, range, size)"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Best/Worst Cases"}),": Consider both for critical applications"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Space vs Time"}),": Often trade space for time (e.g., counting sort)"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Practical vs Theoretical"}),": Real-world performance depends on constants, cache, etc."]}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:"Understanding time complexity is essential for writing efficient code and is a fundamental skill for every programmer and computer scientist."})]})}function m(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(d,{...n})}):d(n)}},8453(n,e,i){i.d(e,{R:()=>o,x:()=>a});var t=i(6540);const r={},s=t.createContext(r);function o(n){const e=t.useContext(s);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function a(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:o(n.components),t.createElement(s.Provider,{value:e},n.children)}}}]);