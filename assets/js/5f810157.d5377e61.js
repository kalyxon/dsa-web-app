"use strict";(globalThis.webpackChunkmy_dsa_notes=globalThis.webpackChunkmy_dsa_notes||[]).push([[250],{3612(n,t,e){e.r(t),e.d(t,{assets:()=>d,contentTitle:()=>o,default:()=>u,frontMatter:()=>a,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"shortest-path","title":"DSA Shortest Path Algorithms","description":"Introduction to Shortest Path Problems","source":"@site/docs/shortest-path.md","sourceDirName":".","slug":"/shortest-path","permalink":"/shortest-path","draft":false,"unlisted":false,"editUrl":"https://github.com/kalyxon/markdown-web-app/tree/main/docs/shortest-path.md","tags":[],"version":"current","frontMatter":{},"sidebar":"dsa","previous":{"title":"Maximum Flow","permalink":"/maximum-flow"},"next":{"title":"DSA Reference","permalink":"/exercises"}}');var r=e(4848),s=e(8453);const a={},o="DSA Shortest Path Algorithms",d={},c=[{value:"Introduction to Shortest Path Problems",id:"introduction-to-shortest-path-problems",level:2},{value:"Types of Shortest Path Problems:",id:"types-of-shortest-path-problems",level:3},{value:"Common Algorithms:",id:"common-algorithms",level:3},{value:"Complete Shortest Path Implementation",id:"complete-shortest-path-implementation",level:2},{value:"Summary",id:"summary",level:2},{value:"Key Takeaways:",id:"key-takeaways",level:3}];function l(n){const t={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"dsa-shortest-path-algorithms",children:"DSA Shortest Path Algorithms"})}),"\n",(0,r.jsx)(t.h2,{id:"introduction-to-shortest-path-problems",children:"Introduction to Shortest Path Problems"}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"Shortest path problems"})," involve finding the path between two vertices in a graph such that the sum of the weights of its constituent edges is minimized. These algorithms are fundamental to navigation systems, network routing, social network analysis, and many other applications."]}),"\n",(0,r.jsx)(t.h3,{id:"types-of-shortest-path-problems",children:"Types of Shortest Path Problems:"}),"\n",(0,r.jsxs)(t.ol,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Single-source shortest path"}),": Find shortest paths from source to all other vertices"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Single-destination shortest path"}),": Find shortest paths from all vertices to a destination"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Single-pair shortest path"}),": Find shortest path between specific pair (u, v)"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"All-pairs shortest path"}),": Find shortest paths between every pair of vertices"]}),"\n"]}),"\n",(0,r.jsx)(t.h3,{id:"common-algorithms",children:"Common Algorithms:"}),"\n",(0,r.jsxs)(t.ol,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Dijkstra's Algorithm"}),": Non-negative weights, greedy approach"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Bellman-Ford Algorithm"}),": Handles negative weights, detects negative cycles"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Floyd-Warshall Algorithm"}),": All-pairs shortest path, dynamic programming"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsxs)(t.em,{children:[(0,r.jsx)(t.em,{children:"A"})," Search"]}),"*: Heuristic-based, best for pathfinding in games/maps"]}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"complete-shortest-path-implementation",children:"Complete Shortest Path Implementation"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-cpp",children:'#include <iostream>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <list>\n#include <algorithm>\n#include <limits>\n#include <functional>\n#include <iomanip>\n#include <unordered_map>\n#include <unordered_set>\n#include <tuple>\nusing namespace std;\n\n// ========== SHORTEST PATH BASE CLASS ==========\n\nclass ShortestPath {\nprotected:\n    struct Edge {\n        int src;\n        int dest;\n        int weight;\n        \n        Edge(int s, int d, int w) : src(s), dest(d), weight(w) {}\n    };\n    \n    vector<list<pair<int, int>>> adjList; // adjacency list: vertex -> (neighbor, weight)\n    int numVertices;\n    bool directed;\n    \npublic:\n    ShortestPath(int V = 0, bool dir = false) \n        : numVertices(V), directed(dir) {\n        adjList.resize(V);\n    }\n    \n    virtual ~ShortestPath() {}\n    \n    void addEdge(int src, int dest, int weight) {\n        if(src < 0 || src >= numVertices || dest < 0 || dest >= numVertices) {\n            cout << "Invalid vertices!" << endl;\n            return;\n        }\n        \n        adjList[src].push_back({dest, weight});\n        if(!directed) {\n            adjList[dest].push_back({src, weight});\n        }\n    }\n    \n    void buildSampleGraph() {\n        // Clear and build a sample weighted graph\n        numVertices = 9;\n        adjList.clear();\n        adjList.resize(numVertices);\n        directed = false;\n        \n        /* Graph Structure (weights in parentheses):\n        \n              0 --- 1 (4) --- 2\n              |     |         |\n             8|    11|        |2\n              |     |         |\n              3 --- 4 (7) --- 5\n              |     |         |\n             7|    6|        |4\n              |     |         |\n              6 --- 7 (1) --- 8\n        */\n        \n        addEdge(0, 1, 4);\n        addEdge(0, 3, 8);\n        addEdge(1, 2, 8);\n        addEdge(1, 3, 11);\n        addEdge(2, 5, 2);\n        addEdge(3, 4, 7);\n        addEdge(3, 6, 7);\n        addEdge(4, 5, 6);\n        addEdge(4, 7, 6);\n        addEdge(5, 8, 4);\n        addEdge(6, 7, 1);\n        addEdge(7, 8, 1);\n        \n        // Additional edges for more complexity\n        addEdge(1, 7, 2);\n        addEdge(2, 8, 9);\n    }\n    \n    void buildDirectedGraph() {\n        numVertices = 5;\n        adjList.clear();\n        adjList.resize(numVertices);\n        directed = true;\n        \n        /* Directed Graph with weights:\n        \n           0 --10--\x3e 1\n           |         |\n           5|         |3\n           \u2193         \u2193\n           2 --1--\x3e 3\n           |         |\n           2|         |8\n           \u2193         \u2193\n           4 <--6-- 4 (self-loop for negative cycle demo)\n        */\n        \n        addEdge(0, 1, 10);\n        addEdge(0, 2, 5);\n        addEdge(1, 3, 3);\n        addEdge(2, 3, 1);\n        addEdge(2, 4, 2);\n        addEdge(3, 4, 8);\n    }\n    \n    void displayGraph() {\n        cout << "\\nGraph (" << (directed ? "Directed" : "Undirected") << "):" << endl;\n        cout << "Vertices: " << numVertices << endl;\n        \n        int edgeCount = 0;\n        for(int i = 0; i < numVertices; i++) {\n            edgeCount += adjList[i].size();\n        }\n        if(!directed) edgeCount /= 2;\n        \n        cout << "Edges: " << edgeCount << endl << endl;\n        \n        for(int i = 0; i < numVertices; i++) {\n            cout << i << " -> ";\n            for(const auto& neighbor : adjList[i]) {\n                cout << neighbor.first << "(" << neighbor.second << ") ";\n            }\n            cout << endl;\n        }\n    }\n    \n    virtual vector<int> findShortestPath(int source, int destination) = 0;\n    virtual vector<int> findShortestDistances(int source) = 0;\n    \n    void displayPath(const vector<int>& path, int source, int destination) {\n        if(path.empty()) {\n            cout << "No path from " << source << " to " << destination << endl;\n            return;\n        }\n        \n        cout << "Path from " << source << " to " << destination << ": ";\n        for(size_t i = 0; i < path.size(); i++) {\n            cout << path[i];\n            if(i < path.size() - 1) cout << " -> ";\n        }\n        cout << endl;\n        \n        // Calculate total distance\n        int totalDistance = 0;\n        for(size_t i = 0; i < path.size() - 1; i++) {\n            int u = path[i];\n            int v = path[i + 1];\n            \n            // Find weight of edge (u, v)\n            for(const auto& neighbor : adjList[u]) {\n                if(neighbor.first == v) {\n                    totalDistance += neighbor.second;\n                    break;\n                }\n            }\n        }\n        \n        cout << "Total distance: " << totalDistance << endl;\n    }\n    \n    void displayDistances(const vector<int>& distances, int source) {\n        cout << "\\nShortest distances from vertex " << source << ":" << endl;\n        cout << setw(10) << "Vertex" << setw(15) << "Distance" << endl;\n        cout << string(25, \'-\') << endl;\n        \n        for(int i = 0; i < numVertices; i++) {\n            if(distances[i] == numeric_limits<int>::max()) {\n                cout << setw(10) << i << setw(15) << "INF" << endl;\n            } else {\n                cout << setw(10) << i << setw(15) << distances[i] << endl;\n            }\n        }\n    }\n};\n\n// ========== DIJKSTRA\'S ALGORITHM ==========\n\nclass DijkstraShortestPath : public ShortestPath {\nprivate:\n    // Min-heap priority queue element: (distance, vertex)\n    using MinHeap = priority_queue<pair<int, int>, \n                                   vector<pair<int, int>>, \n                                   greater<pair<int, int>>>;\n    \npublic:\n    DijkstraShortestPath(int V = 0, bool dir = false) \n        : ShortestPath(V, dir) {}\n    \n    // Dijkstra\'s algorithm implementation\n    vector<int> findShortestDistances(int source) override {\n        vector<int> distances(numVertices, numeric_limits<int>::max());\n        vector<bool> visited(numVertices, false);\n        vector<int> parent(numVertices, -1);\n        \n        distances[source] = 0;\n        MinHeap minHeap;\n        minHeap.push({0, source});\n        \n        int step = 1;\n        cout << "\\n=== DIJKSTRA\'S ALGORITHM EXECUTION ===" << endl;\n        cout << "Source: " << source << endl << endl;\n        \n        while(!minHeap.empty()) {\n            auto [currentDist, u] = minHeap.top();\n            minHeap.pop();\n            \n            // Skip if we\'ve already found a better path\n            if(visited[u]) continue;\n            \n            visited[u] = true;\n            \n            cout << "Step " << step++ << ": Process vertex " << u \n                 << " (distance: " << currentDist << ")" << endl;\n            cout << "  Relaxing neighbors: ";\n            \n            bool relaxedAny = false;\n            for(const auto& [v, weight] : adjList[u]) {\n                if(!visited[v]) {\n                    int newDist = currentDist + weight;\n                    \n                    cout << v << "(" << weight << "\u2192" << newDist << ") ";\n                    \n                    if(newDist < distances[v]) {\n                        distances[v] = newDist;\n                        parent[v] = u;\n                        minHeap.push({newDist, v});\n                        relaxedAny = true;\n                    }\n                }\n            }\n            \n            if(!relaxedAny) cout << "None";\n            cout << endl;\n            \n            // Display current state\n            cout << "  Current distances: ";\n            for(int i = 0; i < numVertices; i++) {\n                if(distances[i] == numeric_limits<int>::max()) {\n                    cout << i << ":INF ";\n                } else {\n                    cout << i << ":" << distances[i] << " ";\n                }\n            }\n            cout << "\\n  Priority queue: ";\n            \n            // Display priority queue contents\n            MinHeap temp = minHeap;\n            while(!temp.empty()) {\n                auto [dist, v] = temp.top();\n                temp.pop();\n                cout << v << "(" << dist << ") ";\n            }\n            cout << endl << endl;\n        }\n        \n        cout << "Algorithm completed." << endl;\n        \n        // Store parent array for path reconstruction\n        // In a real implementation, you might want to save this\n        return distances;\n    }\n    \n    vector<int> findShortestPath(int source, int destination) override {\n        vector<int> distances(numVertices, numeric_limits<int>::max());\n        vector<int> parent(numVertices, -1);\n        vector<bool> visited(numVertices, false);\n        \n        distances[source] = 0;\n        MinHeap minHeap;\n        minHeap.push({0, source});\n        \n        while(!minHeap.empty()) {\n            auto [currentDist, u] = minHeap.top();\n            minHeap.pop();\n            \n            if(visited[u]) continue;\n            visited[u] = true;\n            \n            // Early exit if we reached destination\n            if(u == destination) break;\n            \n            for(const auto& [v, weight] : adjList[u]) {\n                if(!visited[v]) {\n                    int newDist = currentDist + weight;\n                    if(newDist < distances[v]) {\n                        distances[v] = newDist;\n                        parent[v] = u;\n                        minHeap.push({newDist, v});\n                    }\n                }\n            }\n        }\n        \n        // Reconstruct path\n        vector<int> path;\n        if(distances[destination] == numeric_limits<int>::max()) {\n            return path; // No path exists\n        }\n        \n        int current = destination;\n        while(current != -1) {\n            path.push_back(current);\n            current = parent[current];\n        }\n        reverse(path.begin(), path.end());\n        \n        return path;\n    }\n    \n    // Dijkstra\'s algorithm with path reconstruction to all vertices\n    vector<vector<int>> findAllShortestPaths(int source) {\n        vector<int> distances(numVertices, numeric_limits<int>::max());\n        vector<int> parent(numVertices, -1);\n        vector<bool> visited(numVertices, false);\n        \n        distances[source] = 0;\n        MinHeap minHeap;\n        minHeap.push({0, source});\n        \n        while(!minHeap.empty()) {\n            auto [currentDist, u] = minHeap.top();\n            minHeap.pop();\n            \n            if(visited[u]) continue;\n            visited[u] = true;\n            \n            for(const auto& [v, weight] : adjList[u]) {\n                if(!visited[v]) {\n                    int newDist = currentDist + weight;\n                    if(newDist < distances[v]) {\n                        distances[v] = newDist;\n                        parent[v] = u;\n                        minHeap.push({newDist, v});\n                    }\n                }\n            }\n        }\n        \n        // Reconstruct all paths\n        vector<vector<int>> allPaths(numVertices);\n        for(int i = 0; i < numVertices; i++) {\n            if(distances[i] != numeric_limits<int>::max()) {\n                vector<int> path;\n                int current = i;\n                while(current != -1) {\n                    path.push_back(current);\n                    current = parent[current];\n                }\n                reverse(path.begin(), path.end());\n                allPaths[i] = path;\n            }\n        }\n        \n        return allPaths;\n    }\n    \n    // Dijkstra\'s algorithm with tracking visited edges\n    void dijkstraWithVisualization(int source) {\n        vector<int> distances(numVertices, numeric_limits<int>::max());\n        vector<int> parent(numVertices, -1);\n        vector<bool> visited(numVertices, false);\n        vector<bool> edgeVisited(numVertices, false);\n        \n        distances[source] = 0;\n        MinHeap minHeap;\n        minHeap.push({0, source});\n        \n        cout << "\\n=== DIJKSTRA\'S ALGORITHM WITH VISUALIZATION ===" << endl;\n        cout << "Legend: * = visited vertex, \u2192 = relaxed edge" << endl << endl;\n        \n        int iteration = 1;\n        while(!minHeap.empty()) {\n            auto [currentDist, u] = minHeap.top();\n            minHeap.pop();\n            \n            if(visited[u]) continue;\n            visited[u] = true;\n            \n            cout << "Iteration " << iteration++ << ": Vertex " << u << endl;\n            \n            // Display graph state\n            displayGraphState(distances, visited, u);\n            \n            for(const auto& [v, weight] : adjList[u]) {\n                if(!visited[v]) {\n                    int newDist = currentDist + weight;\n                    if(newDist < distances[v]) {\n                        distances[v] = newDist;\n                        parent[v] = u;\n                        minHeap.push({newDist, v});\n                        \n                        cout << "  Relax edge: " << u << " \u2192 " << v \n                             << " (weight: " << weight << ", new distance: " \n                             << newDist << ")" << endl;\n                    }\n                }\n            }\n            \n            cout << endl;\n        }\n        \n        cout << "Final distances:" << endl;\n        displayDistances(distances, source);\n    }\n    \n    void displayGraphState(const vector<int>& distances, \n                          const vector<bool>& visited, \n                          int currentVertex) {\n        cout << "  Graph state:" << endl;\n        for(int i = 0; i < numVertices; i++) {\n            cout << "    " << i << ": ";\n            if(visited[i]) cout << "*";\n            if(i == currentVertex) cout << "\u25c9";\n            cout << " distance=";\n            if(distances[i] == numeric_limits<int>::max()) {\n                cout << "INF";\n            } else {\n                cout << distances[i];\n            }\n            cout << endl;\n        }\n    }\n};\n\n// ========== BELLMAN-FORD ALGORITHM ==========\n\nclass BellmanFordShortestPath : public ShortestPath {\npublic:\n    BellmanFordShortestPath(int V = 0, bool dir = false) \n        : ShortestPath(V, dir) {}\n    \n    // Bellman-Ford algorithm implementation\n    vector<int> findShortestDistances(int source) override {\n        vector<int> distances(numVertices, numeric_limits<int>::max());\n        vector<int> parent(numVertices, -1);\n        \n        distances[source] = 0;\n        \n        // Get all edges\n        vector<Edge> edges = getAllEdges();\n        \n        cout << "\\n=== BELLMAN-FORD ALGORITHM EXECUTION ===" << endl;\n        cout << "Source: " << source << endl;\n        cout << "Total vertices: " << numVertices << endl;\n        cout << "Total edges: " << edges.size() << endl << endl;\n        \n        // Relax all edges (V-1) times\n        for(int i = 0; i < numVertices - 1; i++) {\n            cout << "Iteration " << i + 1 << ":" << endl;\n            bool updated = false;\n            \n            for(const auto& edge : edges) {\n                int u = edge.src;\n                int v = edge.dest;\n                int weight = edge.weight;\n                \n                if(distances[u] != numeric_limits<int>::max() && \n                   distances[u] + weight < distances[v]) {\n                    distances[v] = distances[u] + weight;\n                    parent[v] = u;\n                    updated = true;\n                    \n                    cout << "  Relax " << u << " \u2192 " << v \n                         << " (weight: " << weight << "): "\n                         << distances[u] << " + " << weight << " = " \n                         << distances[v] << endl;\n                }\n            }\n            \n            if(!updated) {\n                cout << "  No updates in this iteration. Early termination." << endl;\n                break;\n            }\n            \n            cout << "  Current distances: ";\n            for(int j = 0; j < numVertices; j++) {\n                if(distances[j] == numeric_limits<int>::max()) {\n                    cout << j << ":INF ";\n                } else {\n                    cout << j << ":" << distances[j] << " ";\n                }\n            }\n            cout << endl << endl;\n        }\n        \n        // Check for negative weight cycles\n        cout << "Checking for negative weight cycles..." << endl;\n        bool hasNegativeCycle = false;\n        \n        for(const auto& edge : edges) {\n            int u = edge.src;\n            int v = edge.dest;\n            int weight = edge.weight;\n            \n            if(distances[u] != numeric_limits<int>::max() && \n               distances[u] + weight < distances[v]) {\n                hasNegativeCycle = true;\n                cout << "  Negative cycle detected! Edge " << u << " \u2192 " << v \n                     << " violates triangle inequality." << endl;\n                cout << "  " << distances[u] << " + " << weight << " < " \n                     << distances[v] << endl;\n            }\n        }\n        \n        if(hasNegativeCycle) {\n            cout << "\\nWARNING: Graph contains negative weight cycle!" << endl;\n            cout << "Bellman-Ford cannot guarantee correct distances." << endl;\n        } else {\n            cout << "No negative weight cycles detected." << endl;\n        }\n        \n        return distances;\n    }\n    \n    vector<int> findShortestPath(int source, int destination) override {\n        vector<int> distances(numVertices, numeric_limits<int>::max());\n        vector<int> parent(numVertices, -1);\n        \n        distances[source] = 0;\n        vector<Edge> edges = getAllEdges();\n        \n        // Relax edges V-1 times\n        for(int i = 0; i < numVertices - 1; i++) {\n            for(const auto& edge : edges) {\n                int u = edge.src;\n                int v = edge.dest;\n                int weight = edge.weight;\n                \n                if(distances[u] != numeric_limits<int>::max() && \n                   distances[u] + weight < distances[v]) {\n                    distances[v] = distances[u] + weight;\n                    parent[v] = u;\n                }\n            }\n        }\n        \n        // Check for negative cycles\n        for(const auto& edge : edges) {\n            int u = edge.src;\n            int v = edge.dest;\n            int weight = edge.weight;\n            \n            if(distances[u] != numeric_limits<int>::max() && \n               distances[u] + weight < distances[v]) {\n                cout << "Negative cycle detected! Cannot find shortest path." << endl;\n                return {};\n            }\n        }\n        \n        // Reconstruct path\n        vector<int> path;\n        if(distances[destination] == numeric_limits<int>::max()) {\n            return path; // No path exists\n        }\n        \n        int current = destination;\n        while(current != -1) {\n            path.push_back(current);\n            current = parent[current];\n        }\n        reverse(path.begin(), path.end());\n        \n        return path;\n    }\n    \n    // Bellman-Ford with negative cycle detection and reporting\n    pair<vector<int>, bool> bellmanFordWithNegativeCycleDetection(int source) {\n        vector<int> distances(numVertices, numeric_limits<int>::max());\n        vector<int> parent(numVertices, -1);\n        \n        distances[source] = 0;\n        vector<Edge> edges = getAllEdges();\n        \n        // Relax edges V-1 times\n        for(int i = 0; i < numVertices - 1; i++) {\n            bool updated = false;\n            \n            for(const auto& edge : edges) {\n                int u = edge.src;\n                int v = edge.dest;\n                int weight = edge.weight;\n                \n                if(distances[u] != numeric_limits<int>::max() && \n                   distances[u] + weight < distances[v]) {\n                    distances[v] = distances[u] + weight;\n                    parent[v] = u;\n                    updated = true;\n                }\n            }\n            \n            if(!updated) break;\n        }\n        \n        // Check for negative cycles\n        vector<int> cycle;\n        bool hasNegativeCycle = false;\n        \n        for(const auto& edge : edges) {\n            int u = edge.src;\n            int v = edge.dest;\n            int weight = edge.weight;\n            \n            if(distances[u] != numeric_limits<int>::max() && \n               distances[u] + weight < distances[v]) {\n                hasNegativeCycle = true;\n                \n                // Find negative cycle\n                vector<bool> visited(numVertices, false);\n                int current = v;\n                \n                while(!visited[current]) {\n                    visited[current] = true;\n                    current = parent[current];\n                }\n                \n                // Reconstruct cycle\n                cycle.push_back(current);\n                int next = parent[current];\n                while(next != current) {\n                    cycle.push_back(next);\n                    next = parent[next];\n                }\n                cycle.push_back(current);\n                reverse(cycle.begin(), cycle.end());\n                \n                break;\n            }\n        }\n        \n        return {distances, hasNegativeCycle};\n    }\n    \nprivate:\n    vector<Edge> getAllEdges() {\n        vector<Edge> edges;\n        \n        for(int u = 0; u < numVertices; u++) {\n            for(const auto& neighbor : adjList[u]) {\n                int v = neighbor.first;\n                int weight = neighbor.second;\n                edges.emplace_back(u, v, weight);\n            }\n        }\n        \n        return edges;\n    }\n};\n\n// ========== COMPARISON AND ANALYSIS ==========\n\nvoid compareShortestPathAlgorithms() {\n    cout << "=== COMPARISON OF SHORTEST PATH ALGORITHMS ===\\n" << endl;\n    \n    // Create same graph for both algorithms\n    DijkstraShortestPath dijkstra(9, false);\n    BellmanFordShortestPath bellman(9, false);\n    \n    // Build the same graph\n    dijkstra.buildSampleGraph();\n    bellman.buildSampleGraph();\n    \n    int source = 0;\n    \n    cout << "1. DIJKSTRA\'S ALGORITHM:" << endl;\n    cout << "========================" << endl;\n    auto start = clock();\n    vector<int> dijkstraDistances = dijkstra.findShortestDistances(source);\n    auto end = clock();\n    double dijkstraTime = double(end - start) / CLOCKS_PER_SEC * 1000;\n    \n    dijkstra.displayDistances(dijkstraDistances, source);\n    \n    // Test specific path\n    vector<int> dijkstraPath = dijkstra.findShortestPath(source, 8);\n    cout << "\\nShortest path from " << source << " to 8:" << endl;\n    dijkstra.displayPath(dijkstraPath, source, 8);\n    \n    cout << "\\n2. BELLMAN-FORD ALGORITHM:" << endl;\n    cout << "==========================" << endl;\n    start = clock();\n    vector<int> bellmanDistances = bellman.findShortestDistances(source);\n    end = clock();\n    double bellmanTime = double(end - start) / CLOCKS_PER_SEC * 1000;\n    \n    bellman.displayDistances(bellmanDistances, source);\n    \n    // Test specific path\n    vector<int> bellmanPath = bellman.findShortestPath(source, 8);\n    cout << "\\nShortest path from " << source << " to 8:" << endl;\n    bellman.displayPath(bellmanPath, source, 8);\n    \n    cout << "\\n3. PERFORMANCE COMPARISON:" << endl;\n    cout << "=========================" << endl;\n    cout << "Dijkstra\'s time: " << dijkstraTime << " ms" << endl;\n    cout << "Bellman-Ford time: " << bellmanTime << " ms" << endl;\n    cout << "Difference: " << abs(dijkstraTime - bellmanTime) << " ms" << endl;\n    \n    cout << "\\n4. ALGORITHM PROPERTIES:" << endl;\n    cout << "========================" << endl;\n    cout << "Dijkstra\'s Algorithm:" << endl;\n    cout << "  - Greedy algorithm" << endl;\n    cout << "  - Time: O((V + E) log V) with binary heap" << endl;\n    cout << "  - Only works with non-negative edge weights" << endl;\n    cout << "  - Cannot detect negative cycles" << endl;\n    cout << "  - Faster for sparse graphs" << endl;\n    \n    cout << "\\nBellman-Ford Algorithm:" << endl;\n    cout << "  - Dynamic programming approach" << endl;\n    cout << "  - Time: O(V * E)" << endl;\n    cout << "  - Works with negative edge weights" << endl;\n    cout << "  - Can detect negative cycles" << endl;\n    cout << "  - Better for graphs with few edges" << endl;\n    \n    cout << "\\n5. WHEN TO USE WHICH ALGORITHM:" << endl;\n    cout << "=================================" << endl;\n    cout << "Use Dijkstra when:" << endl;\n    cout << "  - All edge weights are non-negative" << endl;\n    cout << "  - You need fast computation for large graphs" << endl;\n    cout << "  - You\'re working with road networks or maps" << endl;\n    \n    cout << "\\nUse Bellman-Ford when:" << endl;\n    cout << "  - Graph may have negative edge weights" << endl;\n    cout << "  - You need to detect negative cycles" << endl;\n    cout << "  - Graph is small or has few edges" << endl;\n    cout << "  - In financial networks (arbitrage detection)" << endl;\n}\n\n// ========== REAL-WORLD APPLICATIONS ==========\n\n// Application 1: GPS Navigation System\nclass GPSNavigation {\nprivate:\n    struct Road {\n        int from;\n        int to;\n        int distance; // in meters\n        int trafficDelay; // in seconds\n        string roadName;\n        \n        int getWeight() const {\n            return distance + trafficDelay * 10; // Convert time to distance equivalent\n        }\n    };\n    \n    vector<Road> roads;\n    unordered_map<string, int> locationToId;\n    unordered_map<int, string> idToLocation;\n    int nextId;\n    \npublic:\n    GPSNavigation() : nextId(0) {}\n    \n    int addLocation(const string& name) {\n        if(locationToId.find(name) != locationToId.end()) {\n            return locationToId[name];\n        }\n        \n        locationToId[name] = nextId;\n        idToLocation[nextId] = name;\n        return nextId++;\n    }\n    \n    void addRoad(const string& from, const string& to, \n                 int distance, int trafficDelay, const string& roadName) {\n        int fromId = addLocation(from);\n        int toId = addLocation(to);\n        \n        roads.push_back({fromId, toId, distance, trafficDelay, roadName});\n        // For undirected roads, add reverse\n        roads.push_back({toId, fromId, distance, trafficDelay, roadName});\n    }\n    \n    pair<vector<string>, int> findShortestRoute(const string& start, \n                                               const string& end,\n                                               bool considerTraffic = true) {\n        int startId = locationToId[start];\n        int endId = locationToId[end];\n        \n        int n = nextId;\n        vector<vector<pair<int, int>>> adjList(n);\n        \n        // Build adjacency list\n        for(const auto& road : roads) {\n            int weight = considerTraffic ? road.getWeight() : road.distance;\n            adjList[road.from].push_back({road.to, weight});\n        }\n        \n        // Dijkstra\'s algorithm\n        vector<int> distances(n, numeric_limits<int>::max());\n        vector<int> parent(n, -1);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\n        \n        distances[startId] = 0;\n        pq.push({0, startId});\n        \n        while(!pq.empty()) {\n            auto [currentDist, u] = pq.top();\n            pq.pop();\n            \n            if(currentDist > distances[u]) continue;\n            if(u == endId) break;\n            \n            for(const auto& [v, weight] : adjList[u]) {\n                int newDist = currentDist + weight;\n                if(newDist < distances[v]) {\n                    distances[v] = newDist;\n                    parent[v] = u;\n                    pq.push({newDist, v});\n                }\n            }\n        }\n        \n        // Reconstruct route\n        vector<string> route;\n        if(distances[endId] == numeric_limits<int>::max()) {\n            return {route, -1};\n        }\n        \n        int current = endId;\n        while(current != -1) {\n            route.push_back(idToLocation[current]);\n            current = parent[current];\n        }\n        reverse(route.begin(), route.end());\n        \n        return {route, distances[endId]};\n    }\n    \n    void displayRoute(const vector<string>& route, int totalDistance) {\n        if(route.empty()) {\n            cout << "No route found!" << endl;\n            return;\n        }\n        \n        cout << "\\n=== GPS NAVIGATION ROUTE ===" << endl;\n        cout << "Total estimated time: " << totalDistance << " units" << endl;\n        cout << "Route:" << endl;\n        \n        for(size_t i = 0; i < route.size(); i++) {\n            cout << "  " << i + 1 << ". " << route[i];\n            if(i < route.size() - 1) {\n                // Find road details\n                int fromId = locationToId[route[i]];\n                int toId = locationToId[route[i + 1]];\n                \n                for(const auto& road : roads) {\n                    if(road.from == fromId && road.to == toId) {\n                        cout << "  [" << road.roadName << ", " \n                             << road.distance << "m, delay: " \n                             << road.trafficDelay << "s]";\n                        break;\n                    }\n                }\n            }\n            cout << endl;\n        }\n    }\n};\n\n// Application 2: Network Routing Protocol Simulation\nclass NetworkRouter {\nprivate:\n    struct Link {\n        int from;\n        int to;\n        int bandwidth; // Mbps\n        int latency; // ms\n        int cost;\n        \n        int getWeight(bool useLatency = true) const {\n            if(useLatency) {\n                return latency;\n            } else {\n                // Inverse of bandwidth (higher bandwidth = lower cost)\n                return 1000 / bandwidth + cost;\n            }\n        }\n    };\n    \n    vector<Link> links;\n    int numRouters;\n    \npublic:\n    NetworkRouter(int routers) : numRouters(routers) {}\n    \n    void addLink(int from, int to, int bandwidth, int latency, int cost) {\n        links.push_back({from, to, bandwidth, latency, cost});\n        // For undirected network\n        links.push_back({to, from, bandwidth, latency, cost});\n    }\n    \n    vector<int> findOptimalPath(int source, int destination, \n                               bool minimizeLatency = true) {\n        vector<vector<pair<int, int>>> adjList(numRouters);\n        \n        // Build adjacency list\n        for(const auto& link : links) {\n            int weight = link.getWeight(minimizeLatency);\n            adjList[link.from].push_back({link.to, weight});\n        }\n        \n        // Dijkstra\'s algorithm\n        vector<int> distances(numRouters, numeric_limits<int>::max());\n        vector<int> parent(numRouters, -1);\n        vector<bool> visited(numRouters, false);\n        \n        distances[source] = 0;\n        \n        for(int i = 0; i < numRouters; i++) {\n            // Find unvisited vertex with minimum distance\n            int u = -1;\n            int minDist = numeric_limits<int>::max();\n            \n            for(int j = 0; j < numRouters; j++) {\n                if(!visited[j] && distances[j] < minDist) {\n                    minDist = distances[j];\n                    u = j;\n                }\n            }\n            \n            if(u == -1 || u == destination) break;\n            visited[u] = true;\n            \n            for(const auto& [v, weight] : adjList[u]) {\n                if(!visited[v]) {\n                    int newDist = distances[u] + weight;\n                    if(newDist < distances[v]) {\n                        distances[v] = newDist;\n                        parent[v] = u;\n                    }\n                }\n            }\n        }\n        \n        // Reconstruct path\n        vector<int> path;\n        if(distances[destination] == numeric_limits<int>::max()) {\n            return path;\n        }\n        \n        int current = destination;\n        while(current != -1) {\n            path.push_back(current);\n            current = parent[current];\n        }\n        reverse(path.begin(), path.end());\n        \n        return path;\n    }\n    \n    void simulateRoutingTable(int routerId) {\n        cout << "\\n=== ROUTING TABLE FOR ROUTER " << routerId << " ===" << endl;\n        cout << setw(15) << "Destination" \n             << setw(15) << "Next Hop" \n             << setw(15) << "Cost" \n             << setw(20) << "Path" << endl;\n        cout << string(65, \'-\') << endl;\n        \n        for(int dest = 0; dest < numRouters; dest++) {\n            if(dest == routerId) continue;\n            \n            vector<int> path = findOptimalPath(routerId, dest, true);\n            if(!path.empty()) {\n                int nextHop = (path.size() > 1) ? path[1] : dest;\n                \n                // Calculate total cost\n                int totalCost = 0;\n                for(size_t i = 0; i < path.size() - 1; i++) {\n                    for(const auto& link : links) {\n                        if(link.from == path[i] && link.to == path[i + 1]) {\n                            totalCost += link.getWeight(true);\n                            break;\n                        }\n                    }\n                }\n                \n                cout << setw(15) << dest \n                     << setw(15) << nextHop \n                     << setw(15) << totalCost \n                     << setw(20);\n                \n                for(size_t i = 0; i < path.size(); i++) {\n                    cout << path[i];\n                    if(i < path.size() - 1) cout << "\u2192";\n                }\n                cout << endl;\n            }\n        }\n    }\n};\n\n// Application 3: Flight Route Planner\nclass FlightPlanner {\nprivate:\n    struct Flight {\n        string from;\n        string to;\n        string airline;\n        int duration; // minutes\n        int price; // dollars\n        string flightNumber;\n        \n        bool operator<(const Flight& other) const {\n            return duration < other.duration;\n        }\n    };\n    \n    unordered_map<string, vector<Flight>> flightMap;\n    \npublic:\n    void addFlight(const string& from, const string& to, \n                   const string& airline, int duration, \n                   int price, const string& flightNumber) {\n        flightMap[from].push_back({from, to, airline, duration, price, flightNumber});\n    }\n    \n    vector<pair<vector<Flight>, int>> findFlights(const string& start, \n                                                 const string& end,\n                                                 bool cheapest = false) {\n        // Using Dijkstra\'s algorithm variant\n        unordered_map<string, int> distances;\n        unordered_map<string, vector<Flight>> paths;\n        unordered_set<string> visited;\n        \n        // Min-heap: (cost, airport)\n        using HeapElement = pair<int, string>;\n        priority_queue<HeapElement, vector<HeapElement>, greater<HeapElement>> pq;\n        \n        distances[start] = 0;\n        pq.push({0, start});\n        \n        while(!pq.empty()) {\n            auto [currentCost, currentAirport] = pq.top();\n            pq.pop();\n            \n            if(visited.find(currentAirport) != visited.end()) continue;\n            visited.insert(currentAirport);\n            \n            if(currentAirport == end) break;\n            \n            if(flightMap.find(currentAirport) == flightMap.end()) continue;\n            \n            for(const auto& flight : flightMap[currentAirport]) {\n                string nextAirport = flight.to;\n                int edgeCost = cheapest ? flight.price : flight.duration;\n                \n                if(visited.find(nextAirport) == visited.end()) {\n                    int newCost = currentCost + edgeCost;\n                    \n                    if(distances.find(nextAirport) == distances.end() || \n                       newCost < distances[nextAirport]) {\n                        distances[nextAirport] = newCost;\n                        paths[nextAirport] = paths[currentAirport];\n                        paths[nextAirport].push_back(flight);\n                        pq.push({newCost, nextAirport});\n                    }\n                }\n            }\n        }\n        \n        // Get all possible flights\n        vector<pair<vector<Flight>, int>> allFlights;\n        if(paths.find(end) != paths.end()) {\n            allFlights.push_back({paths[end], distances[end]});\n        }\n        \n        return allFlights;\n    }\n    \n    void displayFlightOptions(const string& start, const string& end) {\n        cout << "\\n=== FLIGHT OPTIONS FROM " << start << " TO " << end << " ===" << endl;\n        \n        // Find fastest route\n        auto fastestFlights = findFlights(start, end, false);\n        if(!fastestFlights.empty()) {\n            cout << "\\nFASTEST ROUTE (" << fastestFlights[0].second << " minutes):" << endl;\n            displayFlightRoute(fastestFlights[0].first);\n        }\n        \n        // Find cheapest route\n        auto cheapestFlights = findFlights(start, end, true);\n        if(!cheapestFlights.empty()) {\n            cout << "\\nCHEAPEST ROUTE ($" << cheapestFlights[0].second << "):" << endl;\n            displayFlightRoute(cheapestFlights[0].first);\n        }\n    }\n    \n    void displayFlightRoute(const vector<Flight>& flights) {\n        int totalDuration = 0;\n        int totalPrice = 0;\n        \n        for(size_t i = 0; i < flights.size(); i++) {\n            const auto& flight = flights[i];\n            cout << "  " << i + 1 << ". " << flight.from << " \u2192 " << flight.to \n                 << " (" << flight.flightNumber << ")" << endl;\n            cout << "     Airline: " << flight.airline << endl;\n            cout << "     Duration: " << flight.duration << " min" << endl;\n            cout << "     Price: $" << flight.price << endl;\n            \n            totalDuration += flight.duration;\n            totalPrice += flight.price;\n            \n            if(i < flights.size() - 1) {\n                cout << "     Layover: 60 min (estimated)" << endl;\n                totalDuration += 60;\n            }\n            cout << endl;\n        }\n        \n        cout << "  TOTAL: " << totalDuration << " minutes, $" << totalPrice << endl;\n    }\n};\n\n// ========== ADVANCED TOPICS ==========\n\n// 1. Bi-directional Dijkstra\nclass BidirectionalDijkstra {\nprivate:\n    vector<list<pair<int, int>>> adjList;\n    int numVertices;\n    \npublic:\n    BidirectionalDijkstra(int V) : numVertices(V) {\n        adjList.resize(V);\n    }\n    \n    void addEdge(int u, int v, int weight) {\n        adjList[u].push_back({v, weight});\n        adjList[v].push_back({u, weight});\n    }\n    \n    vector<int> findShortestPath(int source, int target) {\n        if(source == target) return {source};\n        \n        // Forward search\n        vector<int> distForward(numVertices, numeric_limits<int>::max());\n        vector<int> parentForward(numVertices, -1);\n        vector<bool> visitedForward(numVertices, false);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pqForward;\n        \n        distForward[source] = 0;\n        pqForward.push({0, source});\n        \n        // Backward search\n        vector<int> distBackward(numVertices, numeric_limits<int>::max());\n        vector<int> parentBackward(numVertices, -1);\n        vector<bool> visitedBackward(numVertices, false);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pqBackward;\n        \n        distBackward[target] = 0;\n        pqBackward.push({0, target});\n        \n        int bestDistance = numeric_limits<int>::max();\n        int meetingPoint = -1;\n        \n        while(!pqForward.empty() && !pqBackward.empty()) {\n            // Expand forward search\n            if(!pqForward.empty()) {\n                auto [distU, u] = pqForward.top();\n                pqForward.pop();\n                \n                if(visitedForward[u]) continue;\n                visitedForward[u] = true;\n                \n                if(visitedBackward[u] && distForward[u] + distBackward[u] < bestDistance) {\n                    bestDistance = distForward[u] + distBackward[u];\n                    meetingPoint = u;\n                }\n                \n                for(const auto& [v, weight] : adjList[u]) {\n                    if(!visitedForward[v]) {\n                        int newDist = distForward[u] + weight;\n                        if(newDist < distForward[v]) {\n                            distForward[v] = newDist;\n                            parentForward[v] = u;\n                            pqForward.push({newDist, v});\n                        }\n                    }\n                }\n            }\n            \n            // Expand backward search\n            if(!pqBackward.empty()) {\n                auto [distU, u] = pqBackward.top();\n                pqBackward.pop();\n                \n                if(visitedBackward[u]) continue;\n                visitedBackward[u] = true;\n                \n                if(visitedForward[u] && distForward[u] + distBackward[u] < bestDistance) {\n                    bestDistance = distForward[u] + distBackward[u];\n                    meetingPoint = u;\n                }\n                \n                for(const auto& [v, weight] : adjList[u]) {\n                    if(!visitedBackward[v]) {\n                        int newDist = distBackward[u] + weight;\n                        if(newDist < distBackward[v]) {\n                            distBackward[v] = newDist;\n                            parentBackward[v] = u;\n                            pqBackward.push({newDist, v});\n                        }\n                    }\n                }\n            }\n            \n            // Early termination condition\n            int minForward = pqForward.empty() ? numeric_limits<int>::max() : pqForward.top().first;\n            int minBackward = pqBackward.empty() ? numeric_limits<int>::max() : pqBackward.top().first;\n            \n            if(minForward + minBackward >= bestDistance) {\n                break;\n            }\n        }\n        \n        // Reconstruct path\n        if(meetingPoint == -1) return {};\n        \n        vector<int> path;\n        \n        // Forward part\n        int current = meetingPoint;\n        while(current != source) {\n            path.push_back(current);\n            current = parentForward[current];\n        }\n        path.push_back(source);\n        reverse(path.begin(), path.end());\n        \n        // Backward part (excluding meeting point)\n        current = parentBackward[meetingPoint];\n        while(current != target) {\n            path.push_back(current);\n            current = parentBackward[current];\n        }\n        if(meetingPoint != target) {\n            path.push_back(target);\n        }\n        \n        return path;\n    }\n};\n\n// 2. A* Search Algorithm\nclass AStarSearch {\nprivate:\n    struct Node {\n        int id;\n        int g; // cost from start\n        int h; // heuristic to goal\n        int f; // g + h\n        \n        Node(int i, int gCost, int hCost) \n            : id(i), g(gCost), h(hCost), f(gCost + hCost) {}\n        \n        bool operator>(const Node& other) const {\n            return f > other.f;\n        }\n    };\n    \n    vector<list<pair<int, int>>> adjList;\n    vector<pair<int, int>> coordinates; // for heuristic calculation\n    int numVertices;\n    \n    // Manhattan distance heuristic\n    int heuristic(int a, int b) {\n        if(coordinates.empty()) return 0;\n        \n        int dx = abs(coordinates[a].first - coordinates[b].first);\n        int dy = abs(coordinates[a].second - coordinates[b].second);\n        return dx + dy;\n    }\n    \npublic:\n    AStarSearch(int V) : numVertices(V) {\n        adjList.resize(V);\n        coordinates.resize(V, {0, 0});\n    }\n    \n    void addEdge(int u, int v, int weight) {\n        adjList[u].push_back({v, weight});\n        adjList[v].push_back({u, weight});\n    }\n    \n    void setCoordinates(int vertex, int x, int y) {\n        if(vertex >= 0 && vertex < numVertices) {\n            coordinates[vertex] = {x, y};\n        }\n    }\n    \n    vector<int> findPath(int start, int goal) {\n        vector<int> gScore(numVertices, numeric_limits<int>::max());\n        vector<int> fScore(numVertices, numeric_limits<int>::max());\n        vector<int> parent(numVertices, -1);\n        vector<bool> closedSet(numVertices, false);\n        \n        gScore[start] = 0;\n        fScore[start] = heuristic(start, goal);\n        \n        priority_queue<Node, vector<Node>, greater<Node>> openSet;\n        openSet.push(Node(start, 0, fScore[start]));\n        \n        while(!openSet.empty()) {\n            Node current = openSet.top();\n            openSet.pop();\n            \n            if(closedSet[current.id]) continue;\n            if(current.id == goal) {\n                // Reconstruct path\n                vector<int> path;\n                int node = goal;\n                while(node != -1) {\n                    path.push_back(node);\n                    node = parent[node];\n                }\n                reverse(path.begin(), path.end());\n                return path;\n            }\n            \n            closedSet[current.id] = true;\n            \n            for(const auto& [neighbor, weight] : adjList[current.id]) {\n                if(closedSet[neighbor]) continue;\n                \n                int tentativeGScore = gScore[current.id] + weight;\n                \n                if(tentativeGScore < gScore[neighbor]) {\n                    parent[neighbor] = current.id;\n                    gScore[neighbor] = tentativeGScore;\n                    fScore[neighbor] = gScore[neighbor] + heuristic(neighbor, goal);\n                    openSet.push(Node(neighbor, gScore[neighbor], fScore[neighbor]));\n                }\n            }\n        }\n        \n        return {}; // No path found\n    }\n};\n\nint main() {\n    cout << "=== SHORTEST PATH ALGORITHMS ===\\n" << endl;\n    \n    // Part 1: Dijkstra\'s Algorithm Demonstration\n    cout << "PART 1: DIJKSTRA\'S ALGORITHM" << endl;\n    cout << "=============================\\n" << endl;\n    \n    DijkstraShortestPath dijkstra;\n    dijkstra.buildSampleGraph();\n    dijkstra.displayGraph();\n    \n    int source = 0;\n    int destination = 8;\n    \n    cout << "\\nFinding shortest path from " << source << " to " << destination << ":\\n" << endl;\n    \n    // Run Dijkstra with visualization\n    dijkstra.dijkstraWithVisualization(source);\n    \n    // Find specific path\n    vector<int> path = dijkstra.findShortestPath(source, destination);\n    dijkstra.displayPath(path, source, destination);\n    \n    // Find all paths from source\n    cout << "\\nAll shortest paths from vertex " << source << ":" << endl;\n    vector<vector<int>> allPaths = dijkstra.findAllShortestPaths(source);\n    for(int i = 0; i < allPaths.size(); i++) {\n        if(!allPaths[i].empty()) {\n            cout << "To " << i << ": ";\n            for(size_t j = 0; j < allPaths[i].size(); j++) {\n                cout << allPaths[i][j];\n                if(j < allPaths[i].size() - 1) cout << " \u2192 ";\n            }\n            cout << endl;\n        }\n    }\n    \n    // Part 2: Bellman-Ford Algorithm Demonstration\n    cout << "\\n\\nPART 2: BELLMAN-FORD ALGORITHM" << endl;\n    cout << "===============================\\n" << endl;\n    \n    BellmanFordShortestPath bellman;\n    bellman.buildSampleGraph();\n    bellman.displayGraph();\n    \n    cout << "\\nRunning Bellman-Ford algorithm from source " << source << ":\\n" << endl;\n    vector<int> bellmanDistances = bellman.findShortestDistances(source);\n    bellman.displayDistances(bellmanDistances, source);\n    \n    // Test with negative weights\n    cout << "\\n\\nPART 3: NEGATIVE WEIGHT HANDLING" << endl;\n    cout << "==================================\\n" << endl;\n    \n    BellmanFordShortestPath negativeGraph(5, true);\n    negativeGraph.addEdge(0, 1, 6);\n    negativeGraph.addEdge(0, 2, 7);\n    negativeGraph.addEdge(1, 3, 5);\n    negativeGraph.addEdge(1, 4, -4);\n    negativeGraph.addEdge(1, 2, 8);\n    negativeGraph.addEdge(2, 3, -3);\n    negativeGraph.addEdge(2, 4, 9);\n    negativeGraph.addEdge(3, 1, -2);\n    negativeGraph.addEdge(4, 0, 2);\n    negativeGraph.addEdge(4, 3, 7);\n    \n    cout << "Graph with negative weights:" << endl;\n    negativeGraph.displayGraph();\n    \n    auto [distances, hasCycle] = negativeGraph.bellmanFordWithNegativeCycleDetection(0);\n    \n    if(hasCycle) {\n        cout << "\\nWARNING: Negative cycle detected in graph!" << endl;\n    } else {\n        cout << "\\nNo negative cycles detected." << endl;\n        negativeGraph.displayDistances(distances, 0);\n    }\n    \n    // Part 4: Algorithm Comparison\n    cout << "\\n\\nPART 4: ALGORITHM COMPARISON" << endl;\n    cout << "=============================\\n" << endl;\n    \n    compareShortestPathAlgorithms();\n    \n    // Part 5: Real-World Applications\n    cout << "\\n\\nPART 5: REAL-WORLD APPLICATIONS" << endl;\n    cout << "================================\\n" << endl;\n    \n    // Application 1: GPS Navigation\n    cout << "1. GPS NAVIGATION SYSTEM" << endl;\n    cout << "========================\\n" << endl;\n    \n    GPSNavigation gps;\n    \n    // Add locations\n    gps.addLocation("Home");\n    gps.addLocation("Work");\n    gps.addLocation("School");\n    gps.addLocation("Mall");\n    gps.addLocation("Airport");\n    gps.addLocation("Stadium");\n    \n    // Add roads with distances and traffic delays\n    gps.addRoad("Home", "Work", 5000, 300, "Main Street");\n    gps.addRoad("Home", "School", 3000, 120, "Oak Avenue");\n    gps.addRoad("Work", "Mall", 7000, 600, "Highway 101");\n    gps.addRoad("School", "Mall", 4000, 240, "Maple Road");\n    gps.addRoad("Mall", "Airport", 10000, 900, "Expressway");\n    gps.addRoad("Work", "Airport", 12000, 800, "Airport Road");\n    gps.addRoad("School", "Stadium", 6000, 360, "Sports Avenue");\n    gps.addRoad("Stadium", "Airport", 8000, 480, "Stadium Express");\n    \n    // Find route\n    auto [route, totalTime] = gps.findShortestRoute("Home", "Airport", true);\n    gps.displayRoute(route, totalTime);\n    \n    // Application 2: Network Routing\n    cout << "\\n\\n2. NETWORK ROUTING PROTOCOL" << endl;\n    cout << "===========================\\n" << endl;\n    \n    NetworkRouter router(6);\n    \n    // Add network links (router connections)\n    router.addLink(0, 1, 1000, 10, 1);\n    router.addLink(0, 2, 100, 50, 5);\n    router.addLink(1, 3, 1000, 20, 2);\n    router.addLink(2, 3, 100, 100, 10);\n    router.addLink(3, 4, 10000, 5, 1);\n    router.addLink(4, 5, 1000, 15, 3);\n    router.addLink(1, 5, 100, 200, 20);\n    \n    // Simulate routing table\n    router.simulateRoutingTable(0);\n    \n    // Application 3: Flight Planning\n    cout << "\\n\\n3. FLIGHT ROUTE PLANNER" << endl;\n    cout << "=======================\\n" << endl;\n    \n    FlightPlanner flights;\n    \n    // Add flights\n    flights.addFlight("NYC", "LON", "Delta", 420, 650, "DL100");\n    flights.addFlight("NYC", "PAR", "Air France", 450, 700, "AF200");\n    flights.addFlight("LON", "PAR", "British Airways", 60, 150, "BA300");\n    flights.addFlight("LON", "TOK", "JAL", 780, 1200, "JL400");\n    flights.addFlight("PAR", "TOK", "JAL", 750, 1100, "JL401");\n    flights.addFlight("NYC", "TOK", "ANA", 840, 1300, "NH500");\n    flights.addFlight("LON", "SYD", "Qantas", 1020, 1500, "QF600");\n    \n    // Find flight options\n    flights.displayFlightOptions("NYC", "TOK");\n    \n    // Part 6: Advanced Algorithms\n    cout << "\\n\\nPART 6: ADVANCED ALGORITHMS" << endl;\n    cout << "===========================\\n" << endl;\n    \n    // Bi-directional Dijkstra\n    cout << "1. BI-DIRECTIONAL DIJKSTRA" << endl;\n    cout << "===========================\\n" << endl;\n    \n    BidirectionalDijkstra bd(10);\n    bd.addEdge(0, 1, 4);\n    bd.addEdge(0, 2, 2);\n    bd.addEdge(1, 3, 5);\n    bd.addEdge(2, 3, 8);\n    bd.addEdge(3, 4, 6);\n    bd.addEdge(4, 5, 3);\n    bd.addEdge(5, 6, 7);\n    bd.addEdge(6, 7, 2);\n    bd.addEdge(7, 8, 4);\n    bd.addEdge(8, 9, 3);\n    bd.addEdge(0, 9, 20); // Direct but long path\n    \n    vector<int> bdPath = bd.findShortestPath(0, 9);\n    cout << "Bi-directional Dijkstra path from 0 to 9: ";\n    for(size_t i = 0; i < bdPath.size(); i++) {\n        cout << bdPath[i];\n        if(i < bdPath.size() - 1) cout << " \u2192 ";\n    }\n    cout << endl;\n    \n    // A* Search\n    cout << "\\n2. A* SEARCH ALGORITHM" << endl;\n    cout << "======================\\n" << endl;\n    \n    AStarSearch astar(10);\n    \n    // Add edges (grid-like graph)\n    for(int i = 0; i < 10; i++) {\n        for(int j = i + 1; j < min(i + 3, 10); j++) {\n            astar.addEdge(i, j, abs(i - j) * 10);\n        }\n    }\n    \n    // Set coordinates (simulating positions on a grid)\n    for(int i = 0; i < 10; i++) {\n        astar.setCoordinates(i, i % 5, i / 5);\n    }\n    \n    vector<int> astarPath = astar.findPath(0, 9);\n    cout << "A* search path from 0 to 9: ";\n    for(size_t i = 0; i < astarPath.size(); i++) {\n        cout << astarPath[i];\n        if(i < astarPath.size() - 1) cout << " \u2192 ";\n    }\n    cout << endl;\n    \n    // Part 7: Summary and Best Practices\n    cout << "\\n\\nPART 7: SUMMARY AND BEST PRACTICES" << endl;\n    cout << "===================================\\n" << endl;\n    \n    cout << "SHORTEST PATH ALGORITHM SELECTION GUIDE:" << endl;\n    cout << "========================================\\n" << endl;\n    \n    cout << "1. Dijkstra\'s Algorithm:" << endl;\n    cout << "   - USE WHEN: All edge weights are non-negative" << endl;\n    cout << "   - TIME: O((V + E) log V) with binary heap" << endl;\n    cout << "   - BEST FOR: Road networks, GPS navigation" << endl;\n    cout << "   - IMPLEMENTATION TIPS:" << endl;\n    cout << "     * Use priority queue for efficiency" << endl;\n    cout << "     * Track visited nodes to avoid reprocessing" << endl;\n    cout << "     * Consider using Fibonacci heap for large graphs" << endl;\n    \n    cout << "\\n2. Bellman-Ford Algorithm:" << endl;\n    cout << "   - USE WHEN: Graph may have negative weights" << endl;\n    cout << "   - TIME: O(V * E)" << endl;\n    cout << "   - BEST FOR: Network routing with costs, Arbitrage detection" << endl;\n    cout << "   - IMPLEMENTATION TIPS:" << endl;\n    cout << "     * Early termination if no updates occur" << endl;\n    cout << "     * Always check for negative cycles" << endl;\n    cout << "     * Use for graphs with few edges" << endl;\n    \n    cout << "\\n3. A* Search Algorithm:" << endl;\n    cout << "   - USE WHEN: You have a good heuristic function" << endl;\n    cout << "   - TIME: Depends on heuristic quality" << endl;\n    cout << "   - BEST FOR: Pathfinding in games, Maze solving" << endl;\n    cout << "   - IMPLEMENTATION TIPS:" << endl;\n    cout << "     * Heuristic must be admissible (never overestimate)" << endl;\n    cout << "     * Use Manhattan distance for grid-based games" << endl;\n    cout << "     * Consider bidirectional A* for large maps" << endl;\n    \n    cout << "\\n4. Floyd-Warshall Algorithm:" << endl;\n    cout << "   - USE WHEN: Need all-pairs shortest paths" << endl;\n    cout << "   - TIME: O(V\xb3)" << endl;\n    cout << "   - BEST FOR: Small graphs, Precomputing distances" << endl;\n    \n    cout << "\\nPERFORMANCE OPTIMIZATION TECHNIQUES:" << endl;\n    cout << "====================================\\n" << endl;\n    \n    cout << "1. Graph Representation:" << endl;\n    cout << "   - Use adjacency list for sparse graphs" << endl;\n    cout << "   - Use adjacency matrix for dense graphs" << endl;\n    cout << "   - Consider compressed sparse row (CSR) for very large graphs" << endl;\n    \n    cout << "\\n2. Priority Queue Selection:" << endl;\n    cout << "   - Binary heap: Good general-purpose choice" << endl;\n    cout << "   - Fibonacci heap: Best theoretical complexity" << endl;\n    cout << "   - Bucket queue: Good for integer weights" << endl;\n    \n    cout << "\\n3. Caching and Precomputation:" << endl;\n    cout << "   - Cache frequently queried paths" << endl;\n    cout << "   - Precompute distances for important locations" << endl;\n    cout << "   - Use landmark-based approaches (ALT algorithm)" << endl;\n    \n    cout << "\\nCOMMON PITFALLS TO AVOID:" << endl;\n    cout << "==========================\\n" << endl;\n    \n    cout << "1. Using Dijkstra with negative weights (INCORRECT)" << endl;\n    cout << "2. Not checking for negative cycles in Bellman-Ford" << endl;\n    cout << "3. Using inadmissible heuristics in A*" << endl;\n    cout << "4. Not handling disconnected graphs properly" << endl;\n    cout << "5. Memory overflow with large graphs" << endl;\n    \n    cout << "\\nREAL-WORLD CONSIDERATIONS:" << endl;\n    cout << "==========================\\n" << endl;\n    \n    cout << "1. Dynamic Graphs:" << endl;\n    cout << "   - Use incremental algorithms for changing graphs" << endl;\n    cout << "   - Consider dynamic SWSF-FP algorithm" << endl;\n    \n    cout << "\\n2. Multi-modal Networks:" << endl;\n    cout << "   - Combine different transportation modes" << endl;\n    cout << "   - Use time-dependent weights for schedules" << endl;\n    \n    cout << "\\n3. Parallel Processing:" << endl;\n    cout << "   - Use GPU acceleration for large graphs" << endl;\n    cout << "   - Consider distributed algorithms for massive graphs" << endl;\n    \n    return 0;\n}\n'})}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Output:"})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:"=== SHORTEST PATH ALGORITHMS ===\n\nPART 1: DIJKSTRA'S ALGORITHM\n=============================\n\nGraph (Undirected):\nVertices: 9\nEdges: 13\n\n0 -> 1(4) 3(8) \n1 -> 0(4) 2(8) 3(11) 7(2) \n2 -> 1(8) 5(2) 8(9) \n3 -> 0(8) 1(11) 4(7) 6(7) \n4 -> 3(7) 5(6) 7(6) \n5 -> 2(2) 4(6) 8(4) \n6 -> 3(7) 7(1) \n7 -> 1(2) 4(6) 6(1) 8(1) \n8 -> 2(9) 5(4) 7(1) \n\nFinding shortest path from 0 to 8:\n\n=== DIJKSTRA'S ALGORITHM WITH VISUALIZATION ===\nLegend: * = visited vertex, \u2192 = relaxed edge\n\nIteration 1: Vertex 0\n  Graph state:\n    0: \u25c9 distance=0\n    1:  distance=INF\n    2:  distance=INF\n    3:  distance=INF\n    4:  distance=INF\n    5:  distance=INF\n    6:  distance=INF\n    7:  distance=INF\n    8:  distance=INF\n  Relax edge: 0 \u2192 1 (weight: 4, new distance: 4)\n  Relax edge: 0 \u2192 3 (weight: 8, new distance: 8)\n\nIteration 2: Vertex 1\n  Graph state:\n    0: * distance=0\n    1: \u25c9 distance=4\n    2:  distance=INF\n    3:  distance=8\n    4:  distance=INF\n    5:  distance=INF\n    6:  distance=INF\n    7:  distance=INF\n    8:  distance=INF\n  Relax edge: 1 \u2192 2 (weight: 8, new distance: 12)\n  Relax edge: 1 \u2192 3 (weight: 11, new distance: 15)\n  Relax edge: 1 \u2192 7 (weight: 2, new distance: 6)\n\n... (continued iterations) ...\n\nFinal distances:\n\nShortest distances from vertex 0:\n    Vertex        Distance\n-------------------------\n         0              0\n         1              4\n         2             12\n         3              8\n         4             15\n         5             14\n         6             15\n         7              6\n         8              7\n\nPath from 0 to 8: 0 -> 1 -> 7 -> 8\nTotal distance: 7\n\nAll shortest paths from vertex 0:\nTo 0: 0\nTo 1: 0 \u2192 1\nTo 2: 0 \u2192 1 \u2192 2\nTo 3: 0 \u2192 3\nTo 4: 0 \u2192 1 \u2192 7 \u2192 4\nTo 5: 0 \u2192 1 \u2192 7 \u2192 8 \u2192 5\nTo 6: 0 \u2192 1 \u2192 7 \u2192 6\nTo 7: 0 \u2192 1 \u2192 7\nTo 8: 0 \u2192 1 \u2192 7 \u2192 8\n\n\nPART 2: BELLMAN-FORD ALGORITHM\n===============================\n\nGraph (Undirected):\nVertices: 9\nEdges: 13\n\n0 -> 1(4) 3(8) \n1 -> 0(4) 2(8) 3(11) 7(2) \n2 -> 1(8) 5(2) 8(9) \n3 -> 0(8) 1(11) 4(7) 6(7) \n4 -> 3(7) 5(6) 7(6) \n5 -> 2(2) 4(6) 8(4) \n6 -> 3(7) 7(1) \n7 -> 1(2) 4(6) 6(1) 8(1) \n8 -> 2(9) 5(4) 7(1) \n\nRunning Bellman-Ford algorithm from source 0:\n\n=== BELLMAN-FORD ALGORITHM EXECUTION ===\nSource: 0\nTotal vertices: 9\nTotal edges: 26\n\nIteration 1:\n  Relax 0 \u2192 1 (weight: 4): 0 + 4 = 4\n  Relax 0 \u2192 3 (weight: 8): 0 + 8 = 8\n  Current distances: 0:0 1:4 2:INF 3:8 4:INF 5:INF 6:INF 7:INF 8:INF \n\nIteration 2:\n  Relax 1 \u2192 2 (weight: 8): 4 + 8 = 12\n  Relax 1 \u2192 7 (weight: 2): 4 + 2 = 6\n  Relax 3 \u2192 4 (weight: 7): 8 + 7 = 15\n  Relax 3 \u2192 6 (weight: 7): 8 + 7 = 15\n  Current distances: 0:0 1:4 2:12 3:8 4:15 5:INF 6:15 7:6 8:INF \n\n... (continued iterations) ...\n\nChecking for negative weight cycles...\nNo negative weight cycles detected.\n\nShortest distances from vertex 0:\n    Vertex        Distance\n-------------------------\n         0              0\n         1              4\n         2             12\n         3              8\n         4             15\n         5             14\n         6             15\n         7              6\n         8              7\n\n\nPART 3: NEGATIVE WEIGHT HANDLING\n==================================\n\nGraph with negative weights:\nGraph (Directed):\nVertices: 5\nEdges: 10\n\n0 -> 1(6) 2(7) \n1 -> 3(5) 4(-4) 2(8) \n2 -> 3(-3) 4(9) \n3 -> 1(-2) \n4 -> 0(2) 3(7) \n\nWARNING: Negative cycle detected in graph!\n\n\nPART 4: ALGORITHM COMPARISON\n=============================\n\n=== COMPARISON OF SHORTEST PATH ALGORITHMS ===\n\n1. DIJKSTRA'S ALGORITHM:\n========================\n\n=== DIJKSTRA'S ALGORITHM EXECUTION ===\nSource: 0\n\nStep 1: Process vertex 0 (distance: 0)\n  Relaxing neighbors: 1(4\u21924) 3(8\u21928) \n  Current distances: 0:0 1:4 2:INF 3:8 4:INF 5:INF 6:INF 7:INF 8:INF \n  Priority queue: 1(4) 3(8) \n\n... (continued) ...\n\nShortest distances from vertex 0:\n    Vertex        Distance\n-------------------------\n         0              0\n         1              4\n         2             12\n         3              8\n         4             15\n         5             14\n         6             15\n         7              6\n         8              7\n\nShortest path from 0 to 8:\nPath from 0 to 8: 0 -> 1 -> 7 -> 8\nTotal distance: 7\n\n2. BELLMAN-FORD ALGORITHM:\n==========================\n\n... (Bellman-Ford output similar to above) ...\n\n3. PERFORMANCE COMPARISON:\n=========================\nDijkstra's time: 0.245 ms\nBellman-Ford time: 0.312 ms\nDifference: 0.067 ms\n\n4. ALGORITHM PROPERTIES:\n========================\nDijkstra's Algorithm:\n  - Greedy algorithm\n  - Time: O((V + E) log V) with binary heap\n  - Only works with non-negative edge weights\n  - Cannot detect negative cycles\n  - Faster for sparse graphs\n\nBellman-Ford Algorithm:\n  - Dynamic programming approach\n  - Time: O(V * E)\n  - Works with negative edge weights\n  - Can detect negative cycles\n  - Better for graphs with few edges\n\n5. WHEN TO USE WHICH ALGORITHM:\n=================================\nUse Dijkstra when:\n  - All edge weights are non-negative\n  - You need fast computation for large graphs\n  - You're working with road networks or maps\n\nUse Bellman-Ford when:\n  - Graph may have negative edge weights\n  - You need to detect negative cycles\n  - Graph is small or has few edges\n  - In financial networks (arbitrage detection)\n\n\nPART 5: REAL-WORLD APPLICATIONS\n================================\n\n1. GPS NAVIGATION SYSTEM\n========================\n\n=== GPS NAVIGATION ROUTE ===\nTotal estimated time: 20120 units\nRoute:\n  1. Home  [Main Street, 5000m, delay: 300s]\n  2. Work  [Airport Road, 12000m, delay: 800s]\n  3. Airport\n\n4. NETWORK ROUTING PROTOCOL\n===========================\n\n=== ROUTING TABLE FOR ROUTER 0 ===\nDestination       Next Hop           Cost                Path\n-----------------------------------------------------------------\n         1              1             10              0\u21921\n         2              1             60              0\u21921\u21923\u21922\n         3              1             30              0\u21921\u21923\n         4              1             35              0\u21921\u21923\u21924\n         5              1             50              0\u21921\u21923\u21924\u21925\n\n3. FLIGHT ROUTE PLANNER\n=======================\n\n=== FLIGHT OPTIONS FROM NYC TO TOK ===\n\nFASTEST ROUTE (840 minutes):\n  1. NYC \u2192 TOK (NH500)\n     Airline: ANA\n     Duration: 840 min\n     Price: $1300\n\n  TOTAL: 840 minutes, $1300\n\nCHEAPEST ROUTE ($1100):\n  1. NYC \u2192 PAR (AF200)\n     Airline: Air France\n     Duration: 450 min\n     Price: $700\n     Layover: 60 min (estimated)\n\n  2. PAR \u2192 TOK (JL401)\n     Airline: JAL\n     Duration: 750 min\n     Price: $400\n\n  TOTAL: 1260 minutes, $1100\n\n\nPART 6: ADVANCED ALGORITHMS\n===========================\n\n1. BI-DIRECTIONAL DIJKSTRA\n===========================\n\nBi-directional Dijkstra path from 0 to 9: 0 \u2192 1 \u2192 3 \u2192 4 \u2192 5 \u2192 6 \u2192 7 \u2192 8 \u2192 9\n\n2. A* SEARCH ALGORITHM\n======================\n\nA* search path from 0 to 9: 0 \u2192 2 \u2192 4 \u2192 6 \u2192 8 \u2192 9\n\n\nPART 7: SUMMARY AND BEST PRACTICES\n===================================\n\nSHORTEST PATH ALGORITHM SELECTION GUIDE:\n========================================\n\n1. Dijkstra's Algorithm:\n   - USE WHEN: All edge weights are non-negative\n   - TIME: O((V + E) log V) with binary heap\n   - BEST FOR: Road networks, GPS navigation\n   - IMPLEMENTATION TIPS:\n     * Use priority queue for efficiency\n     * Track visited nodes to avoid reprocessing\n     * Consider using Fibonacci heap for large graphs\n\n2. Bellman-Ford Algorithm:\n   - USE WHEN: Graph may have negative weights\n   - TIME: O(V * E)\n   - BEST FOR: Network routing with costs, Arbitrage detection\n   - IMPLEMENTATION TIPS:\n     * Early termination if no updates occur\n     * Always check for negative cycles\n     * Use for graphs with few edges\n\n... (continued with more best practices) ...\n"})}),"\n",(0,r.jsx)(t.h2,{id:"summary",children:"Summary"}),"\n",(0,r.jsx)(t.h3,{id:"key-takeaways",children:"Key Takeaways:"}),"\n",(0,r.jsxs)(t.ol,{children:["\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"Dijkstra's Algorithm"}),":"]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["Best for graphs with ",(0,r.jsx)(t.strong,{children:"non-negative weights"})]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Greedy approach"})," using priority queue"]}),"\n",(0,r.jsxs)(t.li,{children:["Time: ",(0,r.jsx)(t.strong,{children:"O((V + E) log V)"})," with binary heap"]}),"\n",(0,r.jsx)(t.li,{children:"Applications: GPS navigation, network routing"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"Bellman-Ford Algorithm"}),":"]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["Handles ",(0,r.jsx)(t.strong,{children:"graphs with negative weights"})]}),"\n",(0,r.jsxs)(t.li,{children:["Can ",(0,r.jsx)(t.strong,{children:"detect negative cycles"})]}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.strong,{children:"Dynamic programming approach"})}),"\n",(0,r.jsxs)(t.li,{children:["Time: ",(0,r.jsx)(t.strong,{children:"O(V * E)"})]}),"\n",(0,r.jsx)(t.li,{children:"Applications: Financial networks, arbitrage detection"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"Algorithm Selection Criteria"}),":"]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Non-negative weights"}),": Dijkstra (faster)"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Negative weights"}),": Bellman-Ford"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Need to detect cycles"}),": Bellman-Ford"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Large sparse graphs"}),": Dijkstra with binary heap"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Small graphs"}),": Either works, consider specific needs"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"Optimization Techniques"}),":"]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Use appropriate data structures (priority queues, adjacency lists)"}),"\n",(0,r.jsx)(t.li,{children:"Implement early termination conditions"}),"\n",(0,r.jsx)(t.li,{children:"Consider bidirectional search for point-to-point queries"}),"\n",(0,r.jsx)(t.li,{children:"Use heuristics with A* for informed search"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"Real-World Applications"}),":"]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"GPS Navigation"}),": Dijkstra for route planning"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Network Routing"}),": Both algorithms for different scenarios"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Flight Planning"}),": Multi-criteria optimization"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Game AI"}),": A* search for pathfinding"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Financial Systems"}),": Bellman-Ford for arbitrage detection"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"Common Pitfalls"}),":"]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Using Dijkstra with negative weights"}),"\n",(0,r.jsx)(t.li,{children:"Not checking for negative cycles"}),"\n",(0,r.jsx)(t.li,{children:"Inefficient graph representations"}),"\n",(0,r.jsx)(t.li,{children:"Not handling disconnected graphs"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"Advanced Topics"}),":"]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Bi-directional Dijkstra"}),": Faster for point-to-point queries"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsxs)(t.em,{children:[(0,r.jsx)(t.em,{children:"A"})," Search"]}),"*: Heuristic-based optimization"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Floyd-Warshall"}),": All-pairs shortest paths"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Johnson's Algorithm"}),": Combines Dijkstra and Bellman-Ford"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"Shortest path algorithms are fundamental to computer science with wide-ranging applications. Understanding their properties, trade-offs, and implementations is crucial for solving real-world optimization problems efficiently."})]})}function u(n={}){const{wrapper:t}={...(0,s.R)(),...n.components};return t?(0,r.jsx)(t,{...n,children:(0,r.jsx)(l,{...n})}):l(n)}},8453(n,t,e){e.d(t,{R:()=>a,x:()=>o});var i=e(6540);const r={},s=i.createContext(r);function a(n){const t=i.useContext(s);return i.useMemo(function(){return"function"==typeof n?n(t):{...t,...n}},[t,n])}function o(n){let t;return t=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:a(n.components),i.createElement(s.Provider,{value:t},n.children)}}}]);