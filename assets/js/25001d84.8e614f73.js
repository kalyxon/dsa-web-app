"use strict";(globalThis.webpackChunkmarkdown_web_app=globalThis.webpackChunkmarkdown_web_app||[]).push([[691],{4673(n,e,t){t.r(e),t.d(e,{assets:()=>o,contentTitle:()=>s,default:()=>u,frontMatter:()=>r,metadata:()=>d,toc:()=>a});var i=t(4848),l=t(8453);const r={id:"linked-list",title:"Linked list"},s="Linked Lists",d={id:"linked-list",title:"Linked list",description:"Introduction to Linked Lists",source:"@site/docs/linked-list.md",sourceDirName:".",slug:"/linked-list",permalink:"/markdown-web-app/linked-list",draft:!1,unlisted:!1,editUrl:"https://github.com/kalyxon/markdown-web-app/tree/main/docs/linked-list.md",tags:[],version:"current",frontMatter:{id:"linked-list",title:"Linked list"},sidebar:"dsa",previous:{title:"Arrays",permalink:"/markdown-web-app/arrays"},next:{title:"Stacks Queues",permalink:"/markdown-web-app/stacks-queues"}},o={},a=[{value:"Introduction to Linked Lists",id:"introduction-to-linked-lists",level:2},{value:"Key Characteristics:",id:"key-characteristics",level:3},{value:"Linked Lists in Memory",id:"linked-lists-in-memory",level:2},{value:"Memory Representation:",id:"memory-representation",level:3},{value:"Visual Memory Layout:",id:"visual-memory-layout",level:3},{value:"Comparison with Arrays:",id:"comparison-with-arrays",level:3},{value:"Linked List Types",id:"linked-list-types",level:2},{value:"1. Singly Linked List",id:"1-singly-linked-list",level:3},{value:"2. Doubly Linked List",id:"2-doubly-linked-list",level:3},{value:"3. Circular Linked List",id:"3-circular-linked-list",level:3},{value:"Basic Singly Linked List Implementation",id:"basic-singly-linked-list-implementation",level:2},{value:"Doubly Linked List Implementation",id:"doubly-linked-list-implementation",level:2},{value:"Circular Linked List Implementation",id:"circular-linked-list-implementation",level:2},{value:"Linked List Operations Complexity Analysis",id:"linked-list-operations-complexity-analysis",level:2},{value:"Advanced Linked List Problems",id:"advanced-linked-list-problems",level:2},{value:"1. Detect and Remove Loop",id:"1-detect-and-remove-loop",level:3},{value:"2. Find Middle Element",id:"2-find-middle-element",level:3},{value:"3. Merge Two Sorted Linked Lists",id:"3-merge-two-sorted-linked-lists",level:3},{value:"STL Linked List Implementation",id:"stl-linked-list-implementation",level:2},{value:"Real-World Applications",id:"real-world-applications",level:2},{value:"1. Music Playlist",id:"1-music-playlist",level:3},{value:"2. Browser History",id:"2-browser-history",level:3},{value:"Advantages and Disadvantages",id:"advantages-and-disadvantages",level:2},{value:"Advantages:",id:"advantages",level:3},{value:"Disadvantages:",id:"disadvantages",level:3},{value:"When to Use Linked Lists",id:"when-to-use-linked-lists",level:2},{value:"Summary",id:"summary",level:2}];function c(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,l.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.header,{children:(0,i.jsx)(e.h1,{id:"linked-lists",children:"Linked Lists"})}),"\n",(0,i.jsx)(e.h2,{id:"introduction-to-linked-lists",children:"Introduction to Linked Lists"}),"\n",(0,i.jsxs)(e.p,{children:["A ",(0,i.jsx)(e.strong,{children:"Linked List"})," is a linear data structure where elements are stored in ",(0,i.jsx)(e.strong,{children:"nodes"}),", and each node points to the next node via a ",(0,i.jsx)(e.strong,{children:"pointer"}),". Unlike arrays, linked lists are ",(0,i.jsx)(e.strong,{children:"dynamic"})," and can grow/shrink at runtime."]}),"\n",(0,i.jsx)(e.h3,{id:"key-characteristics",children:"Key Characteristics:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Dynamic Size"}),": No fixed size, can grow/shrink as needed"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Memory Efficiency"}),": Uses memory only when needed"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Sequential Access"}),": Elements accessed sequentially (not random access)"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Insertion/Deletion"}),": O(1) at beginning, O(n) elsewhere"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"No Memory Wastage"}),": No pre-allocation needed"]}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"linked-lists-in-memory",children:"Linked Lists in Memory"}),"\n",(0,i.jsx)(e.h3,{id:"memory-representation",children:"Memory Representation:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["Each node contains:","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Data"}),": The actual value"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Next Pointer"}),": Address of next node"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["Nodes are ",(0,i.jsx)(e.strong,{children:"not contiguous"})," in memory"]}),"\n",(0,i.jsxs)(e.li,{children:["Last node points to ",(0,i.jsx)(e.code,{children:"NULL"})," (end of list)"]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"visual-memory-layout",children:"Visual Memory Layout:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"Memory Address | Node Representation\n---------------+----------------------\n0x1000         | [Data: 10 | Next: 0x2000] \u2192 Node 1\n0x2000         | [Data: 20 | Next: 0x3000] \u2192 Node 2  \n0x3000         | [Data: 30 | Next: NULL]   \u2192 Node 3\n"})}),"\n",(0,i.jsx)(e.h3,{id:"comparison-with-arrays",children:"Comparison with Arrays:"}),"\n",(0,i.jsxs)(e.table,{children:[(0,i.jsx)(e.thead,{children:(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.th,{children:"Aspect"}),(0,i.jsx)(e.th,{children:"Array"}),(0,i.jsx)(e.th,{children:"Linked List"})]})}),(0,i.jsxs)(e.tbody,{children:[(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:(0,i.jsx)(e.strong,{children:"Memory"})}),(0,i.jsx)(e.td,{children:"Contiguous"}),(0,i.jsx)(e.td,{children:"Non-contiguous"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:(0,i.jsx)(e.strong,{children:"Size"})}),(0,i.jsx)(e.td,{children:"Fixed"}),(0,i.jsx)(e.td,{children:"Dynamic"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:(0,i.jsx)(e.strong,{children:"Access"})}),(0,i.jsx)(e.td,{children:"Random (O(1))"}),(0,i.jsx)(e.td,{children:"Sequential (O(n))"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:(0,i.jsx)(e.strong,{children:"Insertion"})}),(0,i.jsx)(e.td,{children:"O(n)"}),(0,i.jsx)(e.td,{children:"O(1) at head"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:(0,i.jsx)(e.strong,{children:"Memory Usage"})}),(0,i.jsx)(e.td,{children:"May waste space"}),(0,i.jsx)(e.td,{children:"Efficient"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:(0,i.jsx)(e.strong,{children:"Cache"})}),(0,i.jsx)(e.td,{children:"Friendly"}),(0,i.jsx)(e.td,{children:"Unfriendly"})]})]})]}),"\n",(0,i.jsx)(e.h2,{id:"linked-list-types",children:"Linked List Types"}),"\n",(0,i.jsx)(e.h3,{id:"1-singly-linked-list",children:"1. Singly Linked List"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:"struct Node {\n    int data;\n    Node* next;\n    \n    Node(int val) {\n        data = val;\n        next = nullptr;\n    }\n};\n"})}),"\n",(0,i.jsx)(e.h3,{id:"2-doubly-linked-list",children:"2. Doubly Linked List"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:"struct Node {\n    int data;\n    Node* next;\n    Node* prev;\n    \n    Node(int val) {\n        data = val;\n        next = nullptr;\n        prev = nullptr;\n    }\n};\n"})}),"\n",(0,i.jsx)(e.h3,{id:"3-circular-linked-list",children:"3. Circular Linked List"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:"// Singly Circular\nstruct Node {\n    int data;\n    Node* next;\n    \n    Node(int val) {\n        data = val;\n        next = this;  // Points to itself initially\n    }\n};\n"})}),"\n",(0,i.jsx)(e.h2,{id:"basic-singly-linked-list-implementation",children:"Basic Singly Linked List Implementation"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\nusing namespace std;\n\nclass Node {\npublic:\n    int data;\n    Node* next;\n    \n    Node(int value) {\n        data = value;\n        next = nullptr;\n    }\n};\n\nclass LinkedList {\nprivate:\n    Node* head;\n    int size;\n    \npublic:\n    LinkedList() {\n        head = nullptr;\n        size = 0;\n    }\n    \n    // Insert at beginning\n    void insertAtHead(int value) {\n        Node* newNode = new Node(value);\n        newNode->next = head;\n        head = newNode;\n        size++;\n        cout << "Inserted " << value << " at head" << endl;\n    }\n    \n    // Insert at end\n    void insertAtTail(int value) {\n        Node* newNode = new Node(value);\n        \n        if(head == nullptr) {\n            head = newNode;\n        } else {\n            Node* temp = head;\n            while(temp->next != nullptr) {\n                temp = temp->next;\n            }\n            temp->next = newNode;\n        }\n        size++;\n        cout << "Inserted " << value << " at tail" << endl;\n    }\n    \n    // Insert at specific position\n    void insertAtPosition(int value, int position) {\n        if(position < 0 || position > size) {\n            cout << "Invalid position!" << endl;\n            return;\n        }\n        \n        if(position == 0) {\n            insertAtHead(value);\n            return;\n        }\n        \n        Node* newNode = new Node(value);\n        Node* temp = head;\n        \n        for(int i = 0; i < position - 1; i++) {\n            temp = temp->next;\n        }\n        \n        newNode->next = temp->next;\n        temp->next = newNode;\n        size++;\n        cout << "Inserted " << value << " at position " << position << endl;\n    }\n    \n    // Delete from beginning\n    void deleteFromHead() {\n        if(head == nullptr) {\n            cout << "List is empty!" << endl;\n            return;\n        }\n        \n        Node* temp = head;\n        head = head->next;\n        cout << "Deleted " << temp->data << " from head" << endl;\n        delete temp;\n        size--;\n    }\n    \n    // Delete from end\n    void deleteFromTail() {\n        if(head == nullptr) {\n            cout << "List is empty!" << endl;\n            return;\n        }\n        \n        if(head->next == nullptr) {\n            cout << "Deleted " << head->data << " from tail" << endl;\n            delete head;\n            head = nullptr;\n            size--;\n            return;\n        }\n        \n        Node* temp = head;\n        while(temp->next->next != nullptr) {\n            temp = temp->next;\n        }\n        \n        cout << "Deleted " << temp->next->data << " from tail" << endl;\n        delete temp->next;\n        temp->next = nullptr;\n        size--;\n    }\n    \n    // Delete from specific position\n    void deleteFromPosition(int position) {\n        if(head == nullptr || position < 0 || position >= size) {\n            cout << "Invalid position or empty list!" << endl;\n            return;\n        }\n        \n        if(position == 0) {\n            deleteFromHead();\n            return;\n        }\n        \n        Node* temp = head;\n        for(int i = 0; i < position - 1; i++) {\n            temp = temp->next;\n        }\n        \n        Node* toDelete = temp->next;\n        temp->next = temp->next->next;\n        cout << "Deleted " << toDelete->data << " from position " << position << endl;\n        delete toDelete;\n        size--;\n    }\n    \n    // Search for a value\n    bool search(int value) {\n        Node* temp = head;\n        int position = 0;\n        \n        while(temp != nullptr) {\n            if(temp->data == value) {\n                cout << "Found " << value << " at position " << position << endl;\n                return true;\n            }\n            temp = temp->next;\n            position++;\n        }\n        \n        cout << value << " not found in list" << endl;\n        return false;\n    }\n    \n    // Get size\n    int getSize() {\n        return size;\n    }\n    \n    // Display the list\n    void display() {\n        if(head == nullptr) {\n            cout << "List is empty!" << endl;\n            return;\n        }\n        \n        cout << "Linked List (" << size << " nodes): ";\n        Node* temp = head;\n        \n        while(temp != nullptr) {\n            cout << temp->data;\n            if(temp->next != nullptr) {\n                cout << " -> ";\n            }\n            temp = temp->next;\n        }\n        cout << " -> NULL" << endl;\n    }\n    \n    // Reverse the list\n    void reverse() {\n        Node* prev = nullptr;\n        Node* current = head;\n        Node* next = nullptr;\n        \n        cout << "Reversing linked list..." << endl;\n        \n        while(current != nullptr) {\n            next = current->next;  // Store next node\n            current->next = prev;  // Reverse current node\'s pointer\n            prev = current;        // Move pointers one position ahead\n            current = next;\n        }\n        \n        head = prev;\n        cout << "List reversed successfully!" << endl;\n    }\n    \n    // Destructor to free memory\n    ~LinkedList() {\n        cout << "\\nCleaning up linked list..." << endl;\n        Node* current = head;\n        while(current != nullptr) {\n            Node* next = current->next;\n            cout << "Deleting node with value: " << current->data << endl;\n            delete current;\n            current = next;\n        }\n        head = nullptr;\n        size = 0;\n    }\n};\n\nint main() {\n    LinkedList list;\n    \n    cout << "=== Singly Linked List Operations ===" << endl;\n    \n    // Insert operations\n    list.insertAtHead(10);\n    list.insertAtTail(20);\n    list.insertAtTail(30);\n    list.insertAtHead(5);\n    list.insertAtPosition(15, 2);\n    \n    list.display();\n    \n    // Search operation\n    list.search(20);\n    list.search(100);\n    \n    // Delete operations\n    list.deleteFromHead();\n    list.display();\n    \n    list.deleteFromTail();\n    list.display();\n    \n    list.deleteFromPosition(1);\n    list.display();\n    \n    // Reverse operation\n    list.insertAtTail(40);\n    list.insertAtTail(50);\n    list.display();\n    \n    list.reverse();\n    list.display();\n    \n    cout << "\\nCurrent size: " << list.getSize() << endl;\n    \n    return 0;\n}\n'})}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Output:"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"=== Singly Linked List Operations ===\nInserted 10 at head\nInserted 20 at tail\nInserted 30 at tail\nInserted 5 at head\nInserted 15 at position 2\nLinked List (5 nodes): 5 -> 10 -> 15 -> 20 -> 30 -> NULL\nFound 20 at position 3\n100 not found in list\nDeleted 5 from head\nLinked List (4 nodes): 10 -> 15 -> 20 -> 30 -> NULL\nDeleted 30 from tail\nLinked List (3 nodes): 10 -> 15 -> 20 -> NULL\nDeleted 20 from position 1\nLinked List (2 nodes): 10 -> 15 -> NULL\nInserted 40 at tail\nInserted 50 at tail\nLinked List (4 nodes): 10 -> 15 -> 40 -> 50 -> NULL\nReversing linked list...\nList reversed successfully!\nLinked List (4 nodes): 50 -> 40 -> 15 -> 10 -> NULL\n\nCurrent size: 4\n\nCleaning up linked list...\nDeleting node with value: 50\nDeleting node with value: 40\nDeleting node with value: 15\nDeleting node with value: 10\n"})}),"\n",(0,i.jsx)(e.h2,{id:"doubly-linked-list-implementation",children:"Doubly Linked List Implementation"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\nusing namespace std;\n\nclass DNode {\npublic:\n    int data;\n    DNode* next;\n    DNode* prev;\n    \n    DNode(int value) {\n        data = value;\n        next = nullptr;\n        prev = nullptr;\n    }\n};\n\nclass DoublyLinkedList {\nprivate:\n    DNode* head;\n    DNode* tail;\n    int size;\n    \npublic:\n    DoublyLinkedList() {\n        head = nullptr;\n        tail = nullptr;\n        size = 0;\n    }\n    \n    // Insert at beginning\n    void insertAtHead(int value) {\n        DNode* newNode = new DNode(value);\n        \n        if(head == nullptr) {\n            head = tail = newNode;\n        } else {\n            newNode->next = head;\n            head->prev = newNode;\n            head = newNode;\n        }\n        size++;\n        cout << "Inserted " << value << " at head" << endl;\n    }\n    \n    // Insert at end\n    void insertAtTail(int value) {\n        DNode* newNode = new DNode(value);\n        \n        if(tail == nullptr) {\n            head = tail = newNode;\n        } else {\n            tail->next = newNode;\n            newNode->prev = tail;\n            tail = newNode;\n        }\n        size++;\n        cout << "Inserted " << value << " at tail" << endl;\n    }\n    \n    // Insert at specific position\n    void insertAtPosition(int value, int position) {\n        if(position < 0 || position > size) {\n            cout << "Invalid position!" << endl;\n            return;\n        }\n        \n        if(position == 0) {\n            insertAtHead(value);\n            return;\n        }\n        \n        if(position == size) {\n            insertAtTail(value);\n            return;\n        }\n        \n        DNode* newNode = new DNode(value);\n        DNode* temp = head;\n        \n        for(int i = 0; i < position - 1; i++) {\n            temp = temp->next;\n        }\n        \n        newNode->next = temp->next;\n        newNode->prev = temp;\n        temp->next->prev = newNode;\n        temp->next = newNode;\n        \n        size++;\n        cout << "Inserted " << value << " at position " << position << endl;\n    }\n    \n    // Delete from beginning\n    void deleteFromHead() {\n        if(head == nullptr) {\n            cout << "List is empty!" << endl;\n            return;\n        }\n        \n        DNode* temp = head;\n        \n        if(head == tail) {\n            head = tail = nullptr;\n        } else {\n            head = head->next;\n            head->prev = nullptr;\n        }\n        \n        cout << "Deleted " << temp->data << " from head" << endl;\n        delete temp;\n        size--;\n    }\n    \n    // Delete from end\n    void deleteFromTail() {\n        if(tail == nullptr) {\n            cout << "List is empty!" << endl;\n            return;\n        }\n        \n        DNode* temp = tail;\n        \n        if(head == tail) {\n            head = tail = nullptr;\n        } else {\n            tail = tail->prev;\n            tail->next = nullptr;\n        }\n        \n        cout << "Deleted " << temp->data << " from tail" << endl;\n        delete temp;\n        size--;\n    }\n    \n    // Display forward\n    void displayForward() {\n        if(head == nullptr) {\n            cout << "List is empty!" << endl;\n            return;\n        }\n        \n        cout << "Doubly Linked List (Forward): ";\n        DNode* temp = head;\n        \n        while(temp != nullptr) {\n            cout << temp->data;\n            if(temp->next != nullptr) {\n                cout << " <-> ";\n            }\n            temp = temp->next;\n        }\n        cout << " -> NULL" << endl;\n    }\n    \n    // Display backward\n    void displayBackward() {\n        if(tail == nullptr) {\n            cout << "List is empty!" << endl;\n            return;\n        }\n        \n        cout << "Doubly Linked List (Backward): ";\n        DNode* temp = tail;\n        \n        while(temp != nullptr) {\n            cout << temp->data;\n            if(temp->prev != nullptr) {\n                cout << " <-> ";\n            }\n            temp = temp->prev;\n        }\n        cout << " -> NULL" << endl;\n    }\n    \n    // Get size\n    int getSize() {\n        return size;\n    }\n    \n    // Destructor\n    ~DoublyLinkedList() {\n        cout << "\\nCleaning up doubly linked list..." << endl;\n        DNode* current = head;\n        while(current != nullptr) {\n            DNode* next = current->next;\n            cout << "Deleting node with value: " << current->data << endl;\n            delete current;\n            current = next;\n        }\n        head = tail = nullptr;\n        size = 0;\n    }\n};\n\nint main() {\n    DoublyLinkedList dll;\n    \n    cout << "=== Doubly Linked List Operations ===" << endl;\n    \n    // Insert operations\n    dll.insertAtHead(10);\n    dll.insertAtTail(20);\n    dll.insertAtTail(30);\n    dll.insertAtHead(5);\n    dll.insertAtPosition(15, 2);\n    \n    dll.displayForward();\n    dll.displayBackward();\n    \n    cout << "\\nSize: " << dll.getSize() << endl;\n    \n    // Delete operations\n    dll.deleteFromHead();\n    dll.displayForward();\n    \n    dll.deleteFromTail();\n    dll.displayForward();\n    \n    return 0;\n}\n'})}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Output:"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"=== Doubly Linked List Operations ===\nInserted 10 at head\nInserted 20 at tail\nInserted 30 at tail\nInserted 5 at head\nInserted 15 at position 2\nDoubly Linked List (Forward): 5 <-> 10 <-> 15 <-> 20 <-> 30 -> NULL\nDoubly Linked List (Backward): 30 <-> 20 <-> 15 <-> 10 <-> 5 -> NULL\n\nSize: 5\nDeleted 5 from head\nDoubly Linked List (Forward): 10 <-> 15 <-> 20 <-> 30 -> NULL\nDeleted 30 from tail\nDoubly Linked List (Forward): 10 <-> 15 <-> 20 -> NULL\n\nCleaning up doubly linked list...\nDeleting node with value: 10\nDeleting node with value: 15\nDeleting node with value: 20\n"})}),"\n",(0,i.jsx)(e.h2,{id:"circular-linked-list-implementation",children:"Circular Linked List Implementation"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\nusing namespace std;\n\nclass CNode {\npublic:\n    int data;\n    CNode* next;\n    \n    CNode(int value) {\n        data = value;\n        next = nullptr;\n    }\n};\n\nclass CircularLinkedList {\nprivate:\n    CNode* head;\n    int size;\n    \npublic:\n    CircularLinkedList() {\n        head = nullptr;\n        size = 0;\n    }\n    \n    // Insert at beginning\n    void insertAtHead(int value) {\n        CNode* newNode = new CNode(value);\n        \n        if(head == nullptr) {\n            head = newNode;\n            newNode->next = head;  // Circular reference\n        } else {\n            CNode* temp = head;\n            while(temp->next != head) {\n                temp = temp->next;\n            }\n            newNode->next = head;\n            temp->next = newNode;\n            head = newNode;\n        }\n        size++;\n        cout << "Inserted " << value << " at head" << endl;\n    }\n    \n    // Insert at end\n    void insertAtTail(int value) {\n        CNode* newNode = new CNode(value);\n        \n        if(head == nullptr) {\n            head = newNode;\n            newNode->next = head;\n        } else {\n            CNode* temp = head;\n            while(temp->next != head) {\n                temp = temp->next;\n            }\n            temp->next = newNode;\n            newNode->next = head;\n        }\n        size++;\n        cout << "Inserted " << value << " at tail" << endl;\n    }\n    \n    // Display the list\n    void display() {\n        if(head == nullptr) {\n            cout << "List is empty!" << endl;\n            return;\n        }\n        \n        cout << "Circular Linked List (" << size << " nodes): ";\n        CNode* temp = head;\n        \n        do {\n            cout << temp->data;\n            temp = temp->next;\n            if(temp != head) {\n                cout << " -> ";\n            }\n        } while(temp != head);\n        \n        cout << " -> [back to head]" << endl;\n    }\n    \n    // Check if list is circular\n    bool isCircular() {\n        if(head == nullptr) return true;\n        \n        CNode* slow = head;\n        CNode* fast = head;\n        \n        while(fast != nullptr && fast->next != nullptr) {\n            slow = slow->next;\n            fast = fast->next->next;\n            \n            if(slow == fast) {\n                return true;\n            }\n        }\n        return false;\n    }\n    \n    // Josephus Problem Solution\n    void josephusProblem(int k) {\n        if(head == nullptr || size == 0) {\n            cout << "List is empty!" << endl;\n            return;\n        }\n        \n        cout << "\\nJosephus Problem with k = " << k << endl;\n        cout << "Elimination order: ";\n        \n        CNode* current = head;\n        CNode* prev = nullptr;\n        \n        // Find last node\n        while(current->next != head) {\n            current = current->next;\n        }\n        prev = current;\n        current = head;\n        \n        while(size > 1) {\n            // Move k-1 steps\n            for(int i = 1; i < k; i++) {\n                prev = current;\n                current = current->next;\n            }\n            \n            // Eliminate current node\n            cout << current->data << " ";\n            \n            prev->next = current->next;\n            CNode* toDelete = current;\n            \n            if(current == head) {\n                head = head->next;\n            }\n            \n            current = current->next;\n            delete toDelete;\n            size--;\n        }\n        \n        cout << "\\nSurvivor: " << current->data << endl;\n        head = current;\n        head->next = head;\n    }\n    \n    // Destructor\n    ~CircularLinkedList() {\n        if(head == nullptr) return;\n        \n        cout << "\\nCleaning up circular linked list..." << endl;\n        CNode* current = head->next;\n        \n        while(current != head) {\n            CNode* next = current->next;\n            cout << "Deleting node with value: " << current->data << endl;\n            delete current;\n            current = next;\n        }\n        \n        cout << "Deleting node with value: " << head->data << endl;\n        delete head;\n        head = nullptr;\n        size = 0;\n    }\n};\n\nint main() {\n    CircularLinkedList cll;\n    \n    cout << "=== Circular Linked List Operations ===" << endl;\n    \n    // Insert operations\n    cll.insertAtHead(10);\n    cll.insertAtTail(20);\n    cll.insertAtTail(30);\n    cll.insertAtHead(5);\n    cll.insertAtTail(40);\n    \n    cll.display();\n    \n    cout << "\\nIs circular? " << (cll.isCircular() ? "Yes" : "No") << endl;\n    \n    // Josephus Problem\n    CircularLinkedList josephusList;\n    for(int i = 1; i <= 7; i++) {\n        josephusList.insertAtTail(i);\n    }\n    \n    josephusList.display();\n    josephusList.josephusProblem(3);\n    josephusList.display();\n    \n    return 0;\n}\n'})}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Output:"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"=== Circular Linked List Operations ===\nInserted 10 at head\nInserted 20 at tail\nInserted 30 at tail\nInserted 5 at head\nInserted 40 at tail\nCircular Linked List (5 nodes): 5 -> 10 -> 20 -> 30 -> 40 -> [back to head]\n\nIs circular? Yes\n\nCircular Linked List (7 nodes): 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> [back to head]\n\nJosephus Problem with k = 3\nElimination order: 3 6 2 7 5 1 \nSurvivor: 4\nCircular Linked List (1 nodes): 4 -> [back to head]\n\nCleaning up circular linked list...\nDeleting node with value: 4\n"})}),"\n",(0,i.jsx)(e.h2,{id:"linked-list-operations-complexity-analysis",children:"Linked List Operations Complexity Analysis"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <chrono>\n#include <random>\n#include <vector>\n#include <iomanip>\nusing namespace std;\nusing namespace chrono;\n\nclass PerformanceAnalyzer {\nprivate:\n    struct Node {\n        int data;\n        Node* next;\n        Node(int val) : data(val), next(nullptr) {}\n    };\n    \n    Node* head;\n    \npublic:\n    PerformanceAnalyzer() : head(nullptr) {}\n    \n    void insertAtHead(int val) {\n        Node* newNode = new Node(val);\n        newNode->next = head;\n        head = newNode;\n    }\n    \n    void insertAtTail(int val) {\n        Node* newNode = new Node(val);\n        if(head == nullptr) {\n            head = newNode;\n            return;\n        }\n        Node* temp = head;\n        while(temp->next != nullptr) {\n            temp = temp->next;\n        }\n        temp->next = newNode;\n    }\n    \n    void clear() {\n        while(head != nullptr) {\n            Node* temp = head;\n            head = head->next;\n            delete temp;\n        }\n    }\n    \n    void analyzeOperations(int n) {\n        random_device rd;\n        mt19937 gen(rd());\n        uniform_int_distribution<> dis(1, 1000000);\n        \n        cout << "\\n" << string(60, \'=\') << endl;\n        cout << "Performance Analysis for " << n << " elements" << endl;\n        cout << string(60, \'=\') << endl;\n        \n        // 1. Insert at head (O(1))\n        clear();\n        auto start = high_resolution_clock::now();\n        for(int i = 0; i < n; i++) {\n            insertAtHead(dis(gen));\n        }\n        auto end = high_resolution_clock::now();\n        auto headTime = duration_cast<microseconds>(end - start).count();\n        \n        // 2. Insert at tail (O(n))\n        clear();\n        start = high_resolution_clock::now();\n        for(int i = 0; i < n; i++) {\n            insertAtTail(dis(gen));\n        }\n        end = high_resolution_clock::now();\n        auto tailTime = duration_cast<microseconds>(end - start).count();\n        \n        // 3. Sequential search (O(n))\n        start = high_resolution_clock::now();\n        Node* temp = head;\n        int searchValue = dis(gen);\n        while(temp != nullptr && temp->data != searchValue) {\n            temp = temp->next;\n        }\n        end = high_resolution_clock::now();\n        auto searchTime = duration_cast<microseconds>(end - start).count();\n        \n        cout << fixed << setprecision(2);\n        cout << "\\nOperation Timings:" << endl;\n        cout << string(40, \'-\') << endl;\n        cout << setw(20) << "Operation" \n             << setw(20) << "Time (\u03bcs)" \n             << setw(20) << "Complexity" << endl;\n        cout << string(60, \'-\') << endl;\n        cout << setw(20) << "Insert at Head" \n             << setw(20) << headTime \n             << setw(20) << "O(1)" << endl;\n        cout << setw(20) << "Insert at Tail" \n             << setw(20) << tailTime \n             << setw(20) << "O(n)" << endl;\n        cout << setw(20) << "Search" \n             << setw(20) << searchTime \n             << setw(20) << "O(n)" << endl;\n        \n        cout << "\\nKey Observations:" << endl;\n        cout << "1. Insert at head is constant time: O(1)" << endl;\n        cout << "2. Insert at tail is linear time: O(n)" << endl;\n        cout << "3. Search is linear time: O(n)" << endl;\n        cout << "4. Linked lists excel at frequent insertions/deletions at head" << endl;\n    }\n};\n\nvoid compareWithArray(int n) {\n    cout << "\\n\\n" << string(70, \'=\') << endl;\n    cout << "Linked List vs Array Comparison for " << n << " elements" << endl;\n    cout << string(70, \'=\') << endl;\n    \n    cout << setw(30) << "Operation" \n         << setw(20) << "Linked List" \n         << setw(20) << "Array" << endl;\n    cout << string(70, \'-\') << endl;\n    \n    cout << setw(30) << "Insert at Beginning" \n         << setw(20) << "O(1)" \n         << setw(20) << "O(n)" << endl;\n    \n    cout << setw(30) << "Insert at End" \n         << setw(20) << "O(n)" \n         << setw(20) << "O(1) (if space)" << endl;\n    \n    cout << setw(30) << "Insert at Middle" \n         << setw(20) << "O(n)" \n         << setw(20) << "O(n)" << endl;\n    \n    cout << setw(30) << "Delete from Beginning" \n         << setw(20) << "O(1)" \n         << setw(20) << "O(n)" << endl;\n    \n    cout << setw(30) << "Random Access" \n         << setw(20) << "O(n)" \n         << setw(20) << "O(1)" << endl;\n    \n    cout << setw(30) << "Memory Usage" \n         << setw(20) << "Dynamic" \n         << setw(20) << "Fixed" << endl;\n    \n    cout << setw(30) << "Memory Overhead" \n         << setw(20) << "High (pointers)" \n         << setw(20) << "Low" << endl;\n    \n    cout << setw(30) << "Cache Performance" \n         << setw(20) << "Poor" \n         << setw(20) << "Excellent" << endl;\n}\n\nint main() {\n    PerformanceAnalyzer analyzer;\n    \n    vector<int> testSizes = {1000, 10000, 50000};\n    \n    for(int size : testSizes) {\n        analyzer.analyzeOperations(size);\n    }\n    \n    compareWithArray(10000);\n    \n    return 0;\n}\n'})}),"\n",(0,i.jsx)(e.h2,{id:"advanced-linked-list-problems",children:"Advanced Linked List Problems"}),"\n",(0,i.jsx)(e.h3,{id:"1-detect-and-remove-loop",children:"1. Detect and Remove Loop"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\nusing namespace std;\n\nclass LoopDetector {\nprivate:\n    struct Node {\n        int data;\n        Node* next;\n        Node(int val) : data(val), next(nullptr) {}\n    };\n    \n    Node* head;\n    \npublic:\n    LoopDetector() : head(nullptr) {}\n    \n    void createListWithLoop(int nodes, int loopStart) {\n        if(head != nullptr) clear();\n        \n        if(nodes <= 0) return;\n        \n        // Create nodes\n        Node* loopNode = nullptr;\n        Node* prev = nullptr;\n        \n        for(int i = 1; i <= nodes; i++) {\n            Node* newNode = new Node(i);\n            if(i == 1) head = newNode;\n            if(i == loopStart) loopNode = newNode;\n            if(prev != nullptr) prev->next = newNode;\n            prev = newNode;\n        }\n        \n        // Create loop if specified\n        if(loopStart > 0 && loopStart <= nodes) {\n            prev->next = loopNode;\n            cout << "Created list with " << nodes << " nodes, loop starts at node " \n                 << loopStart << endl;\n        } else {\n            cout << "Created list with " << nodes << " nodes (no loop)" << endl;\n        }\n    }\n    \n    bool detectLoop() {\n        if(head == nullptr) return false;\n        \n        Node* slow = head;\n        Node* fast = head;\n        \n        while(fast != nullptr && fast->next != nullptr) {\n            slow = slow->next;\n            fast = fast->next->next;\n            \n            if(slow == fast) {\n                cout << "Loop detected!" << endl;\n                return true;\n            }\n        }\n        \n        cout << "No loop detected" << endl;\n        return false;\n    }\n    \n    void removeLoop() {\n        if(head == nullptr) return;\n        \n        // Step 1: Detect loop\n        Node* slow = head;\n        Node* fast = head;\n        bool loopExists = false;\n        \n        while(fast != nullptr && fast->next != nullptr) {\n            slow = slow->next;\n            fast = fast->next->next;\n            \n            if(slow == fast) {\n                loopExists = true;\n                break;\n            }\n        }\n        \n        if(!loopExists) {\n            cout << "No loop to remove" << endl;\n            return;\n        }\n        \n        // Step 2: Find loop start\n        slow = head;\n        while(slow != fast) {\n            slow = slow->next;\n            fast = fast->next;\n        }\n        \n        // Step 3: Find last node\n        Node* lastNode = slow;\n        while(lastNode->next != slow) {\n            lastNode = lastNode->next;\n        }\n        \n        // Step 4: Remove loop\n        lastNode->next = nullptr;\n        cout << "Loop removed successfully!" << endl;\n    }\n    \n    void display(int maxNodes = 20) {\n        if(head == nullptr) {\n            cout << "List is empty" << endl;\n            return;\n        }\n        \n        cout << "List: ";\n        Node* temp = head;\n        int count = 0;\n        \n        while(temp != nullptr && count < maxNodes) {\n            cout << temp->data;\n            if(temp->next != nullptr) {\n                cout << " -> ";\n            }\n            temp = temp->next;\n            count++;\n        }\n        \n        if(temp != nullptr) {\n            cout << "... (loop or large list)" << endl;\n        } else {\n            cout << " -> NULL" << endl;\n        }\n    }\n    \n    void clear() {\n        while(head != nullptr) {\n            Node* temp = head;\n            head = head->next;\n            delete temp;\n        }\n    }\n    \n    ~LoopDetector() {\n        clear();\n    }\n};\n\nint main() {\n    LoopDetector detector;\n    \n    cout << "=== Loop Detection and Removal ===" << endl;\n    \n    // Test 1: List without loop\n    cout << "\\nTest 1: Normal list (no loop)" << endl;\n    detector.createListWithLoop(8, 0);\n    detector.display();\n    detector.detectLoop();\n    \n    // Test 2: List with loop\n    cout << "\\nTest 2: List with loop" << endl;\n    detector.createListWithLoop(8, 3);\n    detector.display(15);  // Show first 15 nodes to see loop\n    detector.detectLoop();\n    \n    // Remove loop\n    detector.removeLoop();\n    detector.display();\n    detector.detectLoop();\n    \n    // Test 3: Circular list\n    cout << "\\nTest 3: Circular list" << endl;\n    detector.createListWithLoop(5, 1);\n    detector.display(12);\n    detector.detectLoop();\n    detector.removeLoop();\n    detector.display();\n    \n    return 0;\n}\n'})}),"\n",(0,i.jsx)(e.h3,{id:"2-find-middle-element",children:"2. Find Middle Element"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\nusing namespace std;\n\nclass MiddleFinder {\nprivate:\n    struct Node {\n        int data;\n        Node* next;\n        Node(int val) : data(val), next(nullptr) {}\n    };\n    \n    Node* head;\n    \npublic:\n    MiddleFinder() : head(nullptr) {}\n    \n    void addNode(int val) {\n        Node* newNode = new Node(val);\n        if(head == nullptr) {\n            head = newNode;\n        } else {\n            Node* temp = head;\n            while(temp->next != nullptr) {\n                temp = temp->next;\n            }\n            temp->next = newNode;\n        }\n    }\n    \n    int findMiddleTwoPass() {\n        if(head == nullptr) return -1;\n        \n        // First pass: count nodes\n        int count = 0;\n        Node* temp = head;\n        while(temp != nullptr) {\n            count++;\n            temp = temp->next;\n        }\n        \n        // Second pass: go to middle\n        temp = head;\n        for(int i = 0; i < count/2; i++) {\n            temp = temp->next;\n        }\n        \n        return temp->data;\n    }\n    \n    int findMiddleOnePass() {\n        if(head == nullptr) return -1;\n        \n        Node* slow = head;\n        Node* fast = head;\n        \n        while(fast != nullptr && fast->next != nullptr) {\n            slow = slow->next;          // Moves 1 step\n            fast = fast->next->next;    // Moves 2 steps\n        }\n        \n        return slow->data;\n    }\n    \n    void display() {\n        Node* temp = head;\n        cout << "List: ";\n        while(temp != nullptr) {\n            cout << temp->data;\n            if(temp->next != nullptr) cout << " -> ";\n            temp = temp->next;\n        }\n        cout << " -> NULL" << endl;\n    }\n    \n    ~MiddleFinder() {\n        while(head != nullptr) {\n            Node* temp = head;\n            head = head->next;\n            delete temp;\n        }\n    }\n};\n\nint main() {\n    MiddleFinder finder;\n    \n    cout << "=== Finding Middle Element of Linked List ===" << endl;\n    \n    // Create list with odd number of elements\n    for(int i = 1; i <= 7; i++) {\n        finder.addNode(i * 10);\n    }\n    \n    finder.display();\n    \n    cout << "\\nTwo-pass method (count then find): ";\n    cout << "Middle = " << finder.findMiddleTwoPass() << endl;\n    \n    cout << "One-pass method (slow/fast pointers): ";\n    cout << "Middle = " << finder.findMiddleOnePass() << endl;\n    \n    // Create list with even number of elements\n    MiddleFinder finder2;\n    for(int i = 1; i <= 8; i++) {\n        finder2.addNode(i * 5);\n    }\n    \n    cout << "\\n\\nEven-sized list:" << endl;\n    finder2.display();\n    \n    cout << "\\nTwo-pass method: Middle = " << finder2.findMiddleTwoPass() << endl;\n    cout << "One-pass method: Middle = " << finder2.findMiddleOnePass() << endl;\n    cout << "(Note: For even length, both methods return second middle element)" << endl;\n    \n    return 0;\n}\n'})}),"\n",(0,i.jsx)(e.h3,{id:"3-merge-two-sorted-linked-lists",children:"3. Merge Two Sorted Linked Lists"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\nusing namespace std;\n\nclass ListMerger {\nprivate:\n    struct Node {\n        int data;\n        Node* next;\n        Node(int val) : data(val), next(nullptr) {}\n    };\n    \n    Node* createList(const vector<int>& values) {\n        if(values.empty()) return nullptr;\n        \n        Node* head = new Node(values[0]);\n        Node* current = head;\n        \n        for(size_t i = 1; i < values.size(); i++) {\n            current->next = new Node(values[i]);\n            current = current->next;\n        }\n        \n        return head;\n    }\n    \n    void displayList(Node* head, const string& name) {\n        cout << name << ": ";\n        Node* temp = head;\n        while(temp != nullptr) {\n            cout << temp->data;\n            if(temp->next != nullptr) cout << " -> ";\n            temp = temp->next;\n        }\n        cout << " -> NULL" << endl;\n    }\n    \n    Node* mergeSortedLists(Node* list1, Node* list2) {\n        // Create a dummy node to simplify code\n        Node dummy(0);\n        Node* tail = &dummy;\n        \n        cout << "\\nMerging process:" << endl;\n        \n        while(list1 != nullptr && list2 != nullptr) {\n            cout << "  Comparing " << list1->data << " and " << list2->data;\n            \n            if(list1->data <= list2->data) {\n                cout << " \u2192 Take " << list1->data << " from list1" << endl;\n                tail->next = list1;\n                list1 = list1->next;\n            } else {\n                cout << " \u2192 Take " << list2->data << " from list2" << endl;\n                tail->next = list2;\n                list2 = list2->next;\n            }\n            tail = tail->next;\n        }\n        \n        // Append remaining nodes\n        if(list1 != nullptr) {\n            cout << "  Appending remaining from list1" << endl;\n            tail->next = list1;\n        } else if(list2 != nullptr) {\n            cout << "  Appending remaining from list2" << endl;\n            tail->next = list2;\n        }\n        \n        return dummy.next;\n    }\n    \n    void freeList(Node* head) {\n        while(head != nullptr) {\n            Node* temp = head;\n            head = head->next;\n            delete temp;\n        }\n    }\n    \npublic:\n    void demoMerge() {\n        cout << "=== Merging Two Sorted Linked Lists ===" << endl;\n        \n        // Create first sorted list\n        vector<int> list1Values = {1, 3, 5, 7, 9};\n        Node* list1 = createList(list1Values);\n        displayList(list1, "List 1");\n        \n        // Create second sorted list\n        vector<int> list2Values = {2, 4, 6, 8, 10};\n        Node* list2 = createList(list2Values);\n        displayList(list2, "List 2");\n        \n        // Merge the lists\n        Node* merged = mergeSortedLists(list1, list2);\n        displayList(merged, "Merged List");\n        \n        // Free memory\n        freeList(merged);  // merged contains all nodes\n    }\n};\n\nint main() {\n    ListMerger merger;\n    merger.demoMerge();\n    return 0;\n}\n'})}),"\n",(0,i.jsx)(e.h2,{id:"stl-linked-list-implementation",children:"STL Linked List Implementation"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <list>\n#include <forward_list>\n#include <algorithm>\n#include <iterator>\nusing namespace std;\n\nvoid demonstrateSTLLists() {\n    cout << "=== STL Linked List Implementations ===" << endl;\n    \n    // 1. std::list (doubly linked list)\n    cout << "\\n1. std::list (Doubly Linked List):" << endl;\n    list<int> myList = {10, 20, 30, 40, 50};\n    \n    cout << "Initial list: ";\n    for(int num : myList) cout << num << " ";\n    cout << endl;\n    \n    // Insert at beginning\n    myList.push_front(5);\n    cout << "After push_front(5): ";\n    for(int num : myList) cout << num << " ";\n    cout << endl;\n    \n    // Insert at end\n    myList.push_back(60);\n    cout << "After push_back(60): ";\n    for(int num : myList) cout << num << " ";\n    cout << endl;\n    \n    // Insert in middle\n    auto it = myList.begin();\n    advance(it, 3);  // Move iterator to position 3\n    myList.insert(it, 25);\n    cout << "After insert at position 3 (25): ";\n    for(int num : myList) cout << num << " ";\n    cout << endl;\n    \n    // Remove elements\n    myList.remove(30);  // Remove all occurrences of 30\n    cout << "After remove(30): ";\n    for(int num : myList) cout << num << " ";\n    cout << endl;\n    \n    // Sort the list\n    myList.sort();\n    cout << "After sort(): ";\n    for(int num : myList) cout << num << " ";\n    cout << endl;\n    \n    // Reverse the list\n    myList.reverse();\n    cout << "After reverse(): ";\n    for(int num : myList) cout << num << " ";\n    cout << endl;\n    \n    // 2. std::forward_list (singly linked list)\n    cout << "\\n2. std::forward_list (Singly Linked List):" << endl;\n    forward_list<int> myForwardList = {15, 25, 35, 45};\n    \n    cout << "Initial forward_list: ";\n    for(int num : myForwardList) cout << num << " ";\n    cout << endl;\n    \n    // Insert after first element\n    auto fit = myForwardList.begin();\n    myForwardList.insert_after(fit, 20);\n    cout << "After insert_after(begin, 20): ";\n    for(int num : myForwardList) cout << num << " ";\n    cout << endl;\n    \n    // Remove elements\n    myForwardList.remove_if([](int n) { return n > 30; });\n    cout << "After remove_if(>30): ";\n    for(int num : myForwardList) cout << num << " ";\n    cout << endl;\n    \n    // Sort\n    myForwardList.sort();\n    cout << "After sort(): ";\n    for(int num : myForwardList) cout << num << " ";\n    cout << endl;\n    \n    // Performance comparison\n    cout << "\\n3. Performance Characteristics:" << endl;\n    cout << "std::list (doubly linked):" << endl;\n    cout << "  - Insert/delete at any position: O(1) if iterator available" << endl;\n    cout << "  - Random access: O(n)" << endl;\n    cout << "  - Memory overhead: 2 pointers per node" << endl;\n    \n    cout << "\\nstd::forward_list (singly linked):" << endl;\n    cout << "  - Insert/delete after given position: O(1)" << endl;\n    cout << "  - No size() method (to save space)" << endl;\n    cout << "  - Memory overhead: 1 pointer per node" << endl;\n}\n\n// Custom object in linked list\nvoid demonstrateCustomObjects() {\n    cout << "\\n\\n=== Custom Objects in Linked List ===" << endl;\n    \n    struct Person {\n        string name;\n        int age;\n        \n        Person(string n, int a) : name(n), age(a) {}\n        \n        // For sorting\n        bool operator<(const Person& other) const {\n            return age < other.age;\n        }\n        \n        // For display\n        friend ostream& operator<<(ostream& os, const Person& p) {\n            os << p.name << " (" << p.age << ")";\n            return os;\n        }\n    };\n    \n    list<Person> people;\n    \n    people.push_back(Person("Alice", 25));\n    people.push_back(Person("Bob", 30));\n    people.push_back(Person("Charlie", 22));\n    people.push_back(Person("Diana", 28));\n    \n    cout << "People list: ";\n    for(const auto& person : people) {\n        cout << person << " -> ";\n    }\n    cout << "NULL" << endl;\n    \n    // Sort by age\n    people.sort();\n    cout << "\\nAfter sorting by age: ";\n    for(const auto& person : people) {\n        cout << person << " -> ";\n    }\n    cout << "NULL" << endl;\n    \n    // Remove people under 25\n    people.remove_if([](const Person& p) { return p.age < 25; });\n    cout << "\\nAfter removing people under 25: ";\n    for(const auto& person : people) {\n        cout << person << " -> ";\n    }\n    cout << "NULL" << endl;\n}\n\nint main() {\n    demonstrateSTLLists();\n    demonstrateCustomObjects();\n    return 0;\n}\n'})}),"\n",(0,i.jsx)(e.h2,{id:"real-world-applications",children:"Real-World Applications"}),"\n",(0,i.jsx)(e.h3,{id:"1-music-playlist",children:"1. Music Playlist"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <string>\nusing namespace std;\n\nclass MusicPlayer {\nprivate:\n    struct Song {\n        string title;\n        string artist;\n        int duration;  // in seconds\n        Song* next;\n        Song* prev;\n        \n        Song(string t, string a, int d) \n            : title(t), artist(a), duration(d), next(nullptr), prev(nullptr) {}\n        \n        void display() const {\n            int min = duration / 60;\n            int sec = duration % 60;\n            cout << "\\"" << title << "\\" by " << artist \n                 << " [" << min << ":" << (sec < 10 ? "0" : "") << sec << "]";\n        }\n    };\n    \n    Song* current;\n    Song* head;\n    Song* tail;\n    \npublic:\n    MusicPlayer() : current(nullptr), head(nullptr), tail(nullptr) {}\n    \n    void addSong(string title, string artist, int duration) {\n        Song* newSong = new Song(title, artist, duration);\n        \n        if(head == nullptr) {\n            head = tail = current = newSong;\n            newSong->next = newSong;\n            newSong->prev = newSong;\n        } else {\n            newSong->prev = tail;\n            newSong->next = head;\n            tail->next = newSong;\n            head->prev = newSong;\n            tail = newSong;\n        }\n        \n        cout << "Added: ";\n        newSong->display();\n        cout << endl;\n    }\n    \n    void playCurrent() {\n        if(current == nullptr) {\n            cout << "Playlist is empty!" << endl;\n            return;\n        }\n        \n        cout << "Now playing: ";\n        current->display();\n        cout << endl;\n    }\n    \n    void nextSong() {\n        if(current == nullptr) return;\n        \n        current = current->next;\n        playCurrent();\n    }\n    \n    void previousSong() {\n        if(current == nullptr) return;\n        \n        current = current->prev;\n        playCurrent();\n    }\n    \n    void displayPlaylist() {\n        if(head == nullptr) {\n            cout << "Playlist is empty!" << endl;\n            return;\n        }\n        \n        cout << "\\n=== Music Playlist ===" << endl;\n        Song* temp = head;\n        int index = 1;\n        \n        do {\n            cout << index++ << ". ";\n            temp->display();\n            if(temp == current) {\n                cout << " [CURRENT]";\n            }\n            cout << endl;\n            temp = temp->next;\n        } while(temp != head);\n    }\n    \n    void removeCurrent() {\n        if(current == nullptr) return;\n        \n        cout << "Removing: ";\n        current->display();\n        cout << endl;\n        \n        if(current->next == current) {  // Only one song\n            delete current;\n            head = tail = current = nullptr;\n            return;\n        }\n        \n        Song* toRemove = current;\n        \n        if(current == head) head = current->next;\n        if(current == tail) tail = current->prev;\n        \n        current->prev->next = current->next;\n        current->next->prev = current->prev;\n        \n        current = current->next;\n        delete toRemove;\n    }\n    \n    ~MusicPlayer() {\n        if(head == nullptr) return;\n        \n        Song* current = head;\n        Song* next;\n        \n        do {\n            next = current->next;\n            delete current;\n            current = next;\n        } while(current != head);\n    }\n};\n\nint main() {\n    MusicPlayer player;\n    \n    cout << "=== Music Playlist Application ===" << endl;\n    \n    // Add songs\n    player.addSong("Bohemian Rhapsody", "Queen", 354);\n    player.addSong("Stairway to Heaven", "Led Zeppelin", 482);\n    player.addSong("Hotel California", "Eagles", 391);\n    player.addSong("Imagine", "John Lennon", 183);\n    player.addSong("Smells Like Teen Spirit", "Nirvana", 301);\n    \n    // Display playlist\n    player.displayPlaylist();\n    \n    // Play songs\n    cout << "\\n=== Playing Songs ===" << endl;\n    player.playCurrent();\n    \n    player.nextSong();\n    player.nextSong();\n    \n    player.previousSong();\n    \n    // Remove current song\n    cout << "\\n=== Removing Song ===" << endl;\n    player.removeCurrent();\n    player.displayPlaylist();\n    \n    return 0;\n}\n'})}),"\n",(0,i.jsx)(e.h3,{id:"2-browser-history",children:"2. Browser History"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <string>\n#include <stack>\nusing namespace std;\n\nclass BrowserHistory {\nprivate:\n    struct Page {\n        string url;\n        string title;\n        Page* next;\n        Page* prev;\n        \n        Page(string u, string t) : url(u), title(t), next(nullptr), prev(nullptr) {}\n        \n        void display() const {\n            cout << title << " (" << url << ")";\n        }\n    };\n    \n    Page* current;\n    Page* head;\n    \npublic:\n    BrowserHistory() : current(nullptr), head(nullptr) {}\n    \n    void visitPage(string url, string title) {\n        Page* newPage = new Page(url, title);\n        \n        // Remove forward history if we\'re not at the end\n        if(current != nullptr) {\n            // Delete all pages after current\n            Page* temp = current->next;\n            while(temp != nullptr) {\n                Page* next = temp->next;\n                cout << "Clearing forward history: ";\n                temp->display();\n                cout << endl;\n                delete temp;\n                temp = next;\n            }\n            current->next = nullptr;\n        }\n        \n        // Add new page\n        if(head == nullptr) {\n            head = newPage;\n        } else {\n            current->next = newPage;\n            newPage->prev = current;\n        }\n        \n        current = newPage;\n        \n        cout << "Visited: ";\n        newPage->display();\n        cout << endl;\n    }\n    \n    void goBack() {\n        if(current == nullptr || current->prev == nullptr) {\n            cout << "Cannot go back!" << endl;\n            return;\n        }\n        \n        current = current->prev;\n        cout << "Went back to: ";\n        current->display();\n        cout << endl;\n    }\n    \n    void goForward() {\n        if(current == nullptr || current->next == nullptr) {\n            cout << "Cannot go forward!" << endl;\n            return;\n        }\n        \n        current = current->next;\n        cout << "Went forward to: ";\n        current->display();\n        cout << endl;\n    }\n    \n    void displayHistory() {\n        if(head == nullptr) {\n            cout << "History is empty!" << endl;\n            return;\n        }\n        \n        cout << "\\n=== Browser History ===" << endl;\n        Page* temp = head;\n        int index = 1;\n        \n        while(temp != nullptr) {\n            cout << index++ << ". ";\n            temp->display();\n            if(temp == current) {\n                cout << " [CURRENT]";\n            }\n            cout << endl;\n            temp = temp->next;\n        }\n    }\n    \n    void clearHistory() {\n        cout << "\\nClearing all history..." << endl;\n        Page* temp = head;\n        \n        while(temp != nullptr) {\n            Page* next = temp->next;\n            delete temp;\n            temp = next;\n        }\n        \n        head = current = nullptr;\n        cout << "History cleared!" << endl;\n    }\n    \n    ~BrowserHistory() {\n        clearHistory();\n    }\n};\n\nint main() {\n    BrowserHistory browser;\n    \n    cout << "=== Browser History Simulation ===" << endl;\n    \n    // Visit pages\n    browser.visitPage("https://www.google.com", "Google");\n    browser.visitPage("https://www.github.com", "GitHub");\n    browser.visitPage("https://www.stackoverflow.com", "Stack Overflow");\n    \n    // Display history\n    browser.displayHistory();\n    \n    // Navigate\n    cout << "\\n=== Navigation ===" << endl;\n    browser.goBack();\n    browser.goBack();\n    \n    browser.goForward();\n    \n    // Visit new page (should clear forward history)\n    cout << "\\n=== Visiting New Page ===" << endl;\n    browser.visitPage("https://www.leetcode.com", "LeetCode");\n    browser.displayHistory();\n    \n    // Clear history\n    browser.clearHistory();\n    browser.displayHistory();\n    \n    return 0;\n}\n'})}),"\n",(0,i.jsx)(e.h2,{id:"advantages-and-disadvantages",children:"Advantages and Disadvantages"}),"\n",(0,i.jsx)(e.h3,{id:"advantages",children:"Advantages:"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Dynamic Size"}),": Can grow/shrink during runtime"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Efficient Insertions/Deletions"}),": O(1) at beginning, no shifting needed"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Memory Efficiency"}),": Uses memory only when needed"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"No Memory Wastage"}),": Unlike arrays with fixed size"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Implementation Flexibility"}),": Can implement stacks, queues, etc."]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"disadvantages",children:"Disadvantages:"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Sequential Access"}),": No random access, must traverse from head"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Memory Overhead"}),": Extra memory for pointers"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Cache Unfriendly"}),": Non-contiguous memory locations"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Reverse Traversal"}),": Difficult in singly linked lists"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Complex Implementation"}),": More error-prone than arrays"]}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"when-to-use-linked-lists",children:"When to Use Linked Lists"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Frequent insertions/deletions"})," at beginning"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Unknown data size"})," at compile time"]}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.strong,{children:"Implementing stacks/queues"})}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Memory is fragmented"})," (arrays need contiguous memory)"]}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.strong,{children:"No random access needed"})}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Dynamic data structures"})," (trees, graphs adjacency lists)"]}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,i.jsx)(e.p,{children:"Linked Lists are fundamental dynamic data structures that form the basis for many advanced data structures and algorithms."}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Key Takeaways:"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Singly Linked List"}),": Each node points to next, efficient forward traversal"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Doubly Linked List"}),": Nodes point to both next and previous, bidirectional traversal"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Circular Linked List"}),": Last node points to first, useful for round-robin"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Time Complexity"}),":","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Access: O(n)"}),"\n",(0,i.jsx)(e.li,{children:"Search: O(n)"}),"\n",(0,i.jsx)(e.li,{children:"Insert/Delete at head: O(1)"}),"\n",(0,i.jsx)(e.li,{children:"Insert/Delete at tail: O(n) (O(1) with tail pointer)"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Space Complexity"}),": O(n) + pointer overhead"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Real Applications"}),": Music players, browser history, undo/redo, symbol tables"]}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Common Patterns:"})}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Two-pointer technique"}),": Fast/slow pointers for middle detection, loop detection"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Dummy node"}),": Simplify edge cases in merge operations"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Recursive reversal"}),": Elegant but O(n) space"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Iterative reversal"}),": O(1) space, modifies list"]}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Remember:"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["Always check for ",(0,i.jsx)(e.code,{children:"nullptr"})," before dereferencing"]}),"\n",(0,i.jsx)(e.li,{children:"Free memory to avoid leaks (especially in C++)"}),"\n",(0,i.jsxs)(e.li,{children:["Consider using STL ",(0,i.jsx)(e.code,{children:"list"})," or ",(0,i.jsx)(e.code,{children:"forward_list"})," when possible"]}),"\n",(0,i.jsx)(e.li,{children:"Choose appropriate type: singly vs doubly vs circular based on needs"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"Linked Lists demonstrate elegant pointer manipulation and are essential for understanding more complex data structures like trees and graphs."}),"\n",(0,i.jsx)(e.hr,{})]})}function u(n={}){const{wrapper:e}={...(0,l.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(c,{...n})}):c(n)}},8453(n,e,t){t.d(e,{R:()=>s,x:()=>d});var i=t(6540);const l={},r=i.createContext(l);function s(n){const e=i.useContext(r);return i.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function d(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(l):n.components||l:s(n.components),i.createElement(r.Provider,{value:e},n.children)}}}]);