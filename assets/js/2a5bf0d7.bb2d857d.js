"use strict";(globalThis.webpackChunkmy_dsa_notes=globalThis.webpackChunkmy_dsa_notes||[]).push([[956],{6446(n,e,t){t.r(e),t.d(e,{assets:()=>c,contentTitle:()=>a,default:()=>u,frontMatter:()=>r,metadata:()=>s,toc:()=>l});var i=t(4848),o=t(8453);const r={},a="DSA Reference",s={id:"exercises",title:"DSA Reference",description:"DSA Euclidean Algorithm",source:"@site/docs/exercises.md",sourceDirName:".",slug:"/exercises",permalink:"/markdown-web-app/exercises",draft:!1,unlisted:!1,editUrl:"https://github.com/Kalyxon/markdown-web-app/tree/main/docs/exercises.md",tags:[],version:"current",frontMatter:{},sidebar:"dsa",previous:{title:"DSA Shortest Path Algorithms",permalink:"/markdown-web-app/shortest-path"}},c={},l=[{value:"DSA Euclidean Algorithm",id:"dsa-euclidean-algorithm",level:2},{value:"Mathematical Foundation",id:"mathematical-foundation",level:3},{value:"Basic Implementation",id:"basic-implementation",level:3},{value:"Applications of Euclidean Algorithm",id:"applications-of-euclidean-algorithm",level:3},{value:"DSA Huffman Coding",id:"dsa-huffman-coding",level:2},{value:"How Huffman Coding Works",id:"how-huffman-coding-works",level:3},{value:"Implementation",id:"implementation",level:3},{value:"Time Complexity:",id:"time-complexity",level:3},{value:"DSA The Traveling Salesman Problem (TSP)",id:"dsa-the-traveling-salesman-problem-tsp",level:2},{value:"Approaches to Solve TSP",id:"approaches-to-solve-tsp",level:3},{value:"DSA 0/1 Knapsack Problem",id:"dsa-01-knapsack-problem",level:2},{value:"Solutions",id:"solutions",level:3},{value:"DSA Memoization",id:"dsa-memoization",level:2},{value:"How Memoization Works",id:"how-memoization-works",level:3},{value:"DSA Tabulation",id:"dsa-tabulation",level:2},{value:"Comparison: Memoization vs Tabulation",id:"comparison-memoization-vs-tabulation",level:3},{value:"DSA Dynamic Programming",id:"dsa-dynamic-programming",level:2},{value:"DP Problem Patterns",id:"dp-problem-patterns",level:3},{value:"DSA Greedy Algorithms",id:"dsa-greedy-algorithms",level:2},{value:"When to Use Greedy Algorithms",id:"when-to-use-greedy-algorithms",level:3},{value:"Key Takeaways",id:"key-takeaways",level:3}];function d(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,o.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.header,{children:(0,i.jsx)(e.h1,{id:"dsa-reference",children:"DSA Reference"})}),"\n",(0,i.jsx)(e.h2,{id:"dsa-euclidean-algorithm",children:"DSA Euclidean Algorithm"}),"\n",(0,i.jsx)(e.p,{children:"The Euclidean Algorithm is an efficient method for computing the greatest common divisor (GCD) of two integers. It's one of the oldest known algorithms, dating back to ancient Greece."}),"\n",(0,i.jsx)(e.h3,{id:"mathematical-foundation",children:"Mathematical Foundation"}),"\n",(0,i.jsxs)(e.p,{children:["Given two integers a and b (where a > b), the Euclidean Algorithm is based on the principle:\n",(0,i.jsx)(e.strong,{children:"GCD(a, b) = GCD(b, a mod b)"})]}),"\n",(0,i.jsx)(e.p,{children:"This process continues until b becomes 0, at which point a is the GCD."}),"\n",(0,i.jsx)(e.h3,{id:"basic-implementation",children:"Basic Implementation"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <numeric> // for std::gcd in C++17+\nusing namespace std;\n\n// Recursive Euclidean Algorithm\nint gcdRecursive(int a, int b) {\n    if (b == 0) {\n        return a;\n    }\n    return gcdRecursive(b, a % b);\n}\n\n// Iterative Euclidean Algorithm\nint gcdIterative(int a, int b) {\n    while (b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n\n// Extended Euclidean Algorithm (also finds coefficients x, y)\n// such that ax + by = gcd(a, b)\nstruct ExtendedGCD {\n    int gcd;\n    int x;\n    int y;\n};\n\nExtendedGCD extendedGCD(int a, int b) {\n    if (b == 0) {\n        return {a, 1, 0};\n    }\n    \n    ExtendedGCD result = extendedGCD(b, a % b);\n    return {\n        result.gcd,\n        result.y,\n        result.x - (a / b) * result.y\n    };\n}\n\n// Binary GCD (Stein\'s Algorithm) - efficient for computers\nint binaryGCD(int a, int b) {\n    if (a == 0) return b;\n    if (b == 0) return a;\n    \n    // Find greatest power of 2 dividing both\n    int shift = 0;\n    while (((a | b) & 1) == 0) { // Both even\n        a >>= 1;\n        b >>= 1;\n        shift++;\n    }\n    \n    // Remove remaining factors of 2 from a\n    while ((a & 1) == 0) {\n        a >>= 1;\n    }\n    \n    // Now a is odd\n    do {\n        // Remove factors of 2 from b\n        while ((b & 1) == 0) {\n            b >>= 1;\n        }\n        \n        // Ensure a >= b\n        if (a > b) {\n            swap(a, b);\n        }\n        \n        b = b - a;\n    } while (b != 0);\n    \n    // Restore common factors of 2\n    return a << shift;\n}\n\nint main() {\n    int a = 56, b = 98;\n    \n    cout << "Finding GCD of " << a << " and " << b << ":" << endl;\n    cout << "Recursive GCD: " << gcdRecursive(a, b) << endl;\n    cout << "Iterative GCD: " << gcdIterative(a, b) << endl;\n    cout << "Binary GCD: " << binaryGCD(a, b) << endl;\n    \n    ExtendedGCD result = extendedGCD(a, b);\n    cout << "\\nExtended Euclidean Algorithm:" << endl;\n    cout << a << " \xd7 " << result.x << " + " << b << " \xd7 " << result.y \n         << " = " << result.gcd << endl;\n    \n    // Using built-in (C++17+)\n    cout << "std::gcd: " << gcd(a, b) << endl;\n    \n    return 0;\n}\n'})}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Output:"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"Finding GCD of 56 and 98:\nRecursive GCD: 14\nIterative GCD: 14\nBinary GCD: 14\n\nExtended Euclidean Algorithm:\n56 \xd7 -3 + 98 \xd7 2 = 14\nstd::gcd: 14\n"})}),"\n",(0,i.jsx)(e.h3,{id:"applications-of-euclidean-algorithm",children:"Applications of Euclidean Algorithm"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <vector>\nusing namespace std;\n\n// 1. Simplify fractions\nvoid simplifyFraction(int numerator, int denominator) {\n    int g = gcdRecursive(numerator, denominator);\n    cout << numerator << "/" << denominator << " = " \n         << numerator/g << "/" << denominator/g << endl;\n}\n\n// 2. Check if numbers are coprime (relatively prime)\nbool areCoprime(int a, int b) {\n    return gcdRecursive(a, b) == 1;\n}\n\n// 3. Find LCM using GCD\nint lcm(int a, int b) {\n    return (a / gcdRecursive(a, b)) * b; // Avoid overflow\n}\n\n// 4. Solve linear Diophantine equations ax + by = c\nbool solveDiophantine(int a, int b, int c, int &x, int &y) {\n    ExtendedGCD egcd = extendedGCD(a, b);\n    \n    if (c % egcd.gcd != 0) {\n        return false; // No solution\n    }\n    \n    x = egcd.x * (c / egcd.gcd);\n    y = egcd.y * (c / egcd.gcd);\n    return true;\n}\n\n// 5. Modular inverse using extended Euclidean\nint modInverse(int a, int m) {\n    ExtendedGCD egcd = extendedGCD(a, m);\n    if (egcd.gcd != 1) {\n        return -1; // Inverse doesn\'t exist\n    }\n    // Ensure positive result\n    return (egcd.x % m + m) % m;\n}\n\nint main() {\n    cout << "\\n=== Applications of Euclidean Algorithm ===" << endl;\n    \n    // Simplify fraction\n    simplifyFraction(24, 36);\n    \n    // Check coprime\n    cout << "Are 15 and 28 coprime? " << (areCoprime(15, 28) ? "Yes" : "No") << endl;\n    \n    // Find LCM\n    cout << "LCM of 12 and 18: " << lcm(12, 18) << endl;\n    \n    // Solve Diophantine equation\n    int x, y;\n    if (solveDiophantine(3, 5, 16, x, y)) {\n        cout << "Solution to 3x + 5y = 16: x=" << x << ", y=" << y << endl;\n    }\n    \n    // Modular inverse\n    int inv = modInverse(3, 11);\n    if (inv != -1) {\n        cout << "Modular inverse of 3 mod 11: " << inv << endl;\n        cout << "Verification: 3 * " << inv << " mod 11 = " << (3 * inv) % 11 << endl;\n    }\n    \n    return 0;\n}\n'})}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Time Complexity:"})," O(log min(a, b))\n",(0,i.jsx)(e.strong,{children:"Space Complexity:"})," O(1) for iterative, O(log n) for recursive"]}),"\n",(0,i.jsx)(e.h2,{id:"dsa-huffman-coding",children:"DSA Huffman Coding"}),"\n",(0,i.jsx)(e.p,{children:"Huffman Coding is a lossless data compression algorithm that assigns variable-length codes to characters based on their frequencies. More frequent characters get shorter codes, less frequent get longer codes."}),"\n",(0,i.jsx)(e.h3,{id:"how-huffman-coding-works",children:"How Huffman Coding Works"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsx)(e.li,{children:"Calculate frequency of each character in input"}),"\n",(0,i.jsx)(e.li,{children:"Create leaf nodes for each character with their frequency"}),"\n",(0,i.jsxs)(e.li,{children:["Build Huffman Tree:","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Take two nodes with smallest frequency"}),"\n",(0,i.jsx)(e.li,{children:"Create new internal node with sum of frequencies"}),"\n",(0,i.jsx)(e.li,{children:"Repeat until single node remains"}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(e.li,{children:"Traverse tree to assign codes (0 for left, 1 for right)"}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"implementation",children:"Implementation"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <queue>\n#include <unordered_map>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// Huffman Tree Node\nstruct HuffmanNode {\n    char ch;\n    int freq;\n    HuffmanNode *left, *right;\n    \n    HuffmanNode(char c, int f) : ch(c), freq(f), left(nullptr), right(nullptr) {}\n};\n\n// Comparator for priority queue\nstruct CompareNodes {\n    bool operator()(HuffmanNode* a, HuffmanNode* b) {\n        return a->freq > b->freq; // Min-heap\n    }\n};\n\nclass HuffmanCoding {\nprivate:\n    HuffmanNode* root;\n    unordered_map<char, string> huffmanCodes;\n    \n    // Build Huffman Tree\n    void buildTree(const string& text) {\n        // Count frequencies\n        unordered_map<char, int> freq;\n        for (char ch : text) {\n            freq[ch]++;\n        }\n        \n        // Create priority queue of leaf nodes\n        priority_queue<HuffmanNode*, vector<HuffmanNode*>, CompareNodes> pq;\n        \n        cout << "Character Frequencies:" << endl;\n        for (auto& pair : freq) {\n            cout << "\'" << pair.first << "\': " << pair.second << endl;\n            pq.push(new HuffmanNode(pair.first, pair.second));\n        }\n        \n        // Build tree\n        while (pq.size() > 1) {\n            HuffmanNode* left = pq.top(); pq.pop();\n            HuffmanNode* right = pq.top(); pq.pop();\n            \n            HuffmanNode* parent = new HuffmanNode(\'\\0\', left->freq + right->freq);\n            parent->left = left;\n            parent->right = right;\n            \n            pq.push(parent);\n        }\n        \n        root = pq.top();\n        cout << "\\nRoot frequency: " << root->freq << endl;\n    }\n    \n    // Generate codes by traversing tree\n    void generateCodes(HuffmanNode* node, string code) {\n        if (!node) return;\n        \n        if (node->ch != \'\\0\') { // Leaf node\n            huffmanCodes[node->ch] = code;\n            cout << "\'" << node->ch << "\': " << code << endl;\n            return;\n        }\n        \n        generateCodes(node->left, code + "0");\n        generateCodes(node->right, code + "1");\n    }\n    \npublic:\n    HuffmanCoding(const string& text) {\n        cout << "Original Text: " << text << endl;\n        cout << "Original size: " << text.length() * 8 << " bits\\n" << endl;\n        \n        buildTree(text);\n        \n        cout << "\\nHuffman Codes:" << endl;\n        generateCodes(root, "");\n    }\n    \n    // Encode text\n    string encode(const string& text) {\n        string encoded = "";\n        for (char ch : text) {\n            encoded += huffmanCodes[ch];\n        }\n        return encoded;\n    }\n    \n    // Decode encoded string\n    string decode(const string& encoded) {\n        string decoded = "";\n        HuffmanNode* current = root;\n        \n        for (char bit : encoded) {\n            if (bit == \'0\') {\n                current = current->left;\n            } else {\n                current = current->right;\n            }\n            \n            if (current->ch != \'\\0\') { // Found leaf\n                decoded += current->ch;\n                current = root;\n            }\n        }\n        \n        return decoded;\n    }\n    \n    // Calculate compression ratio\n    void compressionStats(const string& text) {\n        string encoded = encode(text);\n        int originalBits = text.length() * 8;\n        int encodedBits = encoded.length();\n        \n        cout << "\\n=== Compression Statistics ===" << endl;\n        cout << "Original bits: " << originalBits << endl;\n        cout << "Encoded bits: " << encodedBits << endl;\n        cout << "Compression ratio: " \n             << (double)encodedBits / originalBits * 100 << "%" << endl;\n        cout << "Space saved: " \n             << (1 - (double)encodedBits / originalBits) * 100 << "%" << endl;\n    }\n    \n    ~HuffmanCoding() {\n        // Cleanup would require tree traversal to delete nodes\n    }\n};\n\nint main() {\n    string text = "huffman coding is cool";\n    \n    HuffmanCoding huffman(text);\n    \n    string encoded = huffman.encode(text);\n    cout << "\\nEncoded: " << encoded << endl;\n    \n    string decoded = huffman.decode(encoded);\n    cout << "Decoded: " << decoded << endl;\n    \n    huffman.compressionStats(text);\n    \n    return 0;\n}\n'})}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Output:"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"Original Text: huffman coding is cool\nOriginal size: 168 bits\n\nCharacter Frequencies:\n' ': 3\n'a': 1\n'c': 2\n'd': 1\n'f': 1\n'g': 1\n'h': 1\n'i': 2\n'l': 1\n'm': 1\n'n': 2\n'o': 3\n's': 1\n'u': 1\n\nRoot frequency: 21\n\nHuffman Codes:\n' ': 00\n'o': 01\n'c': 1000\n'i': 1001\n'n': 1010\n'a': 10110\n'd': 10111\n'f': 11000\n'g': 11001\n'h': 11010\n'l': 11011\n'm': 11100\n's': 11101\n'u': 11110\n\nEncoded: 1101011111110010111000100100011001011000100111100100110110101000111101111011101\nDecoded: huffman coding is cool\n\n=== Compression Statistics ===\nOriginal bits: 168\nEncoded bits: 77\nCompression ratio: 45.8333%\nSpace saved: 54.1667%\n"})}),"\n",(0,i.jsx)(e.h3,{id:"time-complexity",children:"Time Complexity:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Building frequency table: O(n)"}),"\n",(0,i.jsx)(e.li,{children:"Building priority queue: O(k log k) where k is unique characters"}),"\n",(0,i.jsx)(e.li,{children:"Building tree: O(k log k)"}),"\n",(0,i.jsx)(e.li,{children:"Encoding/Decoding: O(n)"}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"dsa-the-traveling-salesman-problem-tsp",children:"DSA The Traveling Salesman Problem (TSP)"}),"\n",(0,i.jsx)(e.p,{children:'The Traveling Salesman Problem is an NP-hard optimization problem: "Given a list of cities and distances between them, what is the shortest possible route that visits each city exactly once and returns to the origin city?"'}),"\n",(0,i.jsx)(e.h3,{id:"approaches-to-solve-tsp",children:"Approaches to Solve TSP"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n#include <iomanip>\n#include <cmath>\nusing namespace std;\n\nclass TSP {\nprivate:\n    vector<vector<int>> distance;\n    int n; // Number of cities\n    \npublic:\n    TSP(const vector<vector<int>>& dist) : distance(dist), n(dist.size()) {}\n    \n    // 1. Brute Force (Try all permutations) - O(n!)\n    pair<vector<int>, int> bruteForce() {\n        vector<int> path(n);\n        vector<int> bestPath;\n        int minCost = INT_MAX;\n        \n        // Initialize path as 0, 1, 2, ..., n-1\n        for (int i = 0; i < n; i++) {\n            path[i] = i;\n        }\n        \n        do {\n            int currentCost = 0;\n            \n            // Calculate cost for this permutation\n            for (int i = 0; i < n - 1; i++) {\n                currentCost += distance[path[i]][path[i + 1]];\n            }\n            currentCost += distance[path[n - 1]][path[0]]; // Return to start\n            \n            if (currentCost < minCost) {\n                minCost = currentCost;\n                bestPath = path;\n            }\n            \n        } while (next_permutation(path.begin() + 1, path.end())); // Keep 0 fixed as start\n        \n        return {bestPath, minCost};\n    }\n    \n    // 2. Dynamic Programming with Bitmasking - O(n\xb2 * 2\u207f)\n    pair<vector<int>, int> dpBitmask() {\n        int totalStates = 1 << n;\n        vector<vector<int>> dp(totalStates, vector<int>(n, INT_MAX));\n        vector<vector<int>> parent(totalStates, vector<int>(n, -1));\n        \n        // Base case: starting at city 0\n        dp[1][0] = 0; // Binary 1 means only city 0 visited\n        \n        // Fill DP table\n        for (int mask = 1; mask < totalStates; mask++) {\n            for (int last = 0; last < n; last++) {\n                if (dp[mask][last] == INT_MAX) continue;\n                if (!(mask & (1 << last))) continue;\n                \n                // Try all unvisited cities as next\n                for (int next = 0; next < n; next++) {\n                    if (mask & (1 << next)) continue; // Already visited\n                    \n                    int newMask = mask | (1 << next);\n                    int newCost = dp[mask][last] + distance[last][next];\n                    \n                    if (newCost < dp[newMask][next]) {\n                        dp[newMask][next] = newCost;\n                        parent[newMask][next] = last;\n                    }\n                }\n            }\n        }\n        \n        // Find minimum cost to return to start\n        int finalMask = totalStates - 1; // All cities visited\n        int minCost = INT_MAX;\n        int lastCity = -1;\n        \n        for (int i = 1; i < n; i++) {\n            int cost = dp[finalMask][i] + distance[i][0];\n            if (cost < minCost) {\n                minCost = cost;\n                lastCity = i;\n            }\n        }\n        \n        // Reconstruct path\n        vector<int> path;\n        int mask = finalMask;\n        int current = lastCity;\n        \n        while (current != -1) {\n            path.push_back(current);\n            int prev = parent[mask][current];\n            mask &= ~(1 << current); // Remove current from mask\n            current = prev;\n        }\n        reverse(path.begin(), path.end());\n        \n        // Add starting city (0) at beginning and end\n        vector<int> fullPath = {0};\n        fullPath.insert(fullPath.end(), path.begin(), path.end());\n        fullPath.push_back(0);\n        \n        return {fullPath, minCost};\n    }\n    \n    // 3. Nearest Neighbor Heuristic - O(n\xb2)\n    pair<vector<int>, int> nearestNeighbor() {\n        vector<bool> visited(n, false);\n        vector<int> path = {0}; // Start at city 0\n        visited[0] = true;\n        int totalCost = 0;\n        \n        int current = 0;\n        for (int i = 0; i < n - 1; i++) {\n            int nearest = -1;\n            int minDist = INT_MAX;\n            \n            // Find nearest unvisited city\n            for (int next = 0; next < n; next++) {\n                if (!visited[next] && distance[current][next] < minDist) {\n                    minDist = distance[current][next];\n                    nearest = next;\n                }\n            }\n            \n            path.push_back(nearest);\n            visited[nearest] = true;\n            totalCost += minDist;\n            current = nearest;\n        }\n        \n        // Return to start\n        totalCost += distance[current][0];\n        path.push_back(0);\n        \n        return {path, totalCost};\n    }\n    \n    // 4. 2-opt Local Search Improvement\n    vector<int> twoOptSwap(const vector<int>& path, int i, int k) {\n        vector<int> newPath = path;\n        reverse(newPath.begin() + i + 1, newPath.begin() + k + 1);\n        return newPath;\n    }\n    \n    pair<vector<int>, int> twoOptImprovement(const vector<int>& initialPath, int initialCost) {\n        vector<int> bestPath = initialPath;\n        int bestCost = initialCost;\n        bool improved = true;\n        \n        while (improved) {\n            improved = false;\n            \n            for (int i = 1; i < n; i++) {\n                for (int k = i + 1; k <= n; k++) {\n                    vector<int> newPath = twoOptSwap(bestPath, i, k);\n                    int newCost = calculatePathCost(newPath);\n                    \n                    if (newCost < bestCost) {\n                        bestPath = newPath;\n                        bestCost = newCost;\n                        improved = true;\n                    }\n                }\n            }\n        }\n        \n        return {bestPath, bestCost};\n    }\n    \n    int calculatePathCost(const vector<int>& path) {\n        int cost = 0;\n        for (int i = 0; i < path.size() - 1; i++) {\n            cost += distance[path[i]][path[i + 1]];\n        }\n        return cost;\n    }\n    \n    // Print distance matrix\n    void printDistanceMatrix() {\n        cout << "Distance Matrix:" << endl;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                cout << setw(4) << distance[i][j] << " ";\n            }\n            cout << endl;\n        }\n    }\n};\n\nint main() {\n    // Example: 5 cities\n    vector<vector<int>> distances = {\n        {0, 10, 15, 20, 25},\n        {10, 0, 35, 25, 30},\n        {15, 35, 0, 30, 20},\n        {20, 25, 30, 0, 15},\n        {25, 30, 20, 15, 0}\n    };\n    \n    TSP tsp(distances);\n    tsp.printDistanceMatrix();\n    \n    cout << "\\n=== Solving TSP ===" << endl;\n    \n    // Brute Force (works for n \u2264 10)\n    if (distances.size() <= 10) {\n        auto [bfPath, bfCost] = tsp.bruteForce();\n        cout << "\\nBrute Force Solution:" << endl;\n        cout << "Path: ";\n        for (int city : bfPath) cout << city << " ";\n        cout << "\\nCost: " << bfCost << endl;\n    }\n    \n    // Dynamic Programming (works for n \u2264 20)\n    auto [dpPath, dpCost] = tsp.dpBitmask();\n    cout << "\\nDP with Bitmasking Solution:" << endl;\n    cout << "Path: ";\n    for (int city : dpPath) cout << city << " ";\n    cout << "\\nCost: " << dpCost << endl;\n    \n    // Nearest Neighbor Heuristic\n    auto [nnPath, nnCost] = tsp.nearestNeighbor();\n    cout << "\\nNearest Neighbor Heuristic:" << endl;\n    cout << "Path: ";\n    for (int city : nnPath) cout << city << " ";\n    cout << "\\nCost: " << nnCost << endl;\n    \n    // Improve with 2-opt\n    auto [optPath, optCost] = tsp.twoOptImprovement(nnPath, nnCost);\n    cout << "\\nAfter 2-opt Improvement:" << endl;\n    cout << "Path: ";\n    for (int city : optPath) cout << city << " ";\n    cout << "\\nCost: " << optCost << endl;\n    \n    return 0;\n}\n'})}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Complexity Comparison:"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Brute Force: O(n!)"}),"\n",(0,i.jsx)(e.li,{children:"DP with Bitmasking: O(n\xb2 \xd7 2\u207f)"}),"\n",(0,i.jsx)(e.li,{children:"Nearest Neighbor: O(n\xb2)"}),"\n",(0,i.jsx)(e.li,{children:"2-opt: O(n\xb2) per iteration"}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"dsa-01-knapsack-problem",children:"DSA 0/1 Knapsack Problem"}),"\n",(0,i.jsx)(e.p,{children:"The 0/1 Knapsack Problem: Given weights and values of n items, put these items in a knapsack of capacity W to get maximum total value. You cannot break items (0/1 property)."}),"\n",(0,i.jsx)(e.h3,{id:"solutions",children:"Solutions"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nclass Knapsack {\nprivate:\n    vector<int> weights;\n    vector<int> values;\n    int capacity;\n    int n;\n    \npublic:\n    Knapsack(const vector<int>& w, const vector<int>& v, int cap) \n        : weights(w), values(v), capacity(cap), n(w.size()) {}\n    \n    // 1. Recursive Solution (Exponential)\n    int recursiveKnapsack(int i, int remaining) {\n        if (i == 0 || remaining == 0) {\n            return 0;\n        }\n        \n        // If weight of current item > remaining capacity, skip it\n        if (weights[i-1] > remaining) {\n            return recursiveKnapsack(i-1, remaining);\n        }\n        \n        // Return maximum of:\n        // 1. Including current item\n        // 2. Excluding current item\n        return max(\n            values[i-1] + recursiveKnapsack(i-1, remaining - weights[i-1]),\n            recursiveKnapsack(i-1, remaining)\n        );\n    }\n    \n    // 2. Memoization (Top-down DP)\n    int memoizationKnapsack() {\n        vector<vector<int>> memo(n+1, vector<int>(capacity+1, -1));\n        return memoHelper(n, capacity, memo);\n    }\n    \n    int memoHelper(int i, int remaining, vector<vector<int>>& memo) {\n        if (i == 0 || remaining == 0) {\n            return 0;\n        }\n        \n        if (memo[i][remaining] != -1) {\n            return memo[i][remaining];\n        }\n        \n        if (weights[i-1] > remaining) {\n            memo[i][remaining] = memoHelper(i-1, remaining, memo);\n        } else {\n            memo[i][remaining] = max(\n                values[i-1] + memoHelper(i-1, remaining - weights[i-1], memo),\n                memoHelper(i-1, remaining, memo)\n            );\n        }\n        \n        return memo[i][remaining];\n    }\n    \n    // 3. Tabulation (Bottom-up DP)\n    int tabulationKnapsack() {\n        vector<vector<int>> dp(n+1, vector<int>(capacity+1, 0));\n        \n        // Build table\n        for (int i = 1; i <= n; i++) {\n            for (int w = 0; w <= capacity; w++) {\n                if (weights[i-1] > w) {\n                    dp[i][w] = dp[i-1][w];\n                } else {\n                    dp[i][w] = max(\n                        dp[i-1][w],\n                        values[i-1] + dp[i-1][w - weights[i-1]]\n                    );\n                }\n            }\n        }\n        \n        // Optional: Print selected items\n        cout << "\\nSelected items:" << endl;\n        int w = capacity;\n        int totalValue = dp[n][capacity];\n        \n        for (int i = n; i > 0 && totalValue > 0; i--) {\n            if (totalValue != dp[i-1][w]) {\n                cout << "Item " << i << " (weight: " << weights[i-1] \n                     << ", value: " << values[i-1] << ")" << endl;\n                totalValue -= values[i-1];\n                w -= weights[i-1];\n            }\n        }\n        \n        return dp[n][capacity];\n    }\n    \n    // 4. Space Optimized DP (1D array)\n    int spaceOptimizedKnapsack() {\n        vector<int> dp(capacity+1, 0);\n        \n        for (int i = 0; i < n; i++) {\n            // Traverse backwards to prevent reusing same item\n            for (int w = capacity; w >= weights[i]; w--) {\n                dp[w] = max(dp[w], values[i] + dp[w - weights[i]]);\n            }\n            \n            // Print DP array after each item\n            cout << "After item " << i+1 << ": ";\n            for (int w = 0; w <= capacity; w++) {\n                cout << dp[w] << " ";\n            }\n            cout << endl;\n        }\n        \n        return dp[capacity];\n    }\n    \n    // 5. Meet in the Middle (for large n)\n    int meetInMiddle() {\n        // Split items into two halves\n        int mid = n / 2;\n        \n        // Generate all subsets of first half\n        vector<pair<int, int>> firstHalf;\n        for (int mask = 0; mask < (1 << mid); mask++) {\n            int weight = 0, value = 0;\n            for (int i = 0; i < mid; i++) {\n                if (mask & (1 << i)) {\n                    weight += weights[i];\n                    value += values[i];\n                }\n            }\n            if (weight <= capacity) {\n                firstHalf.push_back({weight, value});\n            }\n        }\n        \n        // Sort first half by weight\n        sort(firstHalf.begin(), firstHalf.end());\n        \n        // Remove dominated pairs (if weight increases but value doesn\'t)\n        vector<pair<int, int>> filtered;\n        int maxValue = -1;\n        for (auto& p : firstHalf) {\n            if (p.second > maxValue) {\n                filtered.push_back(p);\n                maxValue = p.second;\n            }\n        }\n        \n        // Generate subsets of second half and combine\n        int best = 0;\n        int secondHalfSize = n - mid;\n        \n        for (int mask = 0; mask < (1 << secondHalfSize); mask++) {\n            int weight = 0, value = 0;\n            for (int i = 0; i < secondHalfSize; i++) {\n                if (mask & (1 << i)) {\n                    weight += weights[mid + i];\n                    value += values[mid + i];\n                }\n            }\n            \n            if (weight <= capacity) {\n                // Find best match from first half\n                int remaining = capacity - weight;\n                auto it = upper_bound(filtered.begin(), filtered.end(), \n                                     make_pair(remaining, INT_MAX));\n                if (it != filtered.begin()) {\n                    it--;\n                    best = max(best, value + it->second);\n                } else {\n                    best = max(best, value);\n                }\n            }\n        }\n        \n        return best;\n    }\n    \n    void printItems() {\n        cout << "\\nItems:" << endl;\n        cout << "Index\\tWeight\\tValue" << endl;\n        for (int i = 0; i < n; i++) {\n            cout << i+1 << "\\t" << weights[i] << "\\t" << values[i] << endl;\n        }\n        cout << "Capacity: " << capacity << endl;\n    }\n};\n\nint main() {\n    vector<int> weights = {2, 3, 4, 5};\n    vector<int> values = {3, 4, 5, 6};\n    int capacity = 5;\n    \n    Knapsack knapsack(weights, values, capacity);\n    knapsack.printItems();\n    \n    cout << "\\n=== Solving 0/1 Knapsack ===" << endl;\n    \n    // Recursive\n    cout << "\\nRecursive Solution: " \n         << knapsack.recursiveKnapsack(weights.size(), capacity) << endl;\n    \n    // Memoization\n    cout << "Memoization Solution: " \n         << knapsack.memoizationKnapsack() << endl;\n    \n    // Tabulation\n    cout << "\\nTabulation Solution: " \n         << knapsack.tabulationKnapsack() << endl;\n    \n    // Space Optimized\n    cout << "\\nSpace Optimized Solution:" << endl;\n    cout << "Maximum value: " << knapsack.spaceOptimizedKnapsack() << endl;\n    \n    // Meet in the Middle\n    cout << "\\nMeet in the Middle: " \n         << knapsack.meetInMiddle() << endl;\n    \n    return 0;\n}\n'})}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Output:"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"Items:\nIndex   Weight  Value\n1       2       3\n2       3       4\n3       4       5\n4       5       6\nCapacity: 5\n\n=== Solving 0/1 Knapsack ===\n\nRecursive Solution: 7\nMemoization Solution: 7\n\nTabulation Solution:\nSelected items:\nItem 2 (weight: 3, value: 4)\nItem 1 (weight: 2, value: 3)\nMaximum value: 7\n\nSpace Optimized Solution:\nAfter item 1: 0 0 3 3 3 3 \nAfter item 2: 0 0 3 4 4 7 \nAfter item 3: 0 0 3 4 5 7 \nAfter item 4: 0 0 3 4 5 7 \nMaximum value: 7\n\nMeet in the Middle: 7\n"})}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Complexity:"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Recursive: O(2\u207f)"}),"\n",(0,i.jsx)(e.li,{children:"Memoization/Tabulation: O(n \xd7 W)"}),"\n",(0,i.jsx)(e.li,{children:"Space Optimized: O(W)"}),"\n",(0,i.jsx)(e.li,{children:"Meet in the Middle: O(2^(n/2) \xd7 n)"}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"dsa-memoization",children:"DSA Memoization"}),"\n",(0,i.jsx)(e.p,{children:"Memoization is an optimization technique that stores results of expensive function calls and returns cached result when same inputs occur again."}),"\n",(0,i.jsx)(e.h3,{id:"how-memoization-works",children:"How Memoization Works"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <unordered_map>\n#include <chrono>\n#include <vector>\nusing namespace std;\nusing namespace std::chrono;\n\n// 1. Classic Fibonacci Example\nclass Fibonacci {\nprivate:\n    unordered_map<int, long long> memo;\n    \npublic:\n    // Without memoization (exponential)\n    long long fibNaive(int n) {\n        if (n <= 1) return n;\n        return fibNaive(n-1) + fibNaive(n-2);\n    }\n    \n    // With memoization (linear)\n    long long fibMemo(int n) {\n        if (n <= 1) return n;\n        \n        if (memo.find(n) != memo.end()) {\n            return memo[n];\n        }\n        \n        memo[n] = fibMemo(n-1) + fibMemo(n-2);\n        return memo[n];\n    }\n    \n    // Tabulation version\n    long long fibTab(int n) {\n        if (n <= 1) return n;\n        \n        vector<long long> dp(n+1);\n        dp[0] = 0;\n        dp[1] = 1;\n        \n        for (int i = 2; i <= n; i++) {\n            dp[i] = dp[i-1] + dp[i-2];\n        }\n        \n        return dp[n];\n    }\n    \n    // Space optimized\n    long long fibOptimized(int n) {\n        if (n <= 1) return n;\n        \n        long long a = 0, b = 1, c;\n        for (int i = 2; i <= n; i++) {\n            c = a + b;\n            a = b;\n            b = c;\n        }\n        return b;\n    }\n};\n\n// 2. Grid Traveler Problem\n// How many ways to travel from top-left to bottom-right in m\xd7n grid?\nclass GridTraveler {\nprivate:\n    unordered_map<string, long long> memo;\n    \npublic:\n    long long gridTraveler(int m, int n) {\n        string key = to_string(m) + "," + to_string(n);\n        \n        if (memo.find(key) != memo.end()) {\n            return memo[key];\n        }\n        \n        if (m == 1 && n == 1) return 1;\n        if (m == 0 || n == 0) return 0;\n        \n        memo[key] = gridTraveler(m-1, n) + gridTraveler(m, n-1);\n        return memo[key];\n    }\n};\n\n// 3. CanSum Problem\n// Can we achieve target sum using numbers from array?\nclass CanSum {\nprivate:\n    unordered_map<int, bool> memo;\n    \npublic:\n    bool canSum(int target, const vector<int>& numbers) {\n        if (memo.find(target) != memo.end()) return memo[target];\n        if (target == 0) return true;\n        if (target < 0) return false;\n        \n        for (int num : numbers) {\n            int remainder = target - num;\n            if (canSum(remainder, numbers)) {\n                memo[target] = true;\n                return true;\n            }\n        }\n        \n        memo[target] = false;\n        return false;\n    }\n};\n\n// 4. HowSum Problem\n// Return any combination that sums to target\nclass HowSum {\nprivate:\n    unordered_map<int, vector<int>> memo;\n    \npublic:\n    vector<int> howSum(int target, const vector<int>& numbers) {\n        if (memo.find(target) != memo.end()) return memo[target];\n        if (target == 0) return {};\n        if (target < 0) return {INT_MIN}; // Sentinel for impossible\n        \n        for (int num : numbers) {\n            int remainder = target - num;\n            vector<int> remainderResult = howSum(remainder, numbers);\n            \n            if (!remainderResult.empty() || remainder == 0) {\n                remainderResult.push_back(num);\n                memo[target] = remainderResult;\n                return remainderResult;\n            }\n        }\n        \n        memo[target] = {INT_MIN};\n        return {INT_MIN};\n    }\n};\n\n// 5. BestSum Problem\n// Return shortest combination that sums to target\nclass BestSum {\nprivate:\n    unordered_map<int, vector<int>> memo;\n    \npublic:\n    vector<int> bestSum(int target, const vector<int>& numbers) {\n        if (memo.find(target) != memo.end()) return memo[target];\n        if (target == 0) return {};\n        if (target < 0) return {INT_MIN};\n        \n        vector<int> shortest = {INT_MIN};\n        \n        for (int num : numbers) {\n            int remainder = target - num;\n            vector<int> combination = bestSum(remainder, numbers);\n            \n            if (combination.empty() || combination[0] != INT_MIN) {\n                combination.push_back(num);\n                \n                if (shortest[0] == INT_MIN || combination.size() < shortest.size()) {\n                    shortest = combination;\n                }\n            }\n        }\n        \n        memo[target] = shortest;\n        return shortest;\n    }\n};\n\n// Generic Memoization Decorator Template\ntemplate<typename ReturnType, typename... Args>\nclass Memoizer {\nprivate:\n    using FunctionType = std::function<ReturnType(Args...)>;\n    FunctionType func;\n    unordered_map<string, ReturnType> cache;\n    \n    string createKey(Args... args) {\n        string key;\n        ((key += to_string(args) + ","), ...);\n        return key;\n    }\n    \npublic:\n    Memoizer(FunctionType f) : func(f) {}\n    \n    ReturnType operator()(Args... args) {\n        string key = createKey(args...);\n        \n        if (cache.find(key) != cache.end()) {\n            return cache[key];\n        }\n        \n        ReturnType result = func(args...);\n        cache[key] = result;\n        return result;\n    }\n};\n\nint main() {\n    cout << "=== Memoization Examples ===\\n" << endl;\n    \n    // Fibonacci\n    Fibonacci fib;\n    int n = 40;\n    \n    auto start = high_resolution_clock::now();\n    cout << "Fibonacci(" << n << ") naive: " << fib.fibNaive(n) << endl;\n    auto end = high_resolution_clock::now();\n    cout << "Time: " << duration_cast<milliseconds>(end-start).count() << "ms\\n" << endl;\n    \n    start = high_resolution_clock::now();\n    cout << "Fibonacci(" << n << ") memoized: " << fib.fibMemo(n) << endl;\n    end = high_resolution_clock::now();\n    cout << "Time: " << duration_cast<microseconds>(end-start).count() << "\u03bcs\\n" << endl;\n    \n    // Grid Traveler\n    GridTraveler gt;\n    cout << "Grid Traveler(18, 18): " << gt.gridTraveler(18, 18) << endl;\n    \n    // CanSum\n    CanSum cs;\n    vector<int> numbers = {2, 3, 5};\n    cout << "\\nCanSum(8, {2,3,5}): " << (cs.canSum(8, numbers) ? "true" : "false") << endl;\n    cout << "CanSum(7, {2,4}): " << (cs.canSum(7, {2,4}) ? "true" : "false") << endl;\n    \n    // HowSum\n    HowSum hs;\n    vector<int> result = hs.howSum(8, numbers);\n    cout << "\\nHowSum(8, {2,3,5}): ";\n    if (result[0] == INT_MIN) {\n        cout << "null";\n    } else {\n        for (int num : result) cout << num << " ";\n    }\n    cout << endl;\n    \n    // BestSum\n    BestSum bs;\n    result = bs.bestSum(8, {2, 3, 5});\n    cout << "\\nBestSum(8, {2,3,5}): ";\n    if (result[0] == INT_MIN) {\n        cout << "null";\n    } else {\n        for (int num : result) cout << num << " ";\n    }\n    cout << endl;\n    \n    // Using generic memoizer\n    cout << "\\n=== Generic Memoizer ===" << endl;\n    \n    // Memoize a simple function\n    function<int(int, int)> add = [](int a, int b) {\n        cout << "Computing " << a << " + " << b << endl;\n        return a + b;\n    };\n    \n    Memoizer<int, int, int> memoizedAdd(add);\n    \n    cout << "First call (should compute): " << memoizedAdd(5, 3) << endl;\n    cout << "Second call (should use cache): " << memoizedAdd(5, 3) << endl;\n    cout << "Different call (should compute): " << memoizedAdd(5, 4) << endl;\n    \n    return 0;\n}\n'})}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Key Benefits of Memoization:"})}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsx)(e.li,{children:"Eliminates redundant calculations"}),"\n",(0,i.jsx)(e.li,{children:"Converts exponential time to polynomial time"}),"\n",(0,i.jsx)(e.li,{children:"Easy to implement for recursive functions"}),"\n",(0,i.jsx)(e.li,{children:"Automatic cache management"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"When to Use Memoization:"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Overlapping subproblems"}),"\n",(0,i.jsx)(e.li,{children:"Optimal substructure"}),"\n",(0,i.jsx)(e.li,{children:"Function is pure (deterministic)"}),"\n",(0,i.jsx)(e.li,{children:"Computation is expensive"}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"dsa-tabulation",children:"DSA Tabulation"}),"\n",(0,i.jsx)(e.p,{children:"Tabulation is a bottom-up dynamic programming approach that builds solutions iteratively from base cases to the desired solution."}),"\n",(0,i.jsx)(e.h3,{id:"comparison-memoization-vs-tabulation",children:"Comparison: Memoization vs Tabulation"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nclass TabulationExamples {\npublic:\n    // 1. Fibonacci using tabulation\n    long long fibTab(int n) {\n        if (n <= 1) return n;\n        \n        vector<long long> table(n+1);\n        table[0] = 0;\n        table[1] = 1;\n        \n        cout << "Building table:" << endl;\n        cout << "table[0] = 0" << endl;\n        cout << "table[1] = 1" << endl;\n        \n        for (int i = 2; i <= n; i++) {\n            table[i] = table[i-1] + table[i-2];\n            cout << "table[" << i << "] = table[" << i-1 << "] + table[" << i-2 << "] = "\n                 << table[i-1] << " + " << table[i-2] << " = " << table[i] << endl;\n        }\n        \n        return table[n];\n    }\n    \n    // 2. Grid Traveler using tabulation\n    long long gridTravelerTab(int m, int n) {\n        vector<vector<long long>> table(m+1, vector<long long>(n+1, 0));\n        table[1][1] = 1;\n        \n        for (int i = 0; i <= m; i++) {\n            for (int j = 0; j <= n; j++) {\n                if (i+1 <= m) table[i+1][j] += table[i][j];\n                if (j+1 <= n) table[i][j+1] += table[i][j];\n            }\n        }\n        \n        // Visualization\n        cout << "\\nGrid Traveler Table (" << m << "x" << n << "):" << endl;\n        for (int i = 0; i <= m; i++) {\n            for (int j = 0; j <= n; j++) {\n                cout << table[i][j] << "\\t";\n            }\n            cout << endl;\n        }\n        \n        return table[m][n];\n    }\n    \n    // 3. CanSum using tabulation\n    bool canSumTab(int target, const vector<int>& numbers) {\n        vector<bool> table(target+1, false);\n        table[0] = true; // Base case: sum 0 is always possible\n        \n        cout << "\\nCanSum Table for target " << target << ":" << endl;\n        cout << "table[0] = true (base case)" << endl;\n        \n        for (int i = 0; i <= target; i++) {\n            if (table[i]) {\n                for (int num : numbers) {\n                    if (i + num <= target) {\n                        if (!table[i + num]) {\n                            table[i + num] = true;\n                            cout << "table[" << i+num << "] = true (from " << i << " + " << num << ")" << endl;\n                        }\n                    }\n                }\n            }\n        }\n        \n        return table[target];\n    }\n    \n    // 4. HowSum using tabulation\n    vector<int> howSumTab(int target, const vector<int>& numbers) {\n        vector<vector<int>> table(target+1);\n        table[0] = {}; // Base case\n        \n        for (int i = 0; i <= target; i++) {\n            if (!table[i].empty() || i == 0) {\n                for (int num : numbers) {\n                    if (i + num <= target) {\n                        // If current combination is better (shorter) or first time\n                        if (table[i + num].empty() || \n                            table[i].size() + 1 < table[i + num].size()) {\n                            table[i + num] = table[i];\n                            table[i + num].push_back(num);\n                        }\n                    }\n                }\n            }\n        }\n        \n        // Visualization\n        cout << "\\nHowSum Table:" << endl;\n        for (int i = 0; i <= target; i++) {\n            cout << "table[" << i << "] = ";\n            if (table[i].empty()) {\n                cout << "[]";\n            } else {\n                for (int num : table[i]) {\n                    cout << num << " ";\n                }\n            }\n            cout << endl;\n        }\n        \n        return table[target];\n    }\n    \n    // 5. BestSum using tabulation\n    vector<int> bestSumTab(int target, const vector<int>& numbers) {\n        vector<vector<int>> table(target+1);\n        \n        for (int i = 0; i <= target; i++) {\n            if (i == 0 || !table[i].empty()) {\n                for (int num : numbers) {\n                    if (i + num <= target) {\n                        vector<int> combination = table[i];\n                        combination.push_back(num);\n                        \n                        if (table[i + num].empty() || \n                            combination.size() < table[i + num].size()) {\n                            table[i + num] = combination;\n                        }\n                    }\n                }\n            }\n        }\n        \n        return table[target];\n    }\n    \n    // 6. Coin Change Problem (Minimum coins)\n    int coinChangeTab(const vector<int>& coins, int amount) {\n        vector<int> dp(amount+1, amount+1); // Initialize with invalid value\n        dp[0] = 0; // 0 coins needed for amount 0\n        \n        for (int i = 1; i <= amount; i++) {\n            for (int coin : coins) {\n                if (coin <= i) {\n                    dp[i] = min(dp[i], dp[i - coin] + 1);\n                }\n            }\n        }\n        \n        // Visualization\n        cout << "\\nCoin Change Table:" << endl;\n        for (int i = 0; i <= amount; i++) {\n            cout << "Amount " << i << ": ";\n            if (dp[i] > amount) {\n                cout << "Not possible";\n            } else {\n                cout << dp[i] << " coins";\n            }\n            cout << endl;\n        }\n        \n        return dp[amount] > amount ? -1 : dp[amount];\n    }\n};\n\nint main() {\n    TabulationExamples tab;\n    \n    cout << "=== Tabulation Examples ===\\n" << endl;\n    \n    // Fibonacci\n    cout << "Fibonacci(10) using tabulation:" << endl;\n    long long result = tab.fibTab(10);\n    cout << "Result: " << result << "\\n" << endl;\n    \n    // Grid Traveler\n    cout << "Grid Traveler(3, 3): " << tab.gridTravelerTab(3, 3) << "\\n" << endl;\n    \n    // CanSum\n    vector<int> numbers = {2, 3, 5};\n    cout << "CanSum(8, {2,3,5}): " \n         << (tab.canSumTab(8, numbers) ? "true" : "false") << "\\n" << endl;\n    \n    // HowSum\n    vector<int> howResult = tab.howSumTab(8, numbers);\n    cout << "\\nHowSum result: ";\n    if (howResult.empty()) {\n        cout << "Not possible";\n    } else {\n        for (int num : howResult) cout << num << " ";\n    }\n    cout << "\\n" << endl;\n    \n    // Coin Change\n    vector<int> coins = {1, 2, 5};\n    int amount = 11;\n    int minCoins = tab.coinChangeTab(coins, amount);\n    cout << "\\nMinimum coins to make " << amount << ": " << minCoins << endl;\n    \n    return 0;\n}\n'})}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Tabulation vs Memoization:"})}),"\n",(0,i.jsxs)(e.table,{children:[(0,i.jsx)(e.thead,{children:(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.th,{children:"Aspect"}),(0,i.jsx)(e.th,{children:"Tabulation"}),(0,i.jsx)(e.th,{children:"Memoization"})]})}),(0,i.jsxs)(e.tbody,{children:[(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:(0,i.jsx)(e.strong,{children:"Approach"})}),(0,i.jsx)(e.td,{children:"Bottom-up"}),(0,i.jsx)(e.td,{children:"Top-down"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:(0,i.jsx)(e.strong,{children:"Implementation"})}),(0,i.jsx)(e.td,{children:"Iterative"}),(0,i.jsx)(e.td,{children:"Recursive"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:(0,i.jsx)(e.strong,{children:"Speed"})}),(0,i.jsx)(e.td,{children:"Usually faster (no recursion overhead)"}),(0,i.jsx)(e.td,{children:"Slower (recursion overhead)"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:(0,i.jsx)(e.strong,{children:"Memory"})}),(0,i.jsx)(e.td,{children:"Stores all states"}),(0,i.jsx)(e.td,{children:"Stores only needed states"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:(0,i.jsx)(e.strong,{children:"Stack Overflow"})}),(0,i.jsx)(e.td,{children:"No risk"}),(0,i.jsx)(e.td,{children:"Possible with deep recursion"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:(0,i.jsx)(e.strong,{children:"Complexity"})}),(0,i.jsx)(e.td,{children:"Easier to analyze"}),(0,i.jsx)(e.td,{children:"Harder to analyze"})]})]})]}),"\n",(0,i.jsx)(e.h2,{id:"dsa-dynamic-programming",children:"DSA Dynamic Programming"}),"\n",(0,i.jsx)(e.p,{children:"Dynamic Programming is a method for solving complex problems by breaking them down into simpler subproblems and storing their solutions to avoid redundant computations."}),"\n",(0,i.jsx)(e.h3,{id:"dp-problem-patterns",children:"DP Problem Patterns"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nclass DynamicProgramming {\npublic:\n    // Pattern 1: 0/1 Knapsack Problems\n    int knapsack(vector<int>& weights, vector<int>& values, int capacity) {\n        int n = weights.size();\n        vector<vector<int>> dp(n+1, vector<int>(capacity+1, 0));\n        \n        for (int i = 1; i <= n; i++) {\n            for (int w = 0; w <= capacity; w++) {\n                if (weights[i-1] > w) {\n                    dp[i][w] = dp[i-1][w];\n                } else {\n                    dp[i][w] = max(dp[i-1][w], \n                                  values[i-1] + dp[i-1][w - weights[i-1]]);\n                }\n            }\n        }\n        return dp[n][capacity];\n    }\n    \n    // Pattern 2: Unbounded Knapsack\n    int unboundedKnapsack(vector<int>& weights, vector<int>& values, int capacity) {\n        vector<int> dp(capacity+1, 0);\n        \n        for (int w = 0; w <= capacity; w++) {\n            for (int i = 0; i < weights.size(); i++) {\n                if (weights[i] <= w) {\n                    dp[w] = max(dp[w], values[i] + dp[w - weights[i]]);\n                }\n            }\n        }\n        return dp[capacity];\n    }\n    \n    // Pattern 3: Longest Common Subsequence\n    int longestCommonSubsequence(string text1, string text2) {\n        int m = text1.length(), n = text2.length();\n        vector<vector<int>> dp(m+1, vector<int>(n+1, 0));\n        \n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                if (text1[i-1] == text2[j-1]) {\n                    dp[i][j] = 1 + dp[i-1][j-1];\n                } else {\n                    dp[i][j] = max(dp[i-1][j], dp[i][j-1]);\n                }\n            }\n        }\n        \n        // Reconstruction\n        string lcs = "";\n        int i = m, j = n;\n        while (i > 0 && j > 0) {\n            if (text1[i-1] == text2[j-1]) {\n                lcs = text1[i-1] + lcs;\n                i--; j--;\n            } else if (dp[i-1][j] > dp[i][j-1]) {\n                i--;\n            } else {\n                j--;\n            }\n        }\n        \n        cout << "LCS: " << lcs << endl;\n        return dp[m][n];\n    }\n    \n    // Pattern 4: Longest Increasing Subsequence\n    int longestIncreasingSubsequence(vector<int>& nums) {\n        int n = nums.size();\n        vector<int> dp(n, 1);\n        vector<int> prev(n, -1);\n        int maxLen = 1, maxIdx = 0;\n        \n        for (int i = 1; i < n; i++) {\n            for (int j = 0; j < i; j++) {\n                if (nums[j] < nums[i] && dp[j] + 1 > dp[i]) {\n                    dp[i] = dp[j] + 1;\n                    prev[i] = j;\n                }\n            }\n            if (dp[i] > maxLen) {\n                maxLen = dp[i];\n                maxIdx = i;\n            }\n        }\n        \n        // Reconstruction\n        vector<int> lis;\n        for (int i = maxIdx; i != -1; i = prev[i]) {\n            lis.push_back(nums[i]);\n        }\n        reverse(lis.begin(), lis.end());\n        \n        cout << "LIS: ";\n        for (int num : lis) cout << num << " ";\n        cout << endl;\n        \n        return maxLen;\n    }\n    \n    // Pattern 5: Edit Distance\n    int editDistance(string word1, string word2) {\n        int m = word1.length(), n = word2.length();\n        vector<vector<int>> dp(m+1, vector<int>(n+1, 0));\n        \n        // Initialize\n        for (int i = 0; i <= m; i++) dp[i][0] = i;\n        for (int j = 0; j <= n; j++) dp[0][j] = j;\n        \n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                if (word1[i-1] == word2[j-1]) {\n                    dp[i][j] = dp[i-1][j-1];\n                } else {\n                    dp[i][j] = 1 + min({dp[i-1][j],    // Delete\n                                        dp[i][j-1],    // Insert\n                                        dp[i-1][j-1]}); // Replace\n                }\n            }\n        }\n        \n        // Visualization\n        cout << "\\nEdit Distance Table:" << endl;\n        cout << "   ";\n        for (int j = 0; j <= n; j++) {\n            if (j == 0) cout << "\u03b5 ";\n            else cout << word2[j-1] << " ";\n        }\n        cout << endl;\n        \n        for (int i = 0; i <= m; i++) {\n            if (i == 0) cout << "\u03b5 ";\n            else cout << word1[i-1] << " ";\n            \n            for (int j = 0; j <= n; j++) {\n                cout << dp[i][j] << " ";\n            }\n            cout << endl;\n        }\n        \n        return dp[m][n];\n    }\n    \n    // Pattern 6: Matrix Chain Multiplication\n    int matrixChainMultiplication(vector<int>& dims) {\n        int n = dims.size() - 1; // Number of matrices\n        vector<vector<int>> dp(n, vector<int>(n, 0));\n        vector<vector<int>> split(n, vector<int>(n, 0));\n        \n        for (int len = 2; len <= n; len++) {\n            for (int i = 0; i <= n - len; i++) {\n                int j = i + len - 1;\n                dp[i][j] = INT_MAX;\n                \n                for (int k = i; k < j; k++) {\n                    int cost = dp[i][k] + dp[k+1][j] + \n                               dims[i] * dims[k+1] * dims[j+1];\n                    \n                    if (cost < dp[i][j]) {\n                        dp[i][j] = cost;\n                        split[i][j] = k;\n                    }\n                }\n            }\n        }\n        \n        // Print optimal parenthesization\n        cout << "Optimal parenthesization: ";\n        printParenthesization(split, 0, n-1);\n        cout << endl;\n        \n        return dp[0][n-1];\n    }\n    \n    void printParenthesization(vector<vector<int>>& split, int i, int j) {\n        if (i == j) {\n            cout << "A" << i;\n        } else {\n            cout << "(";\n            printParenthesization(split, i, split[i][j]);\n            printParenthesization(split, split[i][j] + 1, j);\n            cout << ")";\n        }\n    }\n    \n    // Pattern 7: Rod Cutting\n    int rodCutting(vector<int>& prices, int n) {\n        vector<int> dp(n+1, 0);\n        \n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= i; j++) {\n                dp[i] = max(dp[i], prices[j-1] + dp[i-j]);\n            }\n        }\n        \n        // Reconstruction\n        cout << "Optimal cuts: ";\n        int length = n;\n        while (length > 0) {\n            for (int j = 1; j <= length; j++) {\n                if (dp[length] == prices[j-1] + dp[length-j]) {\n                    cout << j << " ";\n                    length -= j;\n                    break;\n                }\n            }\n        }\n        cout << endl;\n        \n        return dp[n];\n    }\n    \n    // Pattern 8: Coin Change II (Number of ways)\n    int coinChangeWays(vector<int>& coins, int amount) {\n        vector<int> dp(amount+1, 0);\n        dp[0] = 1;\n        \n        for (int coin : coins) {\n            for (int i = coin; i <= amount; i++) {\n                dp[i] += dp[i - coin];\n            }\n        }\n        \n        // Print DP table\n        cout << "\\nCoin Change Ways Table:" << endl;\n        for (int i = 0; i <= amount; i++) {\n            cout << "Ways to make " << i << ": " << dp[i] << endl;\n        }\n        \n        return dp[amount];\n    }\n};\n\nint main() {\n    DynamicProgramming dp;\n    \n    cout << "=== Dynamic Programming Patterns ===\\n" << endl;\n    \n    // 0/1 Knapsack\n    vector<int> weights = {1, 3, 4, 5};\n    vector<int> values = {1, 4, 5, 7};\n    cout << "0/1 Knapsack (capacity=7): " << dp.knapsack(weights, values, 7) << "\\n" << endl;\n    \n    // Unbounded Knapsack\n    cout << "Unbounded Knapsack (capacity=7): " << dp.unboundedKnapsack(weights, values, 7) << "\\n" << endl;\n    \n    // LCS\n    string text1 = "AGGTAB", text2 = "GXTXAYB";\n    cout << "LCS Length: " << dp.longestCommonSubsequence(text1, text2) << "\\n" << endl;\n    \n    // LIS\n    vector<int> nums = {10, 9, 2, 5, 3, 7, 101, 18};\n    cout << "LIS Length: " << dp.longestIncreasingSubsequence(nums) << "\\n" << endl;\n    \n    // Edit Distance\n    cout << "Edit Distance (\'horse\', \'ros\'): " << dp.editDistance("horse", "ros") << "\\n" << endl;\n    \n    // Matrix Chain Multiplication\n    vector<int> dims = {40, 20, 30, 10, 30};\n    cout << "Minimum multiplications: " << dp.matrixChainMultiplication(dims) << "\\n" << endl;\n    \n    // Rod Cutting\n    vector<int> prices = {1, 5, 8, 9, 10, 17, 17, 20};\n    int rodLength = 8;\n    cout << "Maximum rod value: " << dp.rodCutting(prices, rodLength) << "\\n" << endl;\n    \n    // Coin Change Ways\n    vector<int> coins = {1, 2, 5};\n    cout << "Ways to make 5: " << dp.coinChangeWays(coins, 5) << endl;\n    \n    return 0;\n}\n'})}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"DP Problem Identification:"})}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Optimal Substructure"}),": Optimal solution can be constructed from optimal solutions of subproblems"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Overlapping Subproblems"}),": Problem can be broken down into subproblems which are reused several times"]}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"DP Solution Steps:"})}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsx)(e.li,{children:"Define state (what does dp[i] represent?)"}),"\n",(0,i.jsx)(e.li,{children:"Define recurrence relation"}),"\n",(0,i.jsx)(e.li,{children:"Define base cases"}),"\n",(0,i.jsx)(e.li,{children:"Choose implementation (memoization or tabulation)"}),"\n",(0,i.jsx)(e.li,{children:"Add optimization if needed"}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"dsa-greedy-algorithms",children:"DSA Greedy Algorithms"}),"\n",(0,i.jsx)(e.p,{children:"Greedy Algorithms make locally optimal choices at each step with the hope of finding a global optimum. They don't reconsider previous choices."}),"\n",(0,i.jsx)(e.h3,{id:"when-to-use-greedy-algorithms",children:"When to Use Greedy Algorithms"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\nclass GreedyAlgorithms {\npublic:\n    // 1. Activity Selection Problem\n    vector<pair<int, int>> activitySelection(vector<pair<int, int>>& activities) {\n        // Sort by finish time\n        sort(activities.begin(), activities.end(), \n             [](const pair<int, int>& a, const pair<int, int>& b) {\n                 return a.second < b.second;\n             });\n        \n        vector<pair<int, int>> selected;\n        int lastFinish = 0;\n        \n        cout << "Sorted activities (start, finish):" << endl;\n        for (auto& activity : activities) {\n            cout << "(" << activity.first << ", " << activity.second << ") ";\n        }\n        cout << "\\n\\nSelected activities:" << endl;\n        \n        for (auto& activity : activities) {\n            if (activity.first >= lastFinish) {\n                selected.push_back(activity);\n                lastFinish = activity.second;\n                cout << "Select: (" << activity.first << ", " << activity.second << ")" << endl;\n            }\n        }\n        \n        return selected;\n    }\n    \n    // 2. Fractional Knapsack\n    double fractionalKnapsack(vector<pair<int, int>>& items, int capacity) {\n        // Calculate value/weight ratio and sort\n        vector<pair<double, pair<int, int>>> ratios;\n        \n        for (auto& item : items) {\n            double ratio = (double)item.second / item.first;\n            ratios.push_back({ratio, item});\n        }\n        \n        sort(ratios.rbegin(), ratios.rend()); // Descending\n        \n        double totalValue = 0;\n        int remaining = capacity;\n        \n        cout << "\\nFractional Knapsack (capacity: " << capacity << "):" << endl;\n        cout << "Items sorted by value/weight ratio:" << endl;\n        \n        for (auto& [ratio, item] : ratios) {\n            cout << "Weight: " << item.first << ", Value: " << item.second \n                 << ", Ratio: " << ratio << endl;\n        }\n        \n        cout << "\\nSelection process:" << endl;\n        \n        for (auto& [ratio, item] : ratios) {\n            if (remaining == 0) break;\n            \n            int weight = item.first;\n            int value = item.second;\n            \n            if (weight <= remaining) {\n                // Take whole item\n                totalValue += value;\n                remaining -= weight;\n                cout << "Take whole item: weight=" << weight \n                     << ", value=" << value << endl;\n            } else {\n                // Take fraction\n                double fraction = (double)remaining / weight;\n                totalValue += value * fraction;\n                cout << "Take fraction " << fraction << " of item: weight=" << weight \n                     << ", value=" << value << ", added value=" << value * fraction << endl;\n                remaining = 0;\n            }\n        }\n        \n        return totalValue;\n    }\n    \n    // 3. Huffman Coding (Already covered)\n    \n    // 4. Dijkstra\'s Algorithm (Greedy approach for shortest path)\n    vector<int> dijkstra(vector<vector<pair<int, int>>>& graph, int source) {\n        int n = graph.size();\n        vector<int> dist(n, INT_MAX);\n        vector<bool> visited(n, false);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, \n                       greater<pair<int, int>>> pq;\n        \n        dist[source] = 0;\n        pq.push({0, source});\n        \n        cout << "\\nDijkstra\'s Algorithm from source " << source << ":" << endl;\n        \n        while (!pq.empty()) {\n            int u = pq.top().second;\n            int currentDist = pq.top().first;\n            pq.pop();\n            \n            if (visited[u]) continue;\n            visited[u] = true;\n            \n            cout << "Processing vertex " << u << " with distance " << currentDist << endl;\n            \n            for (auto& [v, weight] : graph[u]) {\n                int newDist = currentDist + weight;\n                if (newDist < dist[v]) {\n                    dist[v] = newDist;\n                    pq.push({newDist, v});\n                    cout << "  Update vertex " << v << " to distance " << newDist << endl;\n                }\n            }\n        }\n        \n        return dist;\n    }\n    \n    // 5. Prim\'s Algorithm (Greedy approach for MST)\n    vector<vector<pair<int, int>>> primMST(vector<vector<pair<int, int>>>& graph) {\n        int n = graph.size();\n        vector<bool> inMST(n, false);\n        vector<int> key(n, INT_MAX);\n        vector<int> parent(n, -1);\n        priority_queue<pair<int, int>, vector<pair<int, int>>,\n                       greater<pair<int, int>>> pq;\n        \n        key[0] = 0;\n        pq.push({0, 0});\n        \n        cout << "\\nPrim\'s Algorithm for MST:" << endl;\n        \n        while (!pq.empty()) {\n            int u = pq.top().second;\n            pq.pop();\n            \n            if (inMST[u]) continue;\n            inMST[u] = true;\n            \n            cout << "Add vertex " << u << " to MST" << endl;\n            \n            for (auto& [v, weight] : graph[u]) {\n                if (!inMST[v] && weight < key[v]) {\n                    key[v] = weight;\n                    parent[v] = u;\n                    pq.push({key[v], v});\n                    cout << "  Update vertex " << v << " with edge weight " << weight \n                         << " from " << u << endl;\n                }\n            }\n        }\n        \n        // Build MST\n        vector<vector<pair<int, int>>> mst(n);\n        for (int i = 1; i < n; i++) {\n            if (parent[i] != -1) {\n                mst[parent[i]].push_back({i, key[i]});\n                mst[i].push_back({parent[i], key[i]});\n            }\n        }\n        \n        return mst;\n    }\n    \n    // 6. Kruskal\'s Algorithm (Greedy for MST using Union-Find)\n    struct Edge {\n        int u, v, weight;\n        bool operator<(const Edge& other) const {\n            return weight < other.weight;\n        }\n    };\n    \n    vector<Edge> kruskalMST(vector<Edge>& edges, int n) {\n        // Sort edges by weight\n        sort(edges.begin(), edges.end());\n        \n        // Union-Find structure\n        vector<int> parent(n);\n        vector<int> rank(n, 0);\n        for (int i = 0; i < n; i++) parent[i] = i;\n        \n        vector<Edge> mst;\n        \n        cout << "\\nKruskal\'s Algorithm (edges sorted by weight):" << endl;\n        for (auto& edge : edges) {\n            cout << "Edge " << edge.u << "-" << edge.v << ": " << edge.weight << endl;\n        }\n        \n        cout << "\\nSelection process:" << endl;\n        \n        for (auto& edge : edges) {\n            int rootU = find(parent, edge.u);\n            int rootV = find(parent, edge.v);\n            \n            if (rootU != rootV) {\n                mst.push_back(edge);\n                unionSets(parent, rank, rootU, rootV);\n                cout << "Select edge " << edge.u << "-" << edge.v \n                     << " (weight: " << edge.weight << ")" << endl;\n            } else {\n                cout << "Skip edge " << edge.u << "-" << edge.v \n                     << " (would create cycle)" << endl;\n            }\n            \n            if (mst.size() == n - 1) break;\n        }\n        \n        return mst;\n    }\n    \n    int find(vector<int>& parent, int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent, parent[x]);\n        }\n        return parent[x];\n    }\n    \n    void unionSets(vector<int>& parent, vector<int>& rank, int x, int y) {\n        int rootX = find(parent, x);\n        int rootY = find(parent, y);\n        \n        if (rootX != rootY) {\n            if (rank[rootX] < rank[rootY]) {\n                parent[rootX] = rootY;\n            } else if (rank[rootX] > rank[rootY]) {\n                parent[rootY] = rootX;\n            } else {\n                parent[rootY] = rootX;\n                rank[rootX]++;\n            }\n        }\n    }\n    \n    // 7. Coin Change (Greedy when coins have certain properties)\n    vector<int> coinChangeGreedy(vector<int>& coins, int amount) {\n        sort(coins.rbegin(), coins.rend()); // Descending\n        \n        vector<int> result;\n        int remaining = amount;\n        \n        cout << "\\nGreedy Coin Change for amount " << amount << ":" << endl;\n        cout << "Coins available: ";\n        for (int coin : coins) cout << coin << " ";\n        cout << endl;\n        \n        for (int coin : coins) {\n            while (remaining >= coin) {\n                remaining -= coin;\n                result.push_back(coin);\n                cout << "Take coin: " << coin << ", remaining: " << remaining << endl;\n            }\n        }\n        \n        if (remaining != 0) {\n            cout << "Greedy algorithm failed! Remaining: " << remaining << endl;\n            return {};\n        }\n        \n        return result;\n    }\n    \n    // 8. Job Sequencing with Deadlines\n    struct Job {\n        char id;\n        int deadline;\n        int profit;\n    };\n    \n    vector<char> jobSequencing(vector<Job>& jobs) {\n        // Sort by profit descending\n        sort(jobs.begin(), jobs.end(), [](const Job& a, const Job& b) {\n            return a.profit > b.profit;\n        });\n        \n        int maxDeadline = 0;\n        for (auto& job : jobs) {\n            maxDeadline = max(maxDeadline, job.deadline);\n        }\n        \n        vector<char> result(maxDeadline, \'\\0\');\n        vector<bool> slot(maxDeadline, false);\n        \n        cout << "\\nJob Sequencing Problem:" << endl;\n        cout << "Jobs sorted by profit:" << endl;\n        for (auto& job : jobs) {\n            cout << job.id << ": deadline=" << job.deadline \n                 << ", profit=" << job.profit << endl;\n        }\n        \n        cout << "\\nAssignment process:" << endl;\n        \n        for (auto& job : jobs) {\n            // Find a free slot for this job\n            for (int j = min(job.deadline, maxDeadline) - 1; j >= 0; j--) {\n                if (!slot[j]) {\n                    result[j] = job.id;\n                    slot[j] = true;\n                    cout << "Assign job " << job.id << " to slot " << j+1 << endl;\n                    break;\n                }\n            }\n        }\n        \n        // Remove empty slots\n        vector<char> finalResult;\n        for (char jobId : result) {\n            if (jobId != \'\\0\') {\n                finalResult.push_back(jobId);\n            }\n        }\n        \n        return finalResult;\n    }\n};\n\nint main() {\n    GreedyAlgorithms greedy;\n    \n    cout << "=== Greedy Algorithms ===\\n" << endl;\n    \n    // Activity Selection\n    vector<pair<int, int>> activities = {\n        {1, 3}, {2, 5}, {4, 6}, {6, 7}, {5, 8}, {7, 9}\n    };\n    \n    auto selected = greedy.activitySelection(activities);\n    cout << "\\nTotal activities selected: " << selected.size() << "\\n" << endl;\n    \n    // Fractional Knapsack\n    vector<pair<int, int>> items = {\n        {10, 60}, {20, 100}, {30, 120}\n    };\n    double maxValue = greedy.fractionalKnapsack(items, 50);\n    cout << "\\nMaximum value: " << maxValue << "\\n" << endl;\n    \n    // Dijkstra\'s Algorithm\n    int n = 5;\n    vector<vector<pair<int, int>>> graph(n);\n    graph[0] = {{1, 10}, {4, 5}};\n    graph[1] = {{2, 1}, {4, 2}};\n    graph[2] = {{3, 4}};\n    graph[3] = {{2, 6}, {0, 7}};\n    graph[4] = {{1, 3}, {2, 9}, {3, 2}};\n    \n    auto distances = greedy.dijkstra(graph, 0);\n    cout << "\\nShortest distances from source 0:" << endl;\n    for (int i = 0; i < n; i++) {\n        cout << "Vertex " << i << ": " << distances[i] << endl;\n    }\n    cout << endl;\n    \n    // Prim\'s MST\n    auto mst = greedy.primMST(graph);\n    cout << "\\nMST edges:" << endl;\n    for (int u = 0; u < mst.size(); u++) {\n        for (auto& [v, w] : mst[u]) {\n            if (u < v) { // Avoid duplicates\n                cout << u << "-" << v << ": " << w << endl;\n            }\n        }\n    }\n    cout << endl;\n    \n    // Kruskal\'s MST\n    vector<GreedyAlgorithms::Edge> edges = {\n        {0, 1, 10}, {0, 4, 5}, {1, 2, 1}, {1, 4, 2},\n        {2, 3, 4}, {3, 2, 6}, {3, 0, 7}, {4, 1, 3},\n        {4, 2, 9}, {4, 3, 2}\n    };\n    \n    auto kruskalResult = greedy.kruskalMST(edges, n);\n    cout << "\\nKruskal\'s MST edges:" << endl;\n    int totalWeight = 0;\n    for (auto& edge : kruskalResult) {\n        cout << edge.u << "-" << edge.v << ": " << edge.weight << endl;\n        totalWeight += edge.weight;\n    }\n    cout << "Total weight: " << totalWeight << "\\n" << endl;\n    \n    // Coin Change (Greedy works for canonical coin systems)\n    vector<int> coins = {25, 10, 5, 1};\n    auto coinResult = greedy.coinChangeGreedy(coins, 63);\n    cout << "\\nCoins used: ";\n    for (int coin : coinResult) cout << coin << " ";\n    cout << "\\nTotal coins: " << coinResult.size() << "\\n" << endl;\n    \n    // Job Sequencing\n    vector<GreedyAlgorithms::Job> jobs = {\n        {\'a\', 2, 100}, {\'b\', 1, 19}, {\'c\', 2, 27},\n        {\'d\', 1, 25}, {\'e\', 3, 15}\n    };\n    \n    auto jobResult = greedy.jobSequencing(jobs);\n    cout << "\\nJob sequence: ";\n    for (char jobId : jobResult) cout << jobId << " ";\n    cout << endl;\n    \n    return 0;\n}\n'})}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"When Greedy Algorithms Work:"})}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Greedy Choice Property"}),": Local optimal choice leads to global optimum"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Optimal Substructure"}),": Optimal solution contains optimal solutions to subproblems"]}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Common Greedy Algorithms:"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Dijkstra's Algorithm (Shortest Path)"}),"\n",(0,i.jsx)(e.li,{children:"Prim's and Kruskal's Algorithms (MST)"}),"\n",(0,i.jsx)(e.li,{children:"Huffman Coding (Data Compression)"}),"\n",(0,i.jsx)(e.li,{children:"Activity Selection"}),"\n",(0,i.jsx)(e.li,{children:"Fractional Knapsack"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Limitations:"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Don't always produce optimal solutions"}),"\n",(0,i.jsx)(e.li,{children:"Need proof of correctness"}),"\n",(0,i.jsx)(e.li,{children:"Not suitable for problems without greedy choice property"}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Euclidean Algorithm"}),": Efficient GCD computation with O(log min(a,b)) time"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Huffman Coding"}),": Optimal prefix codes for data compression"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"TSP"}),": NP-hard, requires heuristics or exact methods for small n"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"0/1 Knapsack"}),": Classic DP problem with O(nW) solution"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Memoization"}),": Top-down DP with caching"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Tabulation"}),": Bottom-up DP building table iteratively"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Dynamic Programming"}),": General technique for optimization problems"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Greedy Algorithms"}),": Make locally optimal choices, work for specific problems"]}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"Each technique has its strengths and weaknesses, and choosing the right approach depends on the problem characteristics, constraints, and requirements."})]})}function u(n={}){const{wrapper:e}={...(0,o.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(d,{...n})}):d(n)}},8453(n,e,t){t.d(e,{R:()=>a,x:()=>s});var i=t(6540);const o={},r=i.createContext(o);function a(n){const e=i.useContext(r);return i.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function s(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:a(n.components),i.createElement(r.Provider,{value:e},n.children)}}}]);