"use strict";(globalThis.webpackChunkmy_dsa_notes=globalThis.webpackChunkmy_dsa_notes||[]).push([[864],{1223(n,e,t){t.r(e),t.d(e,{assets:()=>c,contentTitle:()=>r,default:()=>u,frontMatter:()=>i,metadata:()=>o,toc:()=>l});var s=t(4848),a=t(8453);const i={},r="DSA Hash Tables",o={id:"hash-tables",title:"DSA Hash Tables",description:"Introduction to Hash Tables",source:"@site/docs/hash-tables.md",sourceDirName:".",slug:"/hash-tables",permalink:"/markdown-web-app/hash-tables",draft:!1,unlisted:!1,editUrl:"https://github.com/Kalyxon/markdown-web-app/tree/main/docs/hash-tables.md",tags:[],version:"current",frontMatter:{},sidebar:"dsa",previous:{title:"DSA Stacks & Queues",permalink:"/markdown-web-app/stacks-queues"},next:{title:"DSA Trees",permalink:"/markdown-web-app/trees"}},c={},l=[{value:"Introduction to Hash Tables",id:"introduction-to-hash-tables",level:2},{value:"Key Characteristics:",id:"key-characteristics",level:3},{value:"Basic Concepts and Terminology",id:"basic-concepts-and-terminology",level:2},{value:"Visual Overview:",id:"visual-overview",level:3},{value:"Key Components:",id:"key-components",level:3},{value:"DSA Hash Tables",id:"dsa-hash-tables-1",level:2},{value:"1. Hash Table Implementation with Chaining",id:"1-hash-table-implementation-with-chaining",level:3},{value:"2. Hash Table with Open Addressing (Linear Probing)",id:"2-hash-table-with-open-addressing-linear-probing",level:3},{value:"DSA Hash Sets",id:"dsa-hash-sets",level:2},{value:"1. HashSet Implementation",id:"1-hashset-implementation",level:3},{value:"2. Practical Applications of HashSet",id:"2-practical-applications-of-hashset",level:3},{value:"DSA Hash Maps",id:"dsa-hash-maps",level:2},{value:"1. HashMap Implementation",id:"1-hashmap-implementation",level:3},{value:"2. Practical Applications of HashMap",id:"2-practical-applications-of-hashmap",level:3},{value:"Advanced Hash Table Concepts",id:"advanced-hash-table-concepts",level:2},{value:"1. Custom Hash Functions",id:"1-custom-hash-functions",level:3},{value:"2. Performance Analysis and Comparison",id:"2-performance-analysis-and-comparison",level:3},{value:"Common Interview Questions",id:"common-interview-questions",level:2},{value:"1. Implement a HashMap from scratch",id:"1-implement-a-hashmap-from-scratch",level:3},{value:"2. Two Sum Problem (Optimized)",id:"2-two-sum-problem-optimized",level:3},{value:"3. LRU Cache Implementation",id:"3-lru-cache-implementation",level:3},{value:"Summary and Best Practices",id:"summary-and-best-practices",level:2},{value:"Hash Tables Summary:",id:"hash-tables-summary",level:3},{value:"Hash Sets vs Hash Maps:",id:"hash-sets-vs-hash-maps",level:3},{value:"Time Complexity Comparison:",id:"time-complexity-comparison",level:3},{value:"When to Use Hash Tables:",id:"when-to-use-hash-tables",level:3},{value:"Best Practices:",id:"best-practices",level:3},{value:"Common Pitfalls:",id:"common-pitfalls",level:3},{value:"Real-World Applications:",id:"real-world-applications",level:3},{value:"STL Containers:",id:"stl-containers",level:3},{value:"Performance Tips:",id:"performance-tips",level:3},{value:"Interview Preparation:",id:"interview-preparation",level:3}];function d(n){const e={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.header,{children:(0,s.jsx)(e.h1,{id:"dsa-hash-tables",children:"DSA Hash Tables"})}),"\n",(0,s.jsx)(e.h2,{id:"introduction-to-hash-tables",children:"Introduction to Hash Tables"}),"\n",(0,s.jsxs)(e.p,{children:["A ",(0,s.jsx)(e.strong,{children:"Hash Table"})," is a data structure that implements an ",(0,s.jsx)(e.strong,{children:"associative array"})," or ",(0,s.jsx)(e.strong,{children:"dictionary"}),", mapping keys to values. It uses a ",(0,s.jsx)(e.strong,{children:"hash function"})," to compute an index into an array of buckets/slots from which the desired value can be found."]}),"\n",(0,s.jsx)(e.h3,{id:"key-characteristics",children:"Key Characteristics:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Average Time Complexity"}),": O(1) for insert, delete, search"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Worst Case Time Complexity"}),": O(n) due to collisions"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Space Complexity"}),": O(n)"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Load Factor"}),": Ratio of entries to buckets (typically 0.7-0.8)"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Collision Resolution"}),": Chaining or Open Addressing"]}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"basic-concepts-and-terminology",children:"Basic Concepts and Terminology"}),"\n",(0,s.jsx)(e.h3,{id:"visual-overview",children:"Visual Overview:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:"Hash Table Structure:\nKeys \u2192 Hash Function \u2192 Index \u2192 Bucket Array\n[Key1] \u2192 h(Key1) \u2192 3 \u2192 [Bucket3: (Key1, Value1) \u2192 (Key4, Value4) \u2192 ...]\n[Key2] \u2192 h(Key2) \u2192 7 \u2192 [Bucket7: (Key2, Value2)]\n[Key3] \u2192 h(Key3) \u2192 3 \u2192 [Bucket3: (Key1, Value1) \u2192 (Key4, Value4) \u2192 (Key3, Value3)]\n"})}),"\n",(0,s.jsx)(e.h3,{id:"key-components",children:"Key Components:"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Key"}),": Input to hash function"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Value"}),": Data associated with key"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Hash Function"}),": Maps key to index"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Bucket/Slot"}),": Array position storing key-value pairs"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Collision"}),": When two keys map to same index"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Load Factor"}),": n/m (entries/buckets)"]}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"dsa-hash-tables-1",children:"DSA Hash Tables"}),"\n",(0,s.jsx)(e.h3,{id:"1-hash-table-implementation-with-chaining",children:"1. Hash Table Implementation with Chaining"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <vector>\n#include <list>\n#include <string>\n#include <functional>\n#include <cmath>\n#include <iomanip>\nusing namespace std;\n\n// Simple key-value pair structure\ntemplate<typename K, typename V>\nstruct KeyValuePair {\n    K key;\n    V value;\n    \n    KeyValuePair(const K& k, const V& v) : key(k), value(v) {}\n};\n\n// Hash Table with Separate Chaining\ntemplate<typename K, typename V>\nclass HashTable {\nprivate:\n    vector<list<KeyValuePair<K, V>>> table;\n    int capacity;\n    int size;\n    double loadFactorThreshold;\n    \n    // Hash function (using std::hash)\n    size_t hashFunction(const K& key) const {\n        hash<K> hasher;\n        return hasher(key) % capacity;\n    }\n    \n    // Rehash when load factor exceeds threshold\n    void rehash() {\n        cout << "\\n\u26a0\ufe0f  Load factor exceeded threshold (" << loadFactor() << " > " \n             << loadFactorThreshold << "). Rehashing..." << endl;\n        \n        int oldCapacity = capacity;\n        capacity = nextPrime(capacity * 2);\n        \n        vector<list<KeyValuePair<K, V>>> oldTable = move(table);\n        table = vector<list<KeyValuePair<K, V>>>(capacity);\n        size = 0;\n        \n        // Reinsert all elements\n        for(const auto& bucket : oldTable) {\n            for(const auto& kv : bucket) {\n                insert(kv.key, kv.value);\n            }\n        }\n        \n        cout << "\u2705 Rehashed: New capacity = " << capacity << endl;\n    }\n    \n    // Find next prime number (for capacity)\n    bool isPrime(int n) const {\n        if(n <= 1) return false;\n        if(n <= 3) return true;\n        if(n % 2 == 0 || n % 3 == 0) return false;\n        \n        for(int i = 5; i * i <= n; i += 6) {\n            if(n % i == 0 || n % (i + 2) == 0) return false;\n        }\n        return true;\n    }\n    \n    int nextPrime(int n) const {\n        while(!isPrime(n)) {\n            n++;\n        }\n        return n;\n    }\n    \npublic:\n    // Constructor\n    HashTable(int initialCapacity = 10, double threshold = 0.7) \n        : capacity(nextPrime(initialCapacity)), size(0), loadFactorThreshold(threshold) {\n        table.resize(capacity);\n        cout << "Hash Table created with capacity: " << capacity \n             << ", Load factor threshold: " << loadFactorThreshold << endl;\n    }\n    \n    // Insert key-value pair\n    void insert(const K& key, const V& value) {\n        if(loadFactor() >= loadFactorThreshold) {\n            rehash();\n        }\n        \n        size_t index = hashFunction(key);\n        \n        // Check if key already exists\n        for(auto& kv : table[index]) {\n            if(kv.key == key) {\n                kv.value = value;  // Update existing key\n                cout << "Updated key \'" << key << "\' with value: " << value << endl;\n                return;\n            }\n        }\n        \n        // Insert new key-value pair\n        table[index].emplace_back(key, value);\n        size++;\n        \n        cout << "Inserted key \'" << key << "\' with value: " << value \n             << " at index: " << index << endl;\n    }\n    \n    // Search for a key\n    V* search(const K& key) {\n        size_t index = hashFunction(key);\n        \n        for(auto& kv : table[index]) {\n            if(kv.key == key) {\n                cout << "Found key \'" << key << "\' at index: " << index \n                     << ", value: " << kv.value << endl;\n                return &kv.value;\n            }\n        }\n        \n        cout << "Key \'" << key << "\' not found" << endl;\n        return nullptr;\n    }\n    \n    // Delete a key\n    bool remove(const K& key) {\n        size_t index = hashFunction(key);\n        \n        auto& bucket = table[index];\n        for(auto it = bucket.begin(); it != bucket.end(); ++it) {\n            if(it->key == key) {\n                cout << "Removed key \'" << key << "\' from index: " << index << endl;\n                bucket.erase(it);\n                size--;\n                return true;\n            }\n        }\n        \n        cout << "Key \'" << key << "\' not found for removal" << endl;\n        return false;\n    }\n    \n    // Get current size\n    int getSize() const {\n        return size;\n    }\n    \n    // Get capacity\n    int getCapacity() const {\n        return capacity;\n    }\n    \n    // Calculate load factor\n    double loadFactor() const {\n        return static_cast<double>(size) / capacity;\n    }\n    \n    // Display hash table\n    void display() const {\n        cout << "\\n=== Hash Table Details ===" << endl;\n        cout << "Capacity: " << capacity << endl;\n        cout << "Size: " << size << endl;\n        cout << "Load Factor: " << fixed << setprecision(2) << loadFactor() \n             << " (Threshold: " << loadFactorThreshold << ")" << endl;\n        cout << "\\nBucket Distribution:" << endl;\n        \n        int emptyBuckets = 0;\n        int maxChainLength = 0;\n        \n        for(int i = 0; i < capacity; i++) {\n            int chainLength = table[i].size();\n            \n            if(chainLength == 0) {\n                emptyBuckets++;\n            }\n            \n            if(chainLength > maxChainLength) {\n                maxChainLength = chainLength;\n            }\n            \n            cout << "  Bucket[" << i << "]: ";\n            if(chainLength == 0) {\n                cout << "Empty";\n            } else {\n                for(const auto& kv : table[i]) {\n                    cout << "(" << kv.key << ":" << kv.value << ")";\n                    if(&kv != &table[i].back()) {\n                        cout << " \u2192 ";\n                    }\n                }\n                cout << " [Length: " << chainLength << "]";\n            }\n            cout << endl;\n        }\n        \n        cout << "\\nStatistics:" << endl;\n        cout << "  Empty Buckets: " << emptyBuckets << " (" \n             << (emptyBuckets * 100.0 / capacity) << "%)" << endl;\n        cout << "  Max Chain Length: " << maxChainLength << endl;\n        cout << "  Average Chain Length: " << fixed << setprecision(2) \n             << (size == 0 ? 0 : static_cast<double>(size) / (capacity - emptyBuckets)) << endl;\n    }\n    \n    // Visual representation\n    void displayVisual() const {\n        cout << "\\n=== Hash Table Visualization ===" << endl;\n        \n        for(int i = 0; i < capacity; i++) {\n            cout << "[" << setw(2) << i << "] ";\n            \n            if(table[i].empty()) {\n                cout << "\u2514\u2500 Empty" << endl;\n            } else {\n                cout << "\u251c\u2500 ";\n                bool first = true;\n                for(const auto& kv : table[i]) {\n                    if(!first) cout << "   \u251c\u2500 ";\n                    cout << "(" << kv.key << ":" << kv.value << ")" << endl;\n                    first = false;\n                }\n            }\n        }\n        \n        cout << "===============================" << endl;\n    }\n};\n\n// Demonstration\nvoid demonstrateHashTable() {\n    cout << "=== Hash Table Implementation with Chaining ===" << endl;\n    \n    HashTable<string, int> phoneBook(7, 0.6);  // Small capacity for demonstration\n    \n    // Insert some contacts\n    phoneBook.insert("Alice", 1234567890);\n    phoneBook.insert("Bob", 9876543210);\n    phoneBook.insert("Charlie", 5551234567);\n    phoneBook.insert("David", 4449876543);\n    \n    phoneBook.displayVisual();\n    \n    // Search operations\n    cout << "\\n--- Search Operations ---" << endl;\n    phoneBook.search("Alice");\n    phoneBook.search("Eve");  // Not found\n    \n    // Update existing key\n    cout << "\\n--- Update Operation ---" << endl;\n    phoneBook.insert("Alice", 1112223333);\n    \n    // Insert more to trigger rehash\n    cout << "\\n--- Trigger Rehash ---" << endl;\n    phoneBook.insert("Eve", 9998887777);\n    phoneBook.insert("Frank", 6665554444);\n    phoneBook.insert("Grace", 3332221111);\n    \n    phoneBook.display();\n    \n    // Remove operation\n    cout << "\\n--- Remove Operation ---" << endl;\n    phoneBook.remove("Bob");\n    \n    phoneBook.displayVisual();\n    \n    // Display final statistics\n    cout << "\\nFinal Statistics:" << endl;\n    cout << "Total entries: " << phoneBook.getSize() << endl;\n    cout << "Table capacity: " << phoneBook.getCapacity() << endl;\n}\n\nint main() {\n    demonstrateHashTable();\n    return 0;\n}\n'})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Output:"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:"=== Hash Table Implementation with Chaining ===\nHash Table created with capacity: 7, Load factor threshold: 0.6\nInserted key 'Alice' with value: 1234567890 at index: 1\nInserted key 'Bob' with value: 9876543210 at index: 5\nInserted key 'Charlie' with value: 5551234567 at index: 3\nInserted key 'David' with value: 4449876543 at index: 5\n\n=== Hash Table Visualization ===\n[ 0] \u2514\u2500 Empty\n[ 1] \u251c\u2500 (Alice:1234567890)\n[ 2] \u2514\u2500 Empty\n[ 3] \u251c\u2500 (Charlie:5551234567)\n[ 4] \u2514\u2500 Empty\n[ 5] \u251c\u2500 (Bob:9876543210)\n       \u251c\u2500 (David:4449876543)\n[ 6] \u2514\u2500 Empty\n===============================\n\n--- Search Operations ---\nFound key 'Alice' at index: 1, value: 1234567890\nKey 'Eve' not found\n\n--- Update Operation ---\nUpdated key 'Alice' with value: 1112223333\n\n--- Trigger Rehash ---\nInserted key 'Eve' with value: 9998887777 at index: 5\nInserted key 'Frank' with value: 6665554444 at index: 3\n\n\u26a0\ufe0f  Load factor exceeded threshold (0.86 > 0.6). Rehashing...\nInserted key 'Alice' with value: 1112223333 at index: 5\nInserted key 'Bob' with value: 9876543210 at index: 3\nInserted key 'Charlie' with value: 5551234567 at index: 9\nInserted key 'David' with value: 4449876543 at index: 0\nInserted key 'Eve' with value: 9998887777 at index: 11\nInserted key 'Frank' with value: 6665554444 at index: 7\n\u2705 Rehashed: New capacity = 17\nInserted key 'Grace' with value: 3332221111 at index: 13\n\n=== Hash Table Details ===\nCapacity: 17\nSize: 7\nLoad Factor: 0.41 (Threshold: 0.6)\n\nBucket Distribution:\n  Bucket[0]: (David:4449876543) [Length: 1]\n  Bucket[1]: Empty\n  ... (more buckets) ...\n  Bucket[17]: Empty\n\nStatistics:\n  Empty Buckets: 11 (64.71%)\n  Max Chain Length: 1\n  Average Chain Length: 1.17\n"})}),"\n",(0,s.jsx)(e.h3,{id:"2-hash-table-with-open-addressing-linear-probing",children:"2. Hash Table with Open Addressing (Linear Probing)"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <vector>\n#include <string>\n#include <functional>\n#include <iomanip>\nusing namespace std;\n\n// Entry status for open addressing\nenum EntryStatus {\n    EMPTY,\n    OCCUPIED,\n    DELETED\n};\n\n// Entry structure for open addressing\ntemplate<typename K, typename V>\nstruct HashEntry {\n    K key;\n    V value;\n    EntryStatus status;\n    \n    HashEntry() : status(EMPTY) {}\n    HashEntry(const K& k, const V& v) : key(k), value(v), status(OCCUPIED) {}\n};\n\n// Hash Table with Open Addressing (Linear Probing)\ntemplate<typename K, typename V>\nclass OpenAddressingHashTable {\nprivate:\n    vector<HashEntry<K, V>> table;\n    int capacity;\n    int size;\n    double loadFactorThreshold;\n    \n    // Hash function\n    size_t hashFunction(const K& key, int attempt = 0) const {\n        hash<K> hasher;\n        return (hasher(key) + attempt) % capacity;\n    }\n    \n    // Find next prime for capacity\n    bool isPrime(int n) const {\n        if(n <= 1) return false;\n        if(n <= 3) return true;\n        if(n % 2 == 0 || n % 3 == 0) return false;\n        \n        for(int i = 5; i * i <= n; i += 6) {\n            if(n % i == 0 || n % (i + 2) == 0) return false;\n        }\n        return true;\n    }\n    \n    int nextPrime(int n) const {\n        while(!isPrime(n)) {\n            n++;\n        }\n        return n;\n    }\n    \n    // Probe sequence (linear probing)\n    size_t probe(const K& key, int attempt) const {\n        return hashFunction(key, attempt);\n    }\n    \n    // Rehash when load factor exceeds threshold\n    void rehash() {\n        cout << "\\n\u26a0\ufe0f  Load factor exceeded threshold (" << loadFactor() << " > " \n             << loadFactorThreshold << "). Rehashing..." << endl;\n        \n        int oldCapacity = capacity;\n        capacity = nextPrime(capacity * 2);\n        \n        vector<HashEntry<K, V>> oldTable = move(table);\n        table = vector<HashEntry<K, V>>(capacity);\n        size = 0;\n        \n        // Reinsert all occupied entries\n        for(const auto& entry : oldTable) {\n            if(entry.status == OCCUPIED) {\n                insert(entry.key, entry.value);\n            }\n        }\n        \n        cout << "\u2705 Rehashed: New capacity = " << capacity << endl;\n    }\n    \npublic:\n    // Constructor\n    OpenAddressingHashTable(int initialCapacity = 10, double threshold = 0.7) \n        : capacity(nextPrime(initialCapacity)), size(0), loadFactorThreshold(threshold) {\n        table.resize(capacity);\n        cout << "Open Addressing Hash Table created with capacity: " << capacity \n             << ", Load factor threshold: " << loadFactorThreshold << endl;\n    }\n    \n    // Insert key-value pair\n    bool insert(const K& key, const V& value) {\n        if(loadFactor() >= loadFactorThreshold) {\n            rehash();\n        }\n        \n        int attempt = 0;\n        size_t index;\n        \n        // Find empty or deleted slot\n        do {\n            index = probe(key, attempt);\n            \n            if(table[index].status == EMPTY || table[index].status == DELETED) {\n                // Found empty slot\n                table[index] = HashEntry<K, V>(key, value);\n                size++;\n                cout << "Inserted key \'" << key << "\' with value: " << value \n                     << " at index: " << index << " (attempts: " << attempt + 1 << ")" << endl;\n                return true;\n            }\n            \n            if(table[index].status == OCCUPIED && table[index].key == key) {\n                // Update existing key\n                table[index].value = value;\n                cout << "Updated key \'" << key << "\' with value: " << value \n                     << " at index: " << index << endl;\n                return true;\n            }\n            \n            attempt++;\n        } while(attempt < capacity);\n        \n        cout << "\u274c Failed to insert key \'" << key << "\': Table is full" << endl;\n        return false;\n    }\n    \n    // Search for a key\n    V* search(const K& key) {\n        int attempt = 0;\n        size_t index;\n        \n        do {\n            index = probe(key, attempt);\n            \n            if(table[index].status == EMPTY) {\n                // Key not found\n                break;\n            }\n            \n            if(table[index].status == OCCUPIED && table[index].key == key) {\n                cout << "Found key \'" << key << "\' at index: " << index \n                     << ", value: " << table[index].value \n                     << " (attempts: " << attempt + 1 << ")" << endl;\n                return &table[index].value;\n            }\n            \n            attempt++;\n        } while(attempt < capacity);\n        \n        cout << "Key \'" << key << "\' not found" << endl;\n        return nullptr;\n    }\n    \n    // Delete a key\n    bool remove(const K& key) {\n        int attempt = 0;\n        size_t index;\n        \n        do {\n            index = probe(key, attempt);\n            \n            if(table[index].status == EMPTY) {\n                break;\n            }\n            \n            if(table[index].status == OCCUPIED && table[index].key == key) {\n                table[index].status = DELETED;\n                size--;\n                cout << "Removed key \'" << key << "\' from index: " << index << endl;\n                return true;\n            }\n            \n            attempt++;\n        } while(attempt < capacity);\n        \n        cout << "Key \'" << key << "\' not found for removal" << endl;\n        return false;\n    }\n    \n    // Get current size\n    int getSize() const {\n        return size;\n    }\n    \n    // Get capacity\n    int getCapacity() const {\n        return capacity;\n    }\n    \n    // Calculate load factor\n    double loadFactor() const {\n        return static_cast<double>(size) / capacity;\n    }\n    \n    // Display hash table\n    void display() const {\n        cout << "\\n=== Open Addressing Hash Table ===" << endl;\n        cout << "Capacity: " << capacity << endl;\n        cout << "Size: " << size << endl;\n        cout << "Load Factor: " << fixed << setprecision(2) << loadFactor() << endl;\n        \n        cout << "\\nTable Contents:" << endl;\n        cout << left << setw(10) << "Index" \n             << setw(15) << "Status" \n             << setw(15) << "Key" \n             << setw(15) << "Value" << endl;\n        cout << string(55, \'-\') << endl;\n        \n        for(int i = 0; i < capacity; i++) {\n            cout << left << setw(10) << i;\n            \n            switch(table[i].status) {\n                case EMPTY:\n                    cout << setw(15) << "EMPTY" << endl;\n                    break;\n                case OCCUPIED:\n                    cout << setw(15) << "OCCUPIED" \n                         << setw(15) << table[i].key \n                         << setw(15) << table[i].value << endl;\n                    break;\n                case DELETED:\n                    cout << setw(15) << "DELETED" << endl;\n                    break;\n            }\n        }\n        \n        // Calculate cluster statistics\n        int maxClusterSize = 0;\n        int currentCluster = 0;\n        int totalClusters = 0;\n        \n        for(int i = 0; i < capacity; i++) {\n            if(table[i].status == OCCUPIED) {\n                currentCluster++;\n            } else {\n                if(currentCluster > 0) {\n                    totalClusters++;\n                    if(currentCluster > maxClusterSize) {\n                        maxClusterSize = currentCluster;\n                    }\n                    currentCluster = 0;\n                }\n            }\n        }\n        \n        // Handle cluster at the end\n        if(currentCluster > 0) {\n            totalClusters++;\n            if(currentCluster > maxClusterSize) {\n                maxClusterSize = currentCluster;\n            }\n        }\n        \n        cout << "\\nCluster Statistics:" << endl;\n        cout << "  Max Cluster Size: " << maxClusterSize << endl;\n        cout << "  Total Clusters: " << totalClusters << endl;\n        if(totalClusters > 0) {\n            cout << "  Average Cluster Size: " << fixed << setprecision(2) \n                 << static_cast<double>(size) / totalClusters << endl;\n        }\n    }\n    \n    // Visual representation\n    void displayVisual() const {\n        cout << "\\n=== Hash Table Visualization (Linear Probing) ===" << endl;\n        \n        for(int i = 0; i < capacity; i++) {\n            cout << "[" << setw(2) << i << "] ";\n            \n            switch(table[i].status) {\n                case EMPTY:\n                    cout << "\u25fb Empty" << endl;\n                    break;\n                case OCCUPIED:\n                    cout << "\u25a0 " << table[i].key << ":" << table[i].value << endl;\n                    break;\n                case DELETED:\n                    cout << "\u25fc Deleted (tombstone)" << endl;\n                    break;\n            }\n        }\n        \n        // Show probing sequence example\n        cout << "\\nProbing Sequence Example (for key \'Test\'):" << endl;\n        string testKey = "Test";\n        for(int attempt = 0; attempt < 5; attempt++) {\n            size_t index = probe(testKey, attempt);\n            cout << "  Attempt " << attempt << ": index = " << index \n                 << " (hash + " << attempt << ")" << endl;\n        }\n    }\n};\n\n// Demonstration\nvoid demonstrateOpenAddressingHashTable() {\n    cout << "\\n\\n=== Hash Table with Open Addressing (Linear Probing) ===" << endl;\n    \n    OpenAddressingHashTable<string, int> table(7, 0.6);  // Small capacity for demo\n    \n    // Insert operations\n    table.insert("Alice", 100);\n    table.insert("Bob", 200);\n    table.insert("Charlie", 300);\n    table.insert("David", 400);\n    \n    table.displayVisual();\n    \n    // Search operations\n    cout << "\\n--- Search Operations ---" << endl;\n    table.search("Alice");\n    table.search("Eve");\n    \n    // Update existing\n    cout << "\\n--- Update Operation ---" << endl;\n    table.insert("Alice", 150);\n    \n    // Insert more (will cause clustering)\n    cout << "\\n--- Insert More (Show Clustering) ---" << endl;\n    table.insert("Eve", 500);\n    table.insert("Frank", 600);\n    \n    table.display();\n    \n    // Remove operation\n    cout << "\\n--- Remove Operation ---" << endl;\n    table.remove("Bob");\n    \n    table.displayVisual();\n    \n    // Search after removal (should skip tombstone)\n    cout << "\\n--- Search After Removal ---" << endl;\n    table.search("Charlie");\n    \n    // Insert new key in deleted slot\n    cout << "\\n--- Insert in Deleted Slot ---" << endl;\n    table.insert("Grace", 700);\n    \n    table.displayVisual();\n}\n\nint main() {\n    demonstrateOpenAddressingHashTable();\n    return 0;\n}\n'})}),"\n",(0,s.jsx)(e.h2,{id:"dsa-hash-sets",children:"DSA Hash Sets"}),"\n",(0,s.jsx)(e.h3,{id:"1-hashset-implementation",children:"1. HashSet Implementation"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <vector>\n#include <list>\n#include <functional>\n#include <algorithm>\n#include <iomanip>\nusing namespace std;\n\n// HashSet Implementation with Separate Chaining\ntemplate<typename T>\nclass HashSet {\nprivate:\n    vector<list<T>> table;\n    int capacity;\n    int size;\n    double loadFactorThreshold;\n    \n    // Hash function\n    size_t hashFunction(const T& value) const {\n        hash<T> hasher;\n        return hasher(value) % capacity;\n    }\n    \n    // Rehash when load factor exceeds threshold\n    void rehash() {\n        cout << "\\n\u26a0\ufe0f  Load factor exceeded threshold (" << loadFactor() << " > " \n             << loadFactorThreshold << "). Rehashing..." << endl;\n        \n        int oldCapacity = capacity;\n        capacity = nextPrime(capacity * 2);\n        \n        vector<list<T>> oldTable = move(table);\n        table = vector<list<T>>(capacity);\n        size = 0;\n        \n        // Reinsert all elements\n        for(const auto& bucket : oldTable) {\n            for(const auto& value : bucket) {\n                insert(value);\n            }\n        }\n        \n        cout << "\u2705 Rehashed: New capacity = " << capacity << endl;\n    }\n    \n    // Prime number utilities\n    bool isPrime(int n) const {\n        if(n <= 1) return false;\n        if(n <= 3) return true;\n        if(n % 2 == 0 || n % 3 == 0) return false;\n        \n        for(int i = 5; i * i <= n; i += 6) {\n            if(n % i == 0 || n % (i + 2) == 0) return false;\n        }\n        return true;\n    }\n    \n    int nextPrime(int n) const {\n        while(!isPrime(n)) {\n            n++;\n        }\n        return n;\n    }\n    \npublic:\n    // Constructor\n    HashSet(int initialCapacity = 10, double threshold = 0.7) \n        : capacity(nextPrime(initialCapacity)), size(0), loadFactorThreshold(threshold) {\n        table.resize(capacity);\n        cout << "HashSet created with capacity: " << capacity \n             << ", Load factor threshold: " << loadFactorThreshold << endl;\n    }\n    \n    // Insert a value\n    bool insert(const T& value) {\n        if(contains(value)) {\n            cout << "Value \'" << value << "\' already exists in set" << endl;\n            return false;\n        }\n        \n        if(loadFactor() >= loadFactorThreshold) {\n            rehash();\n        }\n        \n        size_t index = hashFunction(value);\n        table[index].push_back(value);\n        size++;\n        \n        cout << "Inserted value: \'" << value << "\' at index: " << index << endl;\n        return true;\n    }\n    \n    // Check if value exists\n    bool contains(const T& value) const {\n        size_t index = hashFunction(value);\n        \n        for(const auto& item : table[index]) {\n            if(item == value) {\n                return true;\n            }\n        }\n        return false;\n    }\n    \n    // Search for a value\n    bool search(const T& value) const {\n        bool found = contains(value);\n        cout << "Value \'" << value << "\' " << (found ? "found" : "not found") << " in set" << endl;\n        return found;\n    }\n    \n    // Remove a value\n    bool erase(const T& value) {\n        size_t index = hashFunction(value);\n        auto& bucket = table[index];\n        \n        auto it = find(bucket.begin(), bucket.end(), value);\n        if(it != bucket.end()) {\n            bucket.erase(it);\n            size--;\n            cout << "Removed value: \'" << value << "\' from index: " << index << endl;\n            return true;\n        }\n        \n        cout << "Value \'" << value << "\' not found for removal" << endl;\n        return false;\n    }\n    \n    // Get current size\n    int getSize() const {\n        return size;\n    }\n    \n    // Get capacity\n    int getCapacity() const {\n        return capacity;\n    }\n    \n    // Calculate load factor\n    double loadFactor() const {\n        return static_cast<double>(size) / capacity;\n    }\n    \n    // Check if set is empty\n    bool empty() const {\n        return size == 0;\n    }\n    \n    // Clear all elements\n    void clear() {\n        for(auto& bucket : table) {\n            bucket.clear();\n        }\n        size = 0;\n        cout << "HashSet cleared" << endl;\n    }\n    \n    // Display HashSet\n    void display() const {\n        cout << "\\n=== HashSet Details ===" << endl;\n        cout << "Capacity: " << capacity << endl;\n        cout << "Size: " << size << endl;\n        cout << "Load Factor: " << fixed << setprecision(2) << loadFactor() << endl;\n        cout << "Elements: { ";\n        \n        bool first = true;\n        for(const auto& bucket : table) {\n            for(const auto& value : bucket) {\n                if(!first) cout << ", ";\n                cout << value;\n                first = false;\n            }\n        }\n        cout << " }" << endl;\n        \n        cout << "\\nBucket Distribution:" << endl;\n        int emptyBuckets = 0;\n        int maxChainLength = 0;\n        \n        for(int i = 0; i < capacity; i++) {\n            int chainLength = table[i].size();\n            \n            if(chainLength == 0) {\n                emptyBuckets++;\n            }\n            \n            if(chainLength > maxChainLength) {\n                maxChainLength = chainLength;\n            }\n            \n            cout << "  Bucket[" << i << "]: ";\n            if(chainLength == 0) {\n                cout << "Empty";\n            } else {\n                for(const auto& value : table[i]) {\n                    cout << value;\n                    if(&value != &table[i].back()) {\n                        cout << " \u2192 ";\n                    }\n                }\n                cout << " [Length: " << chainLength << "]";\n            }\n            cout << endl;\n        }\n        \n        cout << "\\nStatistics:" << endl;\n        cout << "  Empty Buckets: " << emptyBuckets << " (" \n             << (emptyBuckets * 100.0 / capacity) << "%)" << endl;\n        cout << "  Max Chain Length: " << maxChainLength << endl;\n    }\n    \n    // Union of two sets\n    HashSet<T> unionWith(const HashSet<T>& other) const {\n        HashSet<T> result(max(capacity, other.capacity));\n        \n        // Add all elements from this set\n        for(const auto& bucket : table) {\n            for(const auto& value : bucket) {\n                result.insert(value);\n            }\n        }\n        \n        // Add all elements from other set\n        for(const auto& bucket : other.table) {\n            for(const auto& value : bucket) {\n                result.insert(value);\n            }\n        }\n        \n        return result;\n    }\n    \n    // Intersection of two sets\n    HashSet<T> intersectionWith(const HashSet<T>& other) const {\n        HashSet<T> result(min(capacity, other.capacity));\n        \n        // Only check elements from the smaller set\n        const HashSet<T>& smaller = (size < other.size) ? *this : other;\n        const HashSet<T>& larger = (size < other.size) ? other : *this;\n        \n        for(const auto& bucket : smaller.table) {\n            for(const auto& value : bucket) {\n                if(larger.contains(value)) {\n                    result.insert(value);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \n    // Difference of two sets (this - other)\n    HashSet<T> differenceWith(const HashSet<T>& other) const {\n        HashSet<T> result(capacity);\n        \n        for(const auto& bucket : table) {\n            for(const auto& value : bucket) {\n                if(!other.contains(value)) {\n                    result.insert(value);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \n    // Check if this set is subset of another\n    bool isSubsetOf(const HashSet<T>& other) const {\n        for(const auto& bucket : table) {\n            for(const auto& value : bucket) {\n                if(!other.contains(value)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n};\n\n// Demonstration\nvoid demonstrateHashSet() {\n    cout << "=== HashSet Implementation ===" << endl;\n    \n    HashSet<string> set1(7, 0.6);\n    \n    // Insert operations\n    set1.insert("Apple");\n    set1.insert("Banana");\n    set1.insert("Cherry");\n    set1.insert("Date");\n    \n    set1.display();\n    \n    // Search operations\n    cout << "\\n--- Search Operations ---" << endl;\n    set1.search("Apple");\n    set1.search("Elderberry");\n    \n    // Try to insert duplicate\n    cout << "\\n--- Insert Duplicate ---" << endl;\n    set1.insert("Apple");\n    \n    // Insert more to trigger rehash\n    cout << "\\n--- Trigger Rehash ---" << endl;\n    set1.insert("Elderberry");\n    set1.insert("Fig");\n    set1.insert("Grape");\n    \n    set1.display();\n    \n    // Remove operation\n    cout << "\\n--- Remove Operation ---" << endl;\n    set1.erase("Banana");\n    \n    // Create another set for set operations\n    cout << "\\n--- Create Second Set ---" << endl;\n    HashSet<string> set2(5);\n    set2.insert("Cherry");\n    set2.insert("Date");\n    set2.insert("Elderberry");\n    set2.insert("Honeydew");\n    \n    cout << "\\nSet 1: ";\n    set1.display();\n    cout << "\\nSet 2: ";\n    set2.display();\n    \n    // Set operations\n    cout << "\\n--- Set Operations ---" << endl;\n    \n    // Union\n    auto unionSet = set1.unionWith(set2);\n    cout << "Union: ";\n    unionSet.display();\n    \n    // Intersection\n    auto intersectionSet = set1.intersectionWith(set2);\n    cout << "\\nIntersection: ";\n    intersectionSet.display();\n    \n    // Difference\n    auto differenceSet = set1.differenceWith(set2);\n    cout << "\\nDifference (Set1 - Set2): ";\n    differenceSet.display();\n    \n    // Subset check\n    HashSet<string> subset(3);\n    subset.insert("Cherry");\n    subset.insert("Date");\n    \n    cout << "\\nSubset Check:" << endl;\n    cout << "{Cherry, Date} is subset of Set1: " \n         << (subset.isSubsetOf(set1) ? "Yes" : "No") << endl;\n    cout << "{Cherry, Date} is subset of Set2: " \n         << (subset.isSubsetOf(set2) ? "Yes" : "No") << endl;\n    \n    // Clear set\n    cout << "\\n--- Clear Set ---" << endl;\n    set1.clear();\n    cout << "Set 1 is empty: " << (set1.empty() ? "Yes" : "No") << endl;\n}\n\nint main() {\n    demonstrateHashSet();\n    return 0;\n}\n'})}),"\n",(0,s.jsx)(e.h3,{id:"2-practical-applications-of-hashset",children:"2. Practical Applications of HashSet"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <fstream>\n#include <sstream>\nusing namespace std;\n\nclass HashSetApplications {\npublic:\n    // 1. Find unique elements in an array\n    static void findUniqueElements() {\n        cout << "=== 1. Finding Unique Elements ===" << endl;\n        \n        vector<int> numbers = {1, 2, 3, 2, 4, 1, 5, 3, 6, 7, 5, 8, 9, 9};\n        \n        cout << "Original array: ";\n        for(int num : numbers) cout << num << " ";\n        cout << endl;\n        \n        // Using HashSet to find unique elements\n        vector<int> uniqueNumbers;\n        vector<bool> seen(100, false);  // Simplified HashSet\n        \n        for(int num : numbers) {\n            if(!seen[num]) {\n                seen[num] = true;\n                uniqueNumbers.push_back(num);\n            }\n        }\n        \n        cout << "Unique elements: ";\n        for(int num : uniqueNumbers) cout << num << " ";\n        cout << endl;\n        cout << "Total unique elements: " << uniqueNumbers.size() << endl;\n    }\n    \n    // 2. Find duplicate elements\n    static void findDuplicates() {\n        cout << "\\n=== 2. Finding Duplicate Elements ===" << endl;\n        \n        vector<string> words = {"apple", "banana", "apple", "cherry", \n                                "date", "banana", "elderberry", "apple"};\n        \n        cout << "Word list: ";\n        for(const auto& word : words) cout << word << " ";\n        cout << endl;\n        \n        // Find duplicates using HashSet\n        vector<string> uniqueWords;\n        vector<string> duplicates;\n        vector<bool> seen(1000, false);\n        \n        for(const auto& word : words) {\n            // Simple hash for demonstration\n            size_t hash = 0;\n            for(char c : word) hash = hash * 31 + c;\n            hash %= 1000;\n            \n            if(seen[hash]) {\n                if(find(duplicates.begin(), duplicates.end(), word) == duplicates.end()) {\n                    duplicates.push_back(word);\n                }\n            } else {\n                seen[hash] = true;\n                uniqueWords.push_back(word);\n            }\n        }\n        \n        cout << "Duplicate words: ";\n        for(const auto& word : duplicates) cout << word << " ";\n        cout << endl;\n        \n        cout << "Word frequencies:" << endl;\n        vector<int> frequency(1000, 0);\n        for(const auto& word : words) {\n            size_t hash = 0;\n            for(char c : word) hash = hash * 31 + c;\n            hash %= 1000;\n            frequency[hash]++;\n        }\n        \n        for(const auto& word : uniqueWords) {\n            size_t hash = 0;\n            for(char c : word) hash = hash * 31 + c;\n            hash %= 1000;\n            cout << "  " << word << ": " << frequency[hash] << " times" << endl;\n        }\n    }\n    \n    // 3. Check if array has all unique characters\n    static void checkUniqueCharacters() {\n        cout << "\\n=== 3. Checking for Unique Characters ===" << endl;\n        \n        string testString1 = "abcdefg";\n        string testString2 = "hello world";\n        \n        auto hasAllUnique = [](const string& str) -> bool {\n            vector<bool> charSet(256, false);\n            \n            for(char c : str) {\n                if(c == \' \') continue;  // Skip spaces\n                \n                if(charSet[c]) {\n                    return false;  // Duplicate found\n                }\n                charSet[c] = true;\n            }\n            return true;\n        };\n        \n        cout << "String: \\"" << testString1 << "\\"" << endl;\n        cout << "All characters unique? " << (hasAllUnique(testString1) ? "Yes" : "No") << endl;\n        \n        cout << "\\nString: \\"" << testString2 << "\\"" << endl;\n        cout << "All characters unique? " << (hasAllUnique(testString2) ? "Yes" : "No") << endl;\n        \n        // Find first duplicate character\n        auto findFirstDuplicate = [](const string& str) -> char {\n            vector<bool> charSet(256, false);\n            \n            for(char c : str) {\n                if(c == \' \') continue;\n                \n                if(charSet[c]) {\n                    return c;\n                }\n                charSet[c] = true;\n            }\n            return \'\\0\';  // No duplicate\n        };\n        \n        char duplicate = findFirstDuplicate(testString2);\n        if(duplicate != \'\\0\') {\n            cout << "First duplicate character: \'" << duplicate << "\'" << endl;\n        }\n    }\n    \n    // 4. Spell Checker Simulation\n    static void spellChecker() {\n        cout << "\\n=== 4. Spell Checker Simulation ===" << endl;\n        \n        // Dictionary of valid words\n        vector<string> dictionary = {\n            "apple", "banana", "cherry", "date", "elderberry", \n            "fig", "grape", "honeydew", "kiwi", "lemon"\n        };\n        \n        // Text to check\n        vector<string> text = {"I", "like", "apples", "and", "bananas", \n                               "but", "not", "cheris", "or", "dates"};\n        \n        // Create HashSet from dictionary\n        vector<bool> dictSet(1000, false);\n        for(const auto& word : dictionary) {\n            size_t hash = 0;\n            for(char c : word) hash = hash * 31 + c;\n            hash %= 1000;\n            dictSet[hash] = true;\n        }\n        \n        cout << "Dictionary: ";\n        for(const auto& word : dictionary) cout << word << " ";\n        cout << endl;\n        \n        cout << "\\nText to check: ";\n        for(const auto& word : text) cout << word << " ";\n        cout << endl;\n        \n        cout << "\\nSpell check results:" << endl;\n        for(const auto& word : text) {\n            // Convert to lowercase for comparison\n            string lowerWord = word;\n            transform(lowerWord.begin(), lowerWord.end(), lowerWord.begin(), ::tolower);\n            \n            size_t hash = 0;\n            for(char c : lowerWord) hash = hash * 31 + c;\n            hash %= 1000;\n            \n            if(dictSet[hash]) {\n                cout << "  \u2713 " << word << " is spelled correctly" << endl;\n            } else {\n                cout << "  \u2717 " << word << " is misspelled" << endl;\n                \n                // Find suggestions\n                cout << "    Suggestions: ";\n                bool foundSuggestion = false;\n                \n                for(const auto& dictWord : dictionary) {\n                    // Simple suggestion: words with same first letter\n                    if(tolower(dictWord[0]) == tolower(lowerWord[0])) {\n                        cout << dictWord << " ";\n                        foundSuggestion = true;\n                    }\n                }\n                \n                if(!foundSuggestion) {\n                    cout << "(no suggestions)";\n                }\n                cout << endl;\n            }\n        }\n    }\n    \n    // 5. Find symmetric difference between two arrays\n    static void findSymmetricDifference() {\n        cout << "\\n=== 5. Symmetric Difference Between Arrays ===" << endl;\n        \n        vector<int> array1 = {1, 2, 3, 4, 5};\n        vector<int> array2 = {4, 5, 6, 7, 8};\n        \n        cout << "Array 1: ";\n        for(int num : array1) cout << num << " ";\n        cout << endl;\n        \n        cout << "Array 2: ";\n        for(int num : array2) cout << num << " ";\n        cout << endl;\n        \n        // Using HashSet approach\n        vector<bool> set1(100, false);\n        vector<bool> set2(100, false);\n        \n        for(int num : array1) set1[num] = true;\n        for(int num : array2) set2[num] = true;\n        \n        vector<int> symmetricDiff;\n        \n        // Elements in array1 but not in array2\n        for(int num : array1) {\n            if(!set2[num]) {\n                symmetricDiff.push_back(num);\n            }\n        }\n        \n        // Elements in array2 but not in array1\n        for(int num : array2) {\n            if(!set1[num]) {\n                symmetricDiff.push_back(num);\n            }\n        }\n        \n        cout << "Symmetric difference: ";\n        sort(symmetricDiff.begin(), symmetricDiff.end());\n        for(int num : symmetricDiff) cout << num << " ";\n        cout << endl;\n        \n        cout << "Explanation: Elements present in either array but not in both" << endl;\n    }\n};\n\nint main() {\n    cout << "=== Practical Applications of HashSet ===" << endl;\n    \n    HashSetApplications::findUniqueElements();\n    HashSetApplications::findDuplicates();\n    HashSetApplications::checkUniqueCharacters();\n    HashSetApplications::spellChecker();\n    HashSetApplications::findSymmetricDifference();\n    \n    return 0;\n}\n'})}),"\n",(0,s.jsx)(e.h2,{id:"dsa-hash-maps",children:"DSA Hash Maps"}),"\n",(0,s.jsx)(e.h3,{id:"1-hashmap-implementation",children:"1. HashMap Implementation"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <vector>\n#include <list>\n#include <string>\n#include <functional>\n#include <utility>\n#include <iomanip>\n#include <algorithm>\nusing namespace std;\n\n// HashMap Implementation with Separate Chaining\ntemplate<typename K, typename V>\nclass HashMap {\nprivate:\n    vector<list<pair<K, V>>> table;\n    int capacity;\n    int size;\n    double loadFactorThreshold;\n    \n    // Hash function\n    size_t hashFunction(const K& key) const {\n        hash<K> hasher;\n        return hasher(key) % capacity;\n    }\n    \n    // Rehash when load factor exceeds threshold\n    void rehash() {\n        cout << "\\n\u26a0\ufe0f  Load factor exceeded threshold (" << loadFactor() << " > " \n             << loadFactorThreshold << "). Rehashing..." << endl;\n        \n        int oldCapacity = capacity;\n        capacity = nextPrime(capacity * 2);\n        \n        vector<list<pair<K, V>>> oldTable = move(table);\n        table = vector<list<pair<K, V>>>(capacity);\n        size = 0;\n        \n        // Reinsert all elements\n        for(const auto& bucket : oldTable) {\n            for(const auto& kv : bucket) {\n                insert(kv.first, kv.second);\n            }\n        }\n        \n        cout << "\u2705 Rehashed: New capacity = " << capacity << endl;\n    }\n    \n    // Prime number utilities\n    bool isPrime(int n) const {\n        if(n <= 1) return false;\n        if(n <= 3) return true;\n        if(n % 2 == 0 || n % 3 == 0) return false;\n        \n        for(int i = 5; i * i <= n; i += 6) {\n            if(n % i == 0 || n % (i + 2) == 0) return false;\n        }\n        return true;\n    }\n    \n    int nextPrime(int n) const {\n        while(!isPrime(n)) {\n            n++;\n        }\n        return n;\n    }\n    \npublic:\n    // Constructor\n    HashMap(int initialCapacity = 10, double threshold = 0.7) \n        : capacity(nextPrime(initialCapacity)), size(0), loadFactorThreshold(threshold) {\n        table.resize(capacity);\n        cout << "HashMap created with capacity: " << capacity \n             << ", Load factor threshold: " << loadFactorThreshold << endl;\n    }\n    \n    // Insert or update key-value pair\n    void insert(const K& key, const V& value) {\n        if(loadFactor() >= loadFactorThreshold) {\n            rehash();\n        }\n        \n        size_t index = hashFunction(key);\n        \n        // Check if key already exists\n        for(auto& kv : table[index]) {\n            if(kv.first == key) {\n                kv.second = value;  // Update existing key\n                cout << "Updated key \'" << key << "\' with value: " << value << endl;\n                return;\n            }\n        }\n        \n        // Insert new key-value pair\n        table[index].emplace_back(key, value);\n        size++;\n        \n        cout << "Inserted key \'" << key << "\' with value: " << value \n             << " at index: " << index << endl;\n    }\n    \n    // Access element with [] operator\n    V& operator[](const K& key) {\n        size_t index = hashFunction(key);\n        \n        // Search for existing key\n        for(auto& kv : table[index]) {\n            if(kv.first == key) {\n                return kv.second;\n            }\n        }\n        \n        // Key not found, insert default value\n        table[index].emplace_back(key, V());\n        size++;\n        return table[index].back().second;\n    }\n    \n    // Access element (const version)\n    const V& at(const K& key) const {\n        size_t index = hashFunction(key);\n        \n        for(const auto& kv : table[index]) {\n            if(kv.first == key) {\n                return kv.second;\n            }\n        }\n        \n        throw out_of_range("Key not found in HashMap");\n    }\n    \n    // Check if key exists\n    bool contains(const K& key) const {\n        size_t index = hashFunction(key);\n        \n        for(const auto& kv : table[index]) {\n            if(kv.first == key) {\n                return true;\n            }\n        }\n        return false;\n    }\n    \n    // Remove key-value pair\n    bool erase(const K& key) {\n        size_t index = hashFunction(key);\n        auto& bucket = table[index];\n        \n        for(auto it = bucket.begin(); it != bucket.end(); ++it) {\n            if(it->first == key) {\n                bucket.erase(it);\n                size--;\n                cout << "Removed key \'" << key << "\' from index: " << index << endl;\n                return true;\n            }\n        }\n        \n        cout << "Key \'" << key << "\' not found for removal" << endl;\n        return false;\n    }\n    \n    // Get size\n    int getSize() const {\n        return size;\n    }\n    \n    // Get capacity\n    int getCapacity() const {\n        return capacity;\n    }\n    \n    // Calculate load factor\n    double loadFactor() const {\n        return static_cast<double>(size) / capacity;\n    }\n    \n    // Check if empty\n    bool empty() const {\n        return size == 0;\n    }\n    \n    // Clear all elements\n    void clear() {\n        for(auto& bucket : table) {\n            bucket.clear();\n        }\n        size = 0;\n        cout << "HashMap cleared" << endl;\n    }\n    \n    // Get all keys\n    vector<K> keys() const {\n        vector<K> keyList;\n        keyList.reserve(size);\n        \n        for(const auto& bucket : table) {\n            for(const auto& kv : bucket) {\n                keyList.push_back(kv.first);\n            }\n        }\n        \n        return keyList;\n    }\n    \n    // Get all values\n    vector<V> values() const {\n        vector<V> valueList;\n        valueList.reserve(size);\n        \n        for(const auto& bucket : table) {\n            for(const auto& kv : bucket) {\n                valueList.push_back(kv.second);\n            }\n        }\n        \n        return valueList;\n    }\n    \n    // Get all entries\n    vector<pair<K, V>> entries() const {\n        vector<pair<K, V>> entryList;\n        entryList.reserve(size);\n        \n        for(const auto& bucket : table) {\n            for(const auto& kv : bucket) {\n                entryList.emplace_back(kv.first, kv.second);\n            }\n        }\n        \n        return entryList;\n    }\n    \n    // Display HashMap\n    void display() const {\n        cout << "\\n=== HashMap Details ===" << endl;\n        cout << "Capacity: " << capacity << endl;\n        cout << "Size: " << size << endl;\n        cout << "Load Factor: " << fixed << setprecision(2) << loadFactor() << endl;\n        \n        if(size == 0) {\n            cout << "HashMap is empty" << endl;\n            return;\n        }\n        \n        cout << "\\nEntries:" << endl;\n        for(const auto& entry : entries()) {\n            cout << "  " << entry.first << " \u2192 " << entry.second << endl;\n        }\n        \n        cout << "\\nBucket Distribution:" << endl;\n        int emptyBuckets = 0;\n        int maxChainLength = 0;\n        \n        for(int i = 0; i < capacity; i++) {\n            int chainLength = table[i].size();\n            \n            if(chainLength == 0) {\n                emptyBuckets++;\n            }\n            \n            if(chainLength > maxChainLength) {\n                maxChainLength = chainLength;\n            }\n            \n            cout << "  Bucket[" << i << "]: ";\n            if(chainLength == 0) {\n                cout << "Empty";\n            } else {\n                for(const auto& kv : table[i]) {\n                    cout << "(" << kv.first << ":" << kv.second << ")";\n                    if(&kv != &table[i].back()) {\n                        cout << " \u2192 ";\n                    }\n                }\n                cout << " [Length: " << chainLength << "]";\n            }\n            cout << endl;\n        }\n        \n        cout << "\\nStatistics:" << endl;\n        cout << "  Empty Buckets: " << emptyBuckets << " (" \n             << (emptyBuckets * 100.0 / capacity) << "%)" << endl;\n        cout << "  Max Chain Length: " << maxChainLength << endl;\n    }\n    \n    // Visual representation\n    void displayVisual() const {\n        cout << "\\n=== HashMap Visualization ===" << endl;\n        \n        for(int i = 0; i < capacity; i++) {\n            cout << "[" << setw(2) << i << "] ";\n            \n            if(table[i].empty()) {\n                cout << "\u2514\u2500 Empty" << endl;\n            } else {\n                cout << "\u251c\u2500 ";\n                bool first = true;\n                for(const auto& kv : table[i]) {\n                    if(!first) cout << "   \u251c\u2500 ";\n                    cout << kv.first << " \u2192 " << kv.second << endl;\n                    first = false;\n                }\n            }\n        }\n        \n        cout << "=============================" << endl;\n    }\n    \n    // Merge with another HashMap\n    void merge(const HashMap<K, V>& other) {\n        for(const auto& bucket : other.table) {\n            for(const auto& kv : bucket) {\n                insert(kv.first, kv.second);\n            }\n        }\n    }\n};\n\n// Demonstration\nvoid demonstrateHashMap() {\n    cout << "=== HashMap Implementation ===" << endl;\n    \n    HashMap<string, int> studentGrades(7, 0.6);\n    \n    // Insert operations\n    studentGrades.insert("Alice", 95);\n    studentGrades.insert("Bob", 87);\n    studentGrades.insert("Charlie", 92);\n    studentGrades.insert("David", 78);\n    \n    studentGrades.displayVisual();\n    \n    // Access using [] operator\n    cout << "\\n--- Access with [] Operator ---" << endl;\n    cout << "Alice\'s grade: " << studentGrades["Alice"] << endl;\n    \n    // Update using [] operator\n    studentGrades["Alice"] = 96;\n    cout << "Updated Alice\'s grade: " << studentGrades["Alice"] << endl;\n    \n    // Insert using [] operator\n    studentGrades["Eve"] = 88;\n    cout << "Eve\'s grade (auto-inserted): " << studentGrades["Eve"] << endl;\n    \n    // Check contains\n    cout << "\\n--- Contains Check ---" << endl;\n    cout << "Contains \'Bob\'? " << (studentGrades.contains("Bob") ? "Yes" : "No") << endl;\n    cout << "Contains \'Frank\'? " << (studentGrades.contains("Frank") ? "Yes" : "No") << endl;\n    \n    // Insert more to trigger rehash\n    cout << "\\n--- Trigger Rehash ---" << endl;\n    studentGrades.insert("Frank", 85);\n    studentGrades.insert("Grace", 91);\n    studentGrades.insert("Henry", 79);\n    \n    studentGrades.display();\n    \n    // Get keys, values, and entries\n    cout << "\\n--- Keys, Values, and Entries ---" << endl;\n    \n    auto allKeys = studentGrades.keys();\n    cout << "Keys: ";\n    for(const auto& key : allKeys) cout << key << " ";\n    cout << endl;\n    \n    auto allValues = studentGrades.values();\n    cout << "Values: ";\n    for(int grade : allValues) cout << grade << " ";\n    cout << endl;\n    \n    // Remove operation\n    cout << "\\n--- Remove Operation ---" << endl;\n    studentGrades.erase("Bob");\n    \n    // Try to access removed key\n    try {\n        cout << "Trying to access removed key \'Bob\': ";\n        cout << studentGrades.at("Bob") << endl;\n    } catch(const out_of_range& e) {\n        cout << "Error: " << e.what() << endl;\n    }\n    \n    studentGrades.displayVisual();\n    \n    // Create another HashMap and merge\n    cout << "\\n--- Merge with Another HashMap ---" << endl;\n    HashMap<string, int> additionalGrades(5);\n    additionalGrades.insert("Ivy", 93);\n    additionalGrades.insert("Jack", 84);\n    additionalGrades.insert("Alice", 97);  // Should update existing\n    \n    studentGrades.merge(additionalGrades);\n    studentGrades.display();\n    \n    // Clear HashMap\n    cout << "\\n--- Clear HashMap ---" << endl;\n    studentGrades.clear();\n    cout << "HashMap is empty: " << (studentGrades.empty() ? "Yes" : "No") << endl;\n}\n\nint main() {\n    demonstrateHashMap();\n    return 0;\n}\n'})}),"\n",(0,s.jsx)(e.h3,{id:"2-practical-applications-of-hashmap",children:"2. Practical Applications of HashMap"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <sstream>\n#include <iomanip>\nusing namespace std;\n\nclass HashMapApplications {\npublic:\n    // 1. Word Frequency Counter\n    static void wordFrequencyCounter() {\n        cout << "=== 1. Word Frequency Counter ===" << endl;\n        \n        string text = "the quick brown fox jumps over the lazy dog the fox is quick";\n        \n        cout << "Text: \\"" << text << "\\"" << endl;\n        \n        // Count word frequencies using map (simulating HashMap)\n        map<string, int> frequencyMap;\n        \n        // Tokenize the text\n        stringstream ss(text);\n        string word;\n        \n        while(ss >> word) {\n            // Convert to lowercase for consistency\n            transform(word.begin(), word.end(), word.begin(), ::tolower);\n            frequencyMap[word]++;\n        }\n        \n        cout << "\\nWord Frequencies:" << endl;\n        cout << left << setw(15) << "Word" << "Frequency" << endl;\n        cout << string(25, \'-\') << endl;\n        \n        for(const auto& entry : frequencyMap) {\n            cout << left << setw(15) << entry.first << entry.second << endl;\n        }\n        \n        // Find most frequent word\n        string mostFrequentWord;\n        int maxFrequency = 0;\n        \n        for(const auto& entry : frequencyMap) {\n            if(entry.second > maxFrequency) {\n                maxFrequency = entry.second;\n                mostFrequentWord = entry.first;\n            }\n        }\n        \n        cout << "\\nMost frequent word: \\"" << mostFrequentWord \n             << "\\" (appears " << maxFrequency << " times)" << endl;\n    }\n    \n    // 2. Character Frequency Counter\n    static void characterFrequencyCounter() {\n        cout << "\\n\\n=== 2. Character Frequency Counter ===" << endl;\n        \n        string text = "Hello, World! This is a test string.";\n        \n        cout << "Text: \\"" << text << "\\"" << endl;\n        \n        // Count character frequencies\n        map<char, int> charFrequency;\n        \n        for(char c : text) {\n            if(isalpha(c)) {  // Only count letters\n                char lowerC = tolower(c);\n                charFrequency[lowerC]++;\n            }\n        }\n        \n        cout << "\\nCharacter Frequencies (letters only):" << endl;\n        \n        // Display as histogram\n        for(char c = \'a\'; c <= \'z\'; c++) {\n            if(charFrequency.find(c) != charFrequency.end()) {\n                cout << c << ": " << string(charFrequency[c], \'*\') \n                     << " (" << charFrequency[c] << ")" << endl;\n            }\n        }\n        \n        // Find most and least frequent letters\n        char mostFrequent = \' \';\n        char leastFrequent = \' \';\n        int maxCount = 0;\n        int minCount = INT_MAX;\n        \n        for(const auto& entry : charFrequency) {\n            if(entry.second > maxCount) {\n                maxCount = entry.second;\n                mostFrequent = entry.first;\n            }\n            if(entry.second < minCount) {\n                minCount = entry.second;\n                leastFrequent = entry.first;\n            }\n        }\n        \n        cout << "\\nMost frequent letter: \'" << mostFrequent \n             << "\' (" << maxCount << " times)" << endl;\n        cout << "Least frequent letter: \'" << leastFrequent \n             << "\' (" << minCount << " times)" << endl;\n    }\n    \n    // 3. Two Sum Problem\n    static void twoSumProblem() {\n        cout << "\\n\\n=== 3. Two Sum Problem ===" << endl;\n        \n        vector<int> numbers = {2, 7, 11, 15, 3, 6, 8};\n        int target = 9;\n        \n        cout << "Array: ";\n        for(int num : numbers) cout << num << " ";\n        cout << endl;\n        cout << "Target sum: " << target << endl;\n        \n        // Using HashMap to solve Two Sum\n        map<int, int> numIndexMap;  // value \u2192 index\n        \n        cout << "\\nSearching for pairs that sum to " << target << ":" << endl;\n        \n        for(int i = 0; i < numbers.size(); i++) {\n            int complement = target - numbers[i];\n            \n            if(numIndexMap.find(complement) != numIndexMap.end()) {\n                cout << "  Found: numbers[" << numIndexMap[complement] << "] = " << complement\n                     << " + numbers[" << i << "] = " << numbers[i]\n                     << " = " << target << endl;\n            }\n            \n            numIndexMap[numbers[i]] = i;\n        }\n        \n        // Alternative: Find all pairs\n        cout << "\\nAll pairs that sum to " << target << ":" << endl;\n        vector<bool> used(numbers.size(), false);\n        \n        for(int i = 0; i < numbers.size(); i++) {\n            if(used[i]) continue;\n            \n            for(int j = i + 1; j < numbers.size(); j++) {\n                if(used[j]) continue;\n                \n                if(numbers[i] + numbers[j] == target) {\n                    cout << "  (" << numbers[i] << ", " << numbers[j] << ")" << endl;\n                    used[i] = used[j] = true;\n                    break;\n                }\n            }\n        }\n    }\n    \n    // 4. Group Anagrams\n    static void groupAnagrams() {\n        cout << "\\n\\n=== 4. Group Anagrams ===" << endl;\n        \n        vector<string> words = {"eat", "tea", "tan", "ate", "nat", "bat", "tab", "ant"};\n        \n        cout << "Words: ";\n        for(const auto& word : words) cout << word << " ";\n        cout << endl;\n        \n        // Group anagrams using HashMap\n        map<string, vector<string>> anagramGroups;\n        \n        for(const string& word : words) {\n            // Create a sorted version as key\n            string sortedWord = word;\n            sort(sortedWord.begin(), sortedWord.end());\n            \n            anagramGroups[sortedWord].push_back(word);\n        }\n        \n        cout << "\\nAnagram Groups:" << endl;\n        int groupNum = 1;\n        \n        for(const auto& group : anagramGroups) {\n            cout << "Group " << groupNum++ << " (key: \\"" << group.first << "\\"): ";\n            for(const auto& word : group.second) {\n                cout << word << " ";\n            }\n            cout << endl;\n        }\n        \n        // Show the HashMap structure\n        cout << "\\nHashMap Structure:" << endl;\n        for(const auto& entry : anagramGroups) {\n            cout << "  Key: \\"" << entry.first << "\\" \u2192 ";\n            cout << "Values: { ";\n            for(const auto& word : entry.second) {\n                cout << word << " ";\n            }\n            cout << "}" << endl;\n        }\n    }\n    \n    // 5. First Non-Repeating Character\n    static void firstNonRepeatingCharacter() {\n        cout << "\\n\\n=== 5. First Non-Repeating Character ===" << endl;\n        \n        string testString = "swiss";\n        \n        cout << "String: \\"" << testString << "\\"" << endl;\n        \n        // Count character frequencies\n        map<char, pair<int, int>> charInfo;  // char \u2192 (frequency, firstIndex)\n        \n        for(int i = 0; i < testString.length(); i++) {\n            char c = testString[i];\n            \n            if(charInfo.find(c) == charInfo.end()) {\n                // First occurrence\n                charInfo[c] = make_pair(1, i);\n            } else {\n                // Increment frequency\n                charInfo[c].first++;\n            }\n        }\n        \n        // Find first non-repeating character\n        int firstNonRepeatingIndex = INT_MAX;\n        char firstNonRepeatingChar = \'\\0\';\n        \n        cout << "\\nCharacter Analysis:" << endl;\n        for(const auto& entry : charInfo) {\n            cout << "  \'" << entry.first << "\': frequency=" << entry.second.first\n                 << ", first index=" << entry.second.second << endl;\n            \n            if(entry.second.first == 1 && entry.second.second < firstNonRepeatingIndex) {\n                firstNonRepeatingIndex = entry.second.second;\n                firstNonRepeatingChar = entry.first;\n            }\n        }\n        \n        if(firstNonRepeatingChar != \'\\0\') {\n            cout << "\\nFirst non-repeating character: \'" << firstNonRepeatingChar\n                 << "\' at index " << firstNonRepeatingIndex << endl;\n        } else {\n            cout << "\\nNo non-repeating characters found" << endl;\n        }\n        \n        // Additional test cases\n        cout << "\\nAdditional Test Cases:" << endl;\n        vector<string> testCases = {"programming", "aabbcc", "leetcode", "loveleetcode"};\n        \n        for(const string& testCase : testCases) {\n            map<char, int> freq;\n            for(char c : testCase) freq[c]++;\n            \n            char result = \'\\0\';\n            for(char c : testCase) {\n                if(freq[c] == 1) {\n                    result = c;\n                    break;\n                }\n            }\n            \n            cout << "  \\"" << testCase << "\\" \u2192 ";\n            if(result != \'\\0\') {\n                cout << "\'" << result << "\'" << endl;\n            } else {\n                cout << "No unique character" << endl;\n            }\n        }\n    }\n    \n    // 6. LRU Cache Simulation\n    static void lruCacheSimulation() {\n        cout << "\\n\\n=== 6. LRU Cache Simulation ===" << endl;\n        \n        // Simplified LRU Cache using map and list\n        int cacheCapacity = 3;\n        \n        cout << "LRU Cache with capacity: " << cacheCapacity << endl;\n        \n        // Using list to maintain order (most recent at front)\n        list<pair<int, string>> cache;\n        map<int, list<pair<int, string>>::iterator> cacheMap;\n        \n        auto get = [&](int key) -> string {\n            if(cacheMap.find(key) == cacheMap.end()) {\n                cout << "  GET(" << key << ") \u2192 Cache miss" << endl;\n                return "";\n            }\n            \n            // Move to front (most recently used)\n            auto it = cacheMap[key];\n            string value = it->second;\n            cache.erase(it);\n            cache.push_front({key, value});\n            cacheMap[key] = cache.begin();\n            \n            cout << "  GET(" << key << ") \u2192 \\"" << value << "\\"" << endl;\n            return value;\n        };\n        \n        auto put = [&](int key, const string& value) {\n            cout << "  PUT(" << key << ", \\"" << value << "\\")" << endl;\n            \n            if(cacheMap.find(key) != cacheMap.end()) {\n                // Update existing\n                auto it = cacheMap[key];\n                cache.erase(it);\n            } else if(cache.size() >= cacheCapacity) {\n                // Remove least recently used\n                int lruKey = cache.back().first;\n                cout << "    Cache full, removing LRU key: " << lruKey << endl;\n                cacheMap.erase(lruKey);\n                cache.pop_back();\n            }\n            \n            // Add to front\n            cache.push_front({key, value});\n            cacheMap[key] = cache.begin();\n        };\n        \n        auto displayCache = [&]() {\n            cout << "  Cache state: ";\n            for(const auto& item : cache) {\n                cout << item.first << ":\\"" << item.second << "\\" ";\n            }\n            cout << "(most recent first)" << endl;\n        };\n        \n        // Simulate operations\n        cout << "\\nCache Operations:" << endl;\n        put(1, "Data1");\n        put(2, "Data2");\n        put(3, "Data3");\n        displayCache();\n        \n        get(1);  // Access key 1 (becomes most recent)\n        displayCache();\n        \n        put(4, "Data4");  // Should remove key 2 (least recent)\n        displayCache();\n        \n        get(2);  // Cache miss\n        get(3);  // Access key 3\n        displayCache();\n        \n        put(5, "Data5");  // Should remove key 1\n        displayCache();\n    }\n};\n\nint main() {\n    cout << "=== Practical Applications of HashMap ===" << endl;\n    \n    HashMapApplications::wordFrequencyCounter();\n    HashMapApplications::characterFrequencyCounter();\n    HashMapApplications::twoSumProblem();\n    HashMapApplications::groupAnagrams();\n    HashMapApplications::firstNonRepeatingCharacter();\n    HashMapApplications::lruCacheSimulation();\n    \n    return 0;\n}\n'})}),"\n",(0,s.jsx)(e.h2,{id:"advanced-hash-table-concepts",children:"Advanced Hash Table Concepts"}),"\n",(0,s.jsx)(e.h3,{id:"1-custom-hash-functions",children:"1. Custom Hash Functions"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <string>\n#include <functional>\n#include <iomanip>\nusing namespace std;\n\nclass CustomHashFunctions {\npublic:\n    // 1. String hash functions\n    static void demonstrateStringHashing() {\n        cout << "=== String Hash Functions ===" << endl;\n        \n        vector<string> testStrings = {\n            "hello", "world", "hash", "table", "example",\n            "a", "ab", "abc", "abcd", "abcde"\n        };\n        \n        cout << left << setw(15) << "String" \n             << setw(20) << "std::hash" \n             << setw(20) << "Custom Hash 1" \n             << setw(20) << "Custom Hash 2" << endl;\n        cout << string(75, \'-\') << endl;\n        \n        for(const auto& str : testStrings) {\n            // Standard hash\n            hash<string> stdHasher;\n            size_t stdHash = stdHasher(str);\n            \n            // Custom hash 1: Simple polynomial rolling hash\n            size_t customHash1 = 0;\n            for(char c : str) {\n                customHash1 = customHash1 * 31 + c;\n            }\n            \n            // Custom hash 2: DJB2 hash algorithm\n            size_t customHash2 = 5381;\n            for(char c : str) {\n                customHash2 = ((customHash2 << 5) + customHash2) + c;\n            }\n            \n            cout << left << setw(15) << str \n                 << setw(20) << (stdHash % 1000)\n                 << setw(20) << (customHash1 % 1000)\n                 << setw(20) << (customHash2 % 1000) << endl;\n        }\n    }\n    \n    // 2. Custom object hashing\n    struct Person {\n        string name;\n        int age;\n        string city;\n        \n        Person(string n, int a, string c) : name(n), age(a), city(c) {}\n        \n        // Equality operator\n        bool operator==(const Person& other) const {\n            return name == other.name && age == other.age && city == other.city;\n        }\n    };\n    \n    // Custom hash for Person\n    struct PersonHash {\n        size_t operator()(const Person& p) const {\n            // Combine hashes of members\n            size_t nameHash = hash<string>()(p.name);\n            size_t ageHash = hash<int>()(p.age);\n            size_t cityHash = hash<string>()(p.city);\n            \n            // Simple combination\n            return nameHash ^ (ageHash << 1) ^ (cityHash << 2);\n        }\n    };\n    \n    static void demonstrateCustomObjectHashing() {\n        cout << "\\n\\n=== Custom Object Hashing ===" << endl;\n        \n        vector<Person> people = {\n            Person("Alice", 25, "New York"),\n            Person("Bob", 30, "London"),\n            Person("Charlie", 25, "New York"),\n            Person("Alice", 25, "New York")  // Duplicate\n        };\n        \n        PersonHash personHasher;\n        \n        cout << "Person objects and their hashes:" << endl;\n        cout << left << setw(20) << "Name" \n             << setw(10) << "Age" \n             << setw(15) << "City" \n             << setw(15) << "Hash" << endl;\n        cout << string(60, \'-\') << endl;\n        \n        for(const auto& person : people) {\n            size_t hashValue = personHasher(person);\n            cout << left << setw(20) << person.name \n                 << setw(10) << person.age \n                 << setw(15) << person.city \n                 << setw(15) << (hashValue % 1000) << endl;\n        }\n        \n        // Check equality and hash equality\n        cout << "\\nChecking duplicates:" << endl;\n        for(size_t i = 0; i < people.size(); i++) {\n            for(size_t j = i + 1; j < people.size(); j++) {\n                if(people[i] == people[j]) {\n                    cout << "  Person " << i << " and " << j << " are equal" << endl;\n                }\n                if(personHasher(people[i]) == personHasher(people[j])) {\n                    cout << "  Person " << i << " and " << j << " have same hash" << endl;\n                }\n            }\n        }\n    }\n    \n    // 3. Perfect hashing demonstration\n    static void demonstratePerfectHashing() {\n        cout << "\\n\\n=== Perfect Hashing Concept ===" << endl;\n        \n        // Small set of known keys\n        vector<string> keys = {"January", "February", "March", "April", "May", "June"};\n        \n        cout << "Keys: ";\n        for(const auto& key : keys) cout << key << " ";\n        cout << endl;\n        \n        // Try to find a perfect hash function\n        cout << "\\nSearching for perfect hash function..." << endl;\n        \n        for(int a = 1; a <= 10; a++) {\n            for(int b = 0; b <= 10; b++) {\n                vector<bool> occupied(keys.size(), false);\n                bool collision = false;\n                \n                for(const auto& key : keys) {\n                    size_t hash = 0;\n                    for(char c : key) {\n                        hash = hash * a + c + b;\n                    }\n                    size_t index = hash % keys.size();\n                    \n                    if(occupied[index]) {\n                        collision = true;\n                        break;\n                    }\n                    occupied[index] = true;\n                }\n                \n                if(!collision) {\n                    cout << "  Found perfect hash: h(key) = (";\n                    cout << a << " * sum(chars) + " << b << ") % " << keys.size() << endl;\n                    \n                    // Show the mapping\n                    cout << "  Mapping:" << endl;\n                    for(const auto& key : keys) {\n                        size_t hash = 0;\n                        for(char c : key) hash = hash * a + c + b;\n                        size_t index = hash % keys.size();\n                        cout << "    \\"" << key << "\\" \u2192 " << index << endl;\n                    }\n                    return;\n                }\n            }\n        }\n        \n        cout << "  No perfect hash found for this set with simple linear functions" << endl;\n    }\n    \n    // 4. Cryptographic hash functions (conceptual)\n    static void demonstrateCryptographicHashing() {\n        cout << "\\n\\n=== Cryptographic Hash Properties ===" << endl;\n        \n        string testMessage = "Hello, World!";\n        string similarMessage = "Hello, World?";\n        \n        cout << "Testing cryptographic hash properties:" << endl;\n        cout << "1. Deterministic: Same input \u2192 same output" << endl;\n        cout << "2. Quick to compute" << endl;\n        cout << "3. Small changes \u2192 completely different hash" << endl;\n        cout << "4. Impossible to reverse (pre-image resistance)" << endl;\n        cout << "5. Hard to find collisions" << endl;\n        \n        // Simple simulation (not actually cryptographic)\n        cout << "\\nSimulation with simple hash functions:" << endl;\n        \n        auto simpleHash = [](const string& str) -> size_t {\n            size_t hash = 0;\n            for(char c : str) {\n                hash = hash * 31 + c;\n            }\n            return hash;\n        };\n        \n        size_t hash1 = simpleHash(testMessage);\n        size_t hash2 = simpleHash(similarMessage);\n        \n        cout << "Message 1: \\"" << testMessage << "\\"" << endl;\n        cout << "Hash 1: " << hash1 << " (hex: " << hex << hash1 << dec << ")" << endl;\n        \n        cout << "\\nMessage 2: \\"" << similarMessage << "\\"" << endl;\n        cout << "Hash 2: " << hash2 << " (hex: " << hex << hash2 << dec << ")" << endl;\n        \n        cout << "\\nHash difference: " << abs((long long)(hash1 - hash2)) << endl;\n        cout << "Percentage difference: " \n             << (abs((long long)(hash1 - hash2)) * 100.0 / max(hash1, hash2)) << "%" << endl;\n    }\n};\n\nint main() {\n    CustomHashFunctions::demonstrateStringHashing();\n    CustomHashFunctions::demonstrateCustomObjectHashing();\n    CustomHashFunctions::demonstratePerfectHashing();\n    CustomHashFunctions::demonstrateCryptographicHashing();\n    \n    return 0;\n}\n'})}),"\n",(0,s.jsx)(e.h3,{id:"2-performance-analysis-and-comparison",children:"2. Performance Analysis and Comparison"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <unordered_map>\n#include <map>\n#include <vector>\n#include <chrono>\n#include <random>\n#include <iomanip>\n#include <string>\n#include <algorithm>\nusing namespace std;\nusing namespace chrono;\n\nclass HashTablePerformance {\nprivate:\n    // Generate random strings\n    static vector<string> generateRandomStrings(int count, int length = 10) {\n        vector<string> strings;\n        strings.reserve(count);\n        \n        random_device rd;\n        mt19937 gen(rd());\n        uniform_int_distribution<> dis(\'a\', \'z\');\n        \n        for(int i = 0; i < count; i++) {\n            string str;\n            str.reserve(length);\n            for(int j = 0; j < length; j++) {\n                str.push_back(static_cast<char>(dis(gen)));\n            }\n            strings.push_back(str);\n        }\n        \n        return strings;\n    }\n    \n    // Generate random integers\n    static vector<int> generateRandomIntegers(int count, int minVal = 0, int maxVal = 1000000) {\n        vector<int> integers;\n        integers.reserve(count);\n        \n        random_device rd;\n        mt19937 gen(rd());\n        uniform_int_distribution<> dis(minVal, maxVal);\n        \n        for(int i = 0; i < count; i++) {\n            integers.push_back(dis(gen));\n        }\n        \n        return integers;\n    }\n    \npublic:\n    // Compare different hash table implementations\n    static void compareImplementations(int elementCount) {\n        cout << "\\n" << string(80, \'=\') << endl;\n        cout << "Performance Comparison: Hash Table Implementations" << endl;\n        cout << "Testing with " << elementCount << " elements" << endl;\n        cout << string(80, \'=\') << endl;\n        \n        // Generate test data\n        auto strings = generateRandomStrings(elementCount);\n        auto integers = generateRandomIntegers(elementCount);\n        \n        // 1. std::unordered_map (Hash Table)\n        cout << "\\n1. std::unordered_map (Hash Table):" << endl;\n        unordered_map<string, int> unorderedMap;\n        \n        // Insertion test\n        auto start = high_resolution_clock::now();\n        for(int i = 0; i < elementCount; i++) {\n            unorderedMap[strings[i]] = integers[i];\n        }\n        auto end = high_resolution_clock::now();\n        auto unorderedInsertTime = duration_cast<microseconds>(end - start).count();\n        \n        // Search test\n        start = high_resolution_clock::now();\n        for(int i = 0; i < elementCount; i++) {\n            auto it = unorderedMap.find(strings[i]);\n            volatile int value = it->second;  // Prevent optimization\n        }\n        end = high_resolution_clock::now();\n        auto unorderedSearchTime = duration_cast<microseconds>(end - start).count();\n        \n        // Delete test\n        start = high_resolution_clock::now();\n        for(int i = 0; i < elementCount; i++) {\n            unorderedMap.erase(strings[i]);\n        }\n        end = high_resolution_clock::now();\n        auto unorderedDeleteTime = duration_cast<microseconds>(end - start).count();\n        \n        // 2. std::map (Red-Black Tree)\n        cout << "\\n2. std::map (Red-Black Tree - Balanced BST):" << endl;\n        map<string, int> sortedMap;\n        \n        // Insertion test\n        start = high_resolution_clock::now();\n        for(int i = 0; i < elementCount; i++) {\n            sortedMap[strings[i]] = integers[i];\n        }\n        end = high_resolution_clock::now();\n        auto mapInsertTime = duration_cast<microseconds>(end - start).count();\n        \n        // Search test\n        start = high_resolution_clock::now();\n        for(int i = 0; i < elementCount; i++) {\n            auto it = sortedMap.find(strings[i]);\n            volatile int value = it->second;\n        }\n        end = high_resolution_clock::now();\n        auto mapSearchTime = duration_cast<microseconds>(end - start).count();\n        \n        // Delete test\n        start = high_resolution_clock::now();\n        for(int i = 0; i < elementCount; i++) {\n            sortedMap.erase(strings[i]);\n        }\n        end = high_resolution_clock::now();\n        auto mapDeleteTime = duration_cast<microseconds>(end - start).count();\n        \n        // 3. Custom Hash Table (simulated with vector for large data)\n        cout << "\\n3. Custom Hash Table (Separate Chaining - simulated):" << endl;\n        \n        // For fair comparison, we\'ll use unordered_map as proxy\n        // In reality, custom implementation would have different characteristics\n        \n        // Display results\n        cout << fixed << setprecision(2);\n        cout << "\\n" << string(80, \'-\') << endl;\n        cout << left << setw(25) << "Operation" \n             << setw(20) << "unordered_map" \n             << setw(20) << "map (BST)" \n             << setw(15) << "Speedup" << endl;\n        cout << string(80, \'-\') << endl;\n        \n        // Insertion comparison\n        double insertSpeedup = static_cast<double>(mapInsertTime) / unorderedInsertTime;\n        cout << left << setw(25) << "Insertion (\u03bcs)" \n             << setw(20) << unorderedInsertTime \n             << setw(20) << mapInsertTime \n             << setw(15) << insertSpeedup << "x" << endl;\n        \n        // Search comparison\n        double searchSpeedup = static_cast<double>(mapSearchTime) / unorderedSearchTime;\n        cout << left << setw(25) << "Search (\u03bcs)" \n             << setw(20) << unorderedSearchTime \n             << setw(20) << mapSearchTime \n             << setw(15) << searchSpeedup << "x" << endl;\n        \n        // Delete comparison\n        double deleteSpeedup = static_cast<double>(mapDeleteTime) / unorderedDeleteTime;\n        cout << left << setw(25) << "Deletion (\u03bcs)" \n             << setw(20) << unorderedDeleteTime \n             << setw(20) << mapDeleteTime \n             << setw(15) << deleteSpeedup << "x" << endl;\n        \n        cout << "\\nKey Observations:" << endl;\n        cout << "\u2022 unordered_map (hash table): Average O(1) operations" << endl;\n        cout << "\u2022 map (red-black tree): Guaranteed O(log n) operations" << endl;\n        cout << "\u2022 Hash tables are faster but have worst-case O(n)" << endl;\n        cout << "\u2022 Balanced trees provide predictable performance" << endl;\n    }\n    \n    // Analyze load factor impact\n    static void analyzeLoadFactorImpact() {\n        cout << "\\n\\n" << string(80, \'=\') << endl;\n        cout << "Load Factor Impact Analysis" << endl;\n        cout << string(80, \'=\') << endl;\n        \n        const int elementCount = 10000;\n        auto strings = generateRandomStrings(elementCount);\n        auto integers = generateRandomIntegers(elementCount);\n        \n        vector<double> loadFactors = {0.1, 0.25, 0.5, 0.75, 1.0, 1.5, 2.0, 3.0};\n        \n        cout << left << setw(15) << "Load Factor" \n             << setw(20) << "Insert Time (\u03bcs)" \n             << setw(20) << "Search Time (\u03bcs)" \n             << setw(20) << "Collision Rate" << endl;\n        cout << string(75, \'-\') << endl;\n        \n        for(double loadFactor : loadFactors) {\n            // Create hash table with specific load factor\n            int capacity = static_cast<int>(elementCount / loadFactor);\n            unordered_map<string, int> testMap;\n            testMap.rehash(capacity);  // Set initial bucket count\n            \n            // Insert elements\n            auto start = high_resolution_clock::now();\n            for(int i = 0; i < elementCount; i++) {\n                testMap[strings[i]] = integers[i];\n            }\n            auto end = high_resolution_clock::now();\n            auto insertTime = duration_cast<microseconds>(end - start).count();\n            \n            // Search elements\n            start = high_resolution_clock::now();\n            for(int i = 0; i < elementCount; i++) {\n                testMap.find(strings[i]);\n            }\n            end = high_resolution_clock::now();\n            auto searchTime = duration_cast<microseconds>(end - start).count();\n            \n            // Calculate collision rate (approximate)\n            double collisionRate = 0;\n            if(testMap.bucket_count() > 0) {\n                collisionRate = 1.0 - (testMap.size() * 1.0 / testMap.bucket_count());\n            }\n            \n            cout << left << setw(15) << loadFactor \n                 << setw(20) << insertTime \n                 << setw(20) << searchTime \n                 << setw(20) << fixed << setprecision(2) << collisionRate << endl;\n        }\n        \n        cout << "\\nAnalysis:" << endl;\n        cout << "\u2022 Low load factor (< 0.5): Fast operations, more memory" << endl;\n        cout << "\u2022 Optimal load factor (0.7-0.8): Good balance" << endl;\n        cout << "\u2022 High load factor (> 1.0): More collisions, slower" << endl;\n        cout << "\u2022 Standard libraries use ~0.75 as default max load factor" << endl;\n    }\n    \n    // Compare collision resolution strategies\n    static void compareCollisionResolution() {\n        cout << "\\n\\n" << string(80, \'=\') << endl;\n        cout << "Collision Resolution Strategy Comparison" << endl;\n        cout << string(80, \'=\') << endl;\n        \n        const int elementCount = 5000;\n        auto strings = generateRandomStrings(elementCount);\n        \n        cout << "Testing with " << elementCount << " elements" << endl;\n        cout << "Note: Simulating different strategies with std::unordered_map" << endl;\n        \n        // Simulate different scenarios\n        vector<pair<string, double>> scenarios = {\n            {"Best Case (no collisions)", 0.1},\n            {"Good Case (low collisions)", 0.5},\n            {"Average Case", 1.0},\n            {"Worst Case (all collisions)", 100.0}  // Simulated by bad hash\n        };\n        \n        cout << left << setw(30) << "\\nScenario" \n             << setw(20) << "Separate Chaining" \n             << setw(20) << "Linear Probing" \n             << setw(20) << "Double Hashing" << endl;\n        cout << string(90, \'-\') << endl;\n        \n        for(const auto& scenario : scenarios) {\n            // This is a conceptual comparison\n            // In reality, you\'d implement each strategy separately\n            \n            double factor = scenario.second;\n            \n            // Simulated times (in practice, implement and measure)\n            double chainingTime = 100 + (factor * 50);\n            double linearProbingTime = 80 + (factor * 100);\n            double doubleHashingTime = 90 + (factor * 60);\n            \n            cout << left << setw(30) << scenario.first \n                 << setw(20) << fixed << setprecision(1) << chainingTime << " \u03bcs"\n                 << setw(20) << linearProbingTime << " \u03bcs"\n                 << setw(20) << doubleHashingTime << " \u03bcs" << endl;\n        }\n        \n        cout << "\\nStrategy Characteristics:" << endl;\n        cout << "1. Separate Chaining:" << endl;\n        cout << "   \u2022 Simple to implement" << endl;\n        cout << "   \u2022 Handles arbitrary load factors" << endl;\n        cout << "   \u2022 Memory overhead for pointers" << endl;\n        \n        cout << "\\n2. Open Addressing (Linear Probing):" << endl;\n        cout << "   \u2022 Better cache performance" << endl;\n        cout << "   \u2022 Less memory overhead" << endl;\n        cout << "   \u2022 Suffers from clustering" << endl;\n        \n        cout << "\\n3. Open Addressing (Double Hashing):" << endl;\n        cout << "   \u2022 Reduces clustering" << endl;\n        cout << "   \u2022 More computation per probe" << endl;\n        cout << "   \u2022 Better distribution" << endl;\n        \n        cout << "\\n4. Open Addressing (Quadratic Probing):" << endl;\n        cout << "   \u2022 Reduces primary clustering" << endl;\n        cout << "   \u2022 May not find empty slot even if exists" << endl;\n    }\n    \n    // Memory usage comparison\n    static void analyzeMemoryUsage() {\n        cout << "\\n\\n" << string(80, \'=\') << endl;\n        cout << "Memory Usage Analysis" << endl;\n        cout << string(80, \'=\') << endl;\n        \n        cout << "Theoretical memory usage for 1000 elements:" << endl;\n        cout << left << setw(30) << "\\nData Structure" \n             << setw(20) << "Theoretical O()" \n             << setw(30) << "Estimated Memory (bytes)" << endl;\n        cout << string(80, \'-\') << endl;\n        \n        // Assuming 4-byte keys and values\n        int keySize = 4;\n        int valueSize = 4;\n        int pointerSize = 8;  // 64-bit system\n        \n        vector<pair<string, pair<string, long long>>> structures = {\n            {"Array (no gaps)", {"O(n)", 1000 * (keySize + valueSize)}},\n            {"Separate Chaining", {"O(n + m)", 1000 * (keySize + valueSize + pointerSize) + 1000 * pointerSize}},\n            {"Linear Probing", {"O(m)", 1500 * (keySize + valueSize)}},  // Assuming 1.5 load factor\n            {"std::unordered_map", {"O(n)", 1000 * (keySize + valueSize + 2 * pointerSize)}},\n            {"std::map (RB Tree)", {"O(n)", 1000 * (keySize + valueSize + 3 * pointerSize + 1)}},  // +1 for color\n            {"Sorted Array", {"O(n)", 1000 * (keySize + valueSize)}}\n        };\n        \n        for(const auto& structure : structures) {\n            cout << left << setw(30) << structure.first \n                 << setw(20) << structure.second.first \n                 << setw(30) << structure.second.second << endl;\n        }\n        \n        cout << "\\nKey Points:" << endl;\n        cout << "1. Open addressing uses less memory than chaining" << endl;\n        cout << "2. Separate chaining has pointer overhead" << endl;\n        cout << "3. Trees have more overhead than hash tables" << endl;\n        cout << "4. Arrays have best memory efficiency but fixed size" << endl;\n        cout << "5. Load factor significantly affects memory usage" << endl;\n    }\n};\n\nint main() {\n    HashTablePerformance::compareImplementations(10000);\n    HashTablePerformance::analyzeLoadFactorImpact();\n    HashTablePerformance::compareCollisionResolution();\n    HashTablePerformance::analyzeMemoryUsage();\n    \n    return 0;\n}\n'})}),"\n",(0,s.jsx)(e.h2,{id:"common-interview-questions",children:"Common Interview Questions"}),"\n",(0,s.jsx)(e.h3,{id:"1-implement-a-hashmap-from-scratch",children:"1. Implement a HashMap from scratch"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <vector>\n#include <list>\n#include <utility>\n#include <string>\nusing namespace std;\n\nclass InterviewHashMap {\nprivate:\n    vector<list<pair<string, int>>> table;\n    int capacity;\n    int size;\n    \n    int hashFunction(const string& key) const {\n        int hash = 0;\n        for(char c : key) {\n            hash = (hash * 31 + c) % capacity;\n        }\n        return hash;\n    }\n    \n    void rehash() {\n        int newCapacity = capacity * 2;\n        vector<list<pair<string, int>>> newTable(newCapacity);\n        \n        for(const auto& bucket : table) {\n            for(const auto& kv : bucket) {\n                int newIndex = hashFunction(kv.first) % newCapacity;\n                newTable[newIndex].push_back(kv);\n            }\n        }\n        \n        table = move(newTable);\n        capacity = newCapacity;\n    }\n    \npublic:\n    InterviewHashMap(int initialCapacity = 10) : capacity(initialCapacity), size(0) {\n        table.resize(capacity);\n    }\n    \n    void put(const string& key, int value) {\n        if(size * 2 >= capacity) {\n            rehash();\n        }\n        \n        int index = hashFunction(key);\n        \n        // Check if key exists\n        for(auto& kv : table[index]) {\n            if(kv.first == key) {\n                kv.second = value;\n                return;\n            }\n        }\n        \n        // Insert new key\n        table[index].emplace_back(key, value);\n        size++;\n    }\n    \n    int get(const string& key) const {\n        int index = hashFunction(key);\n        \n        for(const auto& kv : table[index]) {\n            if(kv.first == key) {\n                return kv.second;\n            }\n        }\n        \n        return -1;  // Not found\n    }\n    \n    void remove(const string& key) {\n        int index = hashFunction(key);\n        auto& bucket = table[index];\n        \n        for(auto it = bucket.begin(); it != bucket.end(); ++it) {\n            if(it->first == key) {\n                bucket.erase(it);\n                size--;\n                return;\n            }\n        }\n    }\n    \n    void display() const {\n        cout << "HashMap Contents:" << endl;\n        for(int i = 0; i < capacity; i++) {\n            if(!table[i].empty()) {\n                cout << "Bucket " << i << ": ";\n                for(const auto& kv : table[i]) {\n                    cout << "[" << kv.first << "=" << kv.second << "] ";\n                }\n                cout << endl;\n            }\n        }\n    }\n};\n\nvoid demonstrateInterviewHashMap() {\n    cout << "=== Interview Question: Implement HashMap ===" << endl;\n    \n    InterviewHashMap map(5);\n    \n    map.put("apple", 10);\n    map.put("banana", 20);\n    map.put("cherry", 30);\n    map.put("date", 40);\n    \n    map.display();\n    \n    cout << "\\nget(\'apple\'): " << map.get("apple") << endl;\n    cout << "get(\'banana\'): " << map.get("banana") << endl;\n    cout << "get(\'elderberry\'): " << map.get("elderberry") << endl;\n    \n    cout << "\\nRemoving \'banana\'..." << endl;\n    map.remove("banana");\n    map.display();\n    \n    cout << "\\nAdding more elements to trigger rehash..." << endl;\n    map.put("elderberry", 50);\n    map.put("fig", 60);\n    map.put("grape", 70);\n    \n    map.display();\n}\n'})}),"\n",(0,s.jsx)(e.h3,{id:"2-two-sum-problem-optimized",children:"2. Two Sum Problem (Optimized)"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\nusing namespace std;\n\nclass TwoSumProblems {\npublic:\n    // Basic Two Sum\n    static vector<int> twoSum(const vector<int>& nums, int target) {\n        unordered_map<int, int> numMap;  // value -> index\n        \n        for(int i = 0; i < nums.size(); i++) {\n            int complement = target - nums[i];\n            \n            if(numMap.find(complement) != numMap.end()) {\n                return {numMap[complement], i};\n            }\n            \n            numMap[nums[i]] = i;\n        }\n        \n        return {};\n    }\n    \n    // Two Sum with multiple solutions\n    static vector<vector<int>> twoSumAllPairs(const vector<int>& nums, int target) {\n        unordered_map<int, vector<int>> numMap;  // value -> indices\n        vector<vector<int>> result;\n        vector<bool> used(nums.size(), false);\n        \n        // Store all indices for each number\n        for(int i = 0; i < nums.size(); i++) {\n            numMap[nums[i]].push_back(i);\n        }\n        \n        for(int i = 0; i < nums.size(); i++) {\n            if(used[i]) continue;\n            \n            int complement = target - nums[i];\n            \n            if(numMap.find(complement) != numMap.end()) {\n                for(int j : numMap[complement]) {\n                    if(j > i && !used[j]) {  // Avoid duplicates and self-pairing\n                        result.push_back({i, j});\n                        used[i] = used[j] = true;\n                        break;\n                    }\n                }\n            }\n        }\n        \n        return result;\n    }\n    \n    // Two Sum with sorted input\n    static vector<int> twoSumSorted(const vector<int>& nums, int target) {\n        int left = 0;\n        int right = nums.size() - 1;\n        \n        while(left < right) {\n            int sum = nums[left] + nums[right];\n            \n            if(sum == target) {\n                return {left, right};\n            } else if(sum < target) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n        \n        return {};\n    }\n    \n    static void demonstrate() {\n        cout << "\\n\\n=== Two Sum Interview Problems ===" << endl;\n        \n        vector<int> nums = {2, 7, 11, 15, 3, 6, 8, 2};\n        int target = 9;\n        \n        cout << "Array: ";\n        for(int num : nums) cout << num << " ";\n        cout << "\\nTarget: " << target << endl;\n        \n        // Basic Two Sum\n        cout << "\\n1. Basic Two Sum (first pair):" << endl;\n        auto result1 = twoSum(nums, target);\n        if(!result1.empty()) {\n            cout << "Indices: [" << result1[0] << ", " << result1[1] << "]" << endl;\n            cout << "Values: " << nums[result1[0]] << " + " << nums[result1[1]] \n                 << " = " << target << endl;\n        }\n        \n        // All pairs\n        cout << "\\n2. All Two Sum pairs:" << endl;\n        auto result2 = twoSumAllPairs(nums, target);\n        for(const auto& pair : result2) {\n            cout << "  [" << pair[0] << ", " << pair[1] << "] \u2192 " \n                 << nums[pair[0]] << " + " << nums[pair[1]] << endl;\n        }\n        \n        // Sorted array version\n        cout << "\\n3. Two Sum with sorted array:" << endl;\n        vector<int> sortedNums = nums;\n        sort(sortedNums.begin(), sortedNums.end());\n        \n        cout << "Sorted array: ";\n        for(int num : sortedNums) cout << num << " ";\n        cout << endl;\n        \n        auto result3 = twoSumSorted(sortedNums, target);\n        if(!result3.empty()) {\n            cout << "Indices: [" << result3[0] << ", " << result3[1] << "]" << endl;\n            cout << "Values: " << sortedNums[result3[0]] << " + " \n                 << sortedNums[result3[1]] << " = " << target << endl;\n        }\n    }\n};\n'})}),"\n",(0,s.jsx)(e.h3,{id:"3-lru-cache-implementation",children:"3. LRU Cache Implementation"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-cpp",children:'#include <iostream>\n#include <unordered_map>\n#include <list>\nusing namespace std;\n\nclass LRUCache {\nprivate:\n    int capacity;\n    list<pair<int, int>> cache;  // (key, value) pairs, most recent at front\n    unordered_map<int, list<pair<int, int>>::iterator> cacheMap;\n    \npublic:\n    LRUCache(int cap) : capacity(cap) {}\n    \n    int get(int key) {\n        if(cacheMap.find(key) == cacheMap.end()) {\n            return -1;\n        }\n        \n        // Move to front (most recently used)\n        auto it = cacheMap[key];\n        int value = it->second;\n        cache.erase(it);\n        cache.push_front({key, value});\n        cacheMap[key] = cache.begin();\n        \n        return value;\n    }\n    \n    void put(int key, int value) {\n        if(cacheMap.find(key) != cacheMap.end()) {\n            // Update existing\n            auto it = cacheMap[key];\n            cache.erase(it);\n        } else if(cache.size() >= capacity) {\n            // Remove least recently used\n            int lruKey = cache.back().first;\n            cacheMap.erase(lruKey);\n            cache.pop_back();\n        }\n        \n        // Add to front\n        cache.push_front({key, value});\n        cacheMap[key] = cache.begin();\n    }\n    \n    void display() const {\n        cout << "LRU Cache (most recent first): ";\n        for(const auto& item : cache) {\n            cout << item.first << ":" << item.second << " ";\n        }\n        cout << endl;\n    }\n};\n\nvoid demonstrateLRUCache() {\n    cout << "\\n\\n=== LRU Cache Implementation ===" << endl;\n    \n    LRUCache cache(3);\n    \n    cout << "Cache capacity: 3" << endl;\n    \n    cache.put(1, 100);\n    cout << "put(1, 100)" << endl;\n    cache.display();\n    \n    cache.put(2, 200);\n    cout << "put(2, 200)" << endl;\n    cache.display();\n    \n    cache.put(3, 300);\n    cout << "put(3, 300)" << endl;\n    cache.display();\n    \n    cout << "\\nget(2): " << cache.get(2) << endl;\n    cache.display();\n    \n    cache.put(4, 400);  // Should remove key 1 (LRU)\n    cout << "\\nput(4, 400) - should remove key 1" << endl;\n    cache.display();\n    \n    cout << "\\nget(1): " << cache.get(1) << " (should be -1, removed)" << endl;\n    \n    cache.put(5, 500);  // Should remove key 3\n    cout << "\\nput(5, 500) - should remove key 3" << endl;\n    cache.display();\n}\n'})}),"\n",(0,s.jsx)(e.h2,{id:"summary-and-best-practices",children:"Summary and Best Practices"}),"\n",(0,s.jsx)(e.h3,{id:"hash-tables-summary",children:"Hash Tables Summary:"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Key Characteristics:"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Average Time Complexity"}),": O(1) for insert, delete, search"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Worst Case Time Complexity"}),": O(n) due to collisions"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Space Complexity"}),": O(n)"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Load Factor"}),": Critical parameter affecting performance"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Collision Resolution"}),": Chaining vs Open Addressing"]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Common Implementations:"})}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Separate Chaining"}),": Each bucket is a linked list"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Open Addressing"}),": Linear probing, quadratic probing, double hashing"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Robin Hood Hashing"}),": Variant of open addressing"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Cuckoo Hashing"}),": Uses multiple hash functions"]}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"hash-sets-vs-hash-maps",children:"Hash Sets vs Hash Maps:"}),"\n",(0,s.jsxs)(e.table,{children:[(0,s.jsx)(e.thead,{children:(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.th,{children:"Aspect"}),(0,s.jsx)(e.th,{children:"HashSet"}),(0,s.jsx)(e.th,{children:"HashMap"})]})}),(0,s.jsxs)(e.tbody,{children:[(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:(0,s.jsx)(e.strong,{children:"Stores"})}),(0,s.jsx)(e.td,{children:"Only keys"}),(0,s.jsx)(e.td,{children:"Key-value pairs"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:(0,s.jsx)(e.strong,{children:"Use Case"})}),(0,s.jsx)(e.td,{children:"Membership testing"}),(0,s.jsx)(e.td,{children:"Associative storage"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:(0,s.jsx)(e.strong,{children:"Operations"})}),(0,s.jsx)(e.td,{children:"add, remove, contains"}),(0,s.jsx)(e.td,{children:"put, get, remove"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:(0,s.jsx)(e.strong,{children:"Complexity"})}),(0,s.jsx)(e.td,{children:"Same as HashMap"}),(0,s.jsx)(e.td,{children:"Same as HashSet"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:(0,s.jsx)(e.strong,{children:"Example"})}),(0,s.jsx)(e.td,{children:"Unique words"}),(0,s.jsx)(e.td,{children:"Word frequencies"})]})]})]}),"\n",(0,s.jsx)(e.h3,{id:"time-complexity-comparison",children:"Time Complexity Comparison:"}),"\n",(0,s.jsxs)(e.table,{children:[(0,s.jsx)(e.thead,{children:(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.th,{children:"Operation"}),(0,s.jsx)(e.th,{children:"Hash Table (Avg)"}),(0,s.jsx)(e.th,{children:"Hash Table (Worst)"}),(0,s.jsx)(e.th,{children:"Balanced Tree"}),(0,s.jsx)(e.th,{children:"Sorted Array"})]})}),(0,s.jsxs)(e.tbody,{children:[(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:(0,s.jsx)(e.strong,{children:"Insert"})}),(0,s.jsx)(e.td,{children:"O(1)"}),(0,s.jsx)(e.td,{children:"O(n)"}),(0,s.jsx)(e.td,{children:"O(log n)"}),(0,s.jsx)(e.td,{children:"O(n)"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:(0,s.jsx)(e.strong,{children:"Search"})}),(0,s.jsx)(e.td,{children:"O(1)"}),(0,s.jsx)(e.td,{children:"O(n)"}),(0,s.jsx)(e.td,{children:"O(log n)"}),(0,s.jsx)(e.td,{children:"O(log n)"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:(0,s.jsx)(e.strong,{children:"Delete"})}),(0,s.jsx)(e.td,{children:"O(1)"}),(0,s.jsx)(e.td,{children:"O(n)"}),(0,s.jsx)(e.td,{children:"O(log n)"}),(0,s.jsx)(e.td,{children:"O(n)"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:(0,s.jsx)(e.strong,{children:"Min/Max"})}),(0,s.jsx)(e.td,{children:"O(n)"}),(0,s.jsx)(e.td,{children:"O(n)"}),(0,s.jsx)(e.td,{children:"O(log n)"}),(0,s.jsx)(e.td,{children:"O(1)"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:(0,s.jsx)(e.strong,{children:"Successor"})}),(0,s.jsx)(e.td,{children:"O(n)"}),(0,s.jsx)(e.td,{children:"O(n)"}),(0,s.jsx)(e.td,{children:"O(log n)"}),(0,s.jsx)(e.td,{children:"O(1)"})]})]})]}),"\n",(0,s.jsx)(e.h3,{id:"when-to-use-hash-tables",children:"When to Use Hash Tables:"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Use Hash Tables when:"})}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsx)(e.li,{children:"Need O(1) average time operations"}),"\n",(0,s.jsx)(e.li,{children:"Don't need sorted order of elements"}),"\n",(0,s.jsx)(e.li,{children:"Willing to trade worst-case performance for average-case"}),"\n",(0,s.jsx)(e.li,{children:"Have good hash function for keys"}),"\n",(0,s.jsx)(e.li,{children:"Memory is not extremely constrained"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Avoid Hash Tables when:"})}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsx)(e.li,{children:"Need guaranteed O(log n) worst-case performance"}),"\n",(0,s.jsx)(e.li,{children:"Need elements in sorted order"}),"\n",(0,s.jsx)(e.li,{children:"Memory is extremely limited"}),"\n",(0,s.jsx)(e.li,{children:"Need to frequently find min/max/successor"}),"\n",(0,s.jsx)(e.li,{children:"Keys have poor hash distribution"}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"best-practices",children:"Best Practices:"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Choose Good Hash Function"}),":"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Distributes keys uniformly"}),"\n",(0,s.jsx)(e.li,{children:"Fast to compute"}),"\n",(0,s.jsx)(e.li,{children:"Minimizes collisions"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Manage Load Factor"}),":"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Keep between 0.5 and 0.75 for best performance"}),"\n",(0,s.jsx)(e.li,{children:"Implement automatic rehashing"}),"\n",(0,s.jsx)(e.li,{children:"Monitor collision rates"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Choose Right Collision Resolution"}),":"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Separate Chaining"}),": Simple, handles high load factors"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Linear Probing"}),": Better cache performance, less memory"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Double Hashing"}),": Reduces clustering, more computation"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Consider Thread Safety"}),":"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Standard library hash tables are not thread-safe"}),"\n",(0,s.jsx)(e.li,{children:"Use synchronization or concurrent hash maps for multi-threading"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Memory Considerations"}),":"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Hash tables have overhead for buckets/pointers"}),"\n",(0,s.jsx)(e.li,{children:"Open addressing uses less memory than chaining"}),"\n",(0,s.jsx)(e.li,{children:"Consider memory locality for performance"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"common-pitfalls",children:"Common Pitfalls:"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Poor Hash Functions"}),": Lead to many collisions"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"High Load Factor"}),": Causes performance degradation"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Mutable Keys"}),": Changing key after insertion breaks hash table"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Memory Leaks"}),": Forgetting to clean up in chaining implementation"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Resize Timing"}),": Resizing too early wastes memory, too late hurts performance"]}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"real-world-applications",children:"Real-World Applications:"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Databases"}),": Indexing, join operations"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Caches"}),": LRU, LFU caches"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Compilers"}),": Symbol tables"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Networking"}),": Routing tables"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"File Systems"}),": Inode tables"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Cryptography"}),": Digital signatures, message authentication"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Machine Learning"}),": Feature hashing"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Search Engines"}),": Inverted indexes"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Gaming"}),": Game state storage"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Web Browsers"}),": DNS caching, visited URLs"]}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"stl-containers",children:"STL Containers:"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"C++ Standard Library provides:"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"std::unordered_map"}),": Hash table implementation of map"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"std::unordered_set"}),": Hash table implementation of set"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"std::unordered_multimap"}),": Hash table with duplicate keys"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"std::unordered_multiset"}),": Hash table with duplicate values"]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Comparison with ordered containers:"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"unordered_*"}),": Hash tables, average O(1), not sorted"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"map/set"}),": Red-black trees, O(log n), sorted order"]}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"performance-tips",children:"Performance Tips:"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Reserve Capacity"}),": Use ",(0,s.jsx)(e.code,{children:"reserve()"})," to avoid rehashing"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Custom Hash"}),": Provide good hash function for custom types"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Key Design"}),": Use immutable, easily hashable keys"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Profile"}),": Always profile with actual data and workload"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Consider Alternatives"}),": For small data, arrays/vectors may be faster"]}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"interview-preparation",children:"Interview Preparation:"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Common Questions:"})}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsx)(e.li,{children:"Implement hash table from scratch"}),"\n",(0,s.jsx)(e.li,{children:"Two Sum problem and variants"}),"\n",(0,s.jsx)(e.li,{children:"Design LRU/LFU cache"}),"\n",(0,s.jsx)(e.li,{children:"Group anagrams"}),"\n",(0,s.jsx)(e.li,{children:"Find first non-repeating character"}),"\n",(0,s.jsx)(e.li,{children:"Subarray sum problems"}),"\n",(0,s.jsx)(e.li,{children:"Clone graph with random pointers"}),"\n",(0,s.jsx)(e.li,{children:"Word pattern matching"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Key Concepts to Understand:"})}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsx)(e.li,{children:"How hash functions work"}),"\n",(0,s.jsx)(e.li,{children:"Collision resolution strategies"}),"\n",(0,s.jsx)(e.li,{children:"Load factor and rehashing"}),"\n",(0,s.jsx)(e.li,{children:"Time-space tradeoffs"}),"\n",(0,s.jsx)(e.li,{children:"Differences between hash tables and trees"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"Hash tables are one of the most important and widely used data structures in computer science. They provide the foundation for efficient data retrieval in countless applications and are essential knowledge for any serious programmer."}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.em,{children:"This completes our comprehensive DSA notes on Hash Tables, covering Hash Tables, Hash Sets, Hash Maps, implementations, performance analysis, and practical applications in C++."})})]})}function u(n={}){const{wrapper:e}={...(0,a.R)(),...n.components};return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(d,{...n})}):d(n)}},8453(n,e,t){t.d(e,{R:()=>r,x:()=>o});var s=t(6540);const a={},i=s.createContext(a);function r(n){const e=s.useContext(i);return s.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function o(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(a):n.components||a:r(n.components),s.createElement(i.Provider,{value:e},n.children)}}}]);